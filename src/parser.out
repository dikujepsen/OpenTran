Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    RETURN
    WHILE
    EXTERN
    SIZEOF
    COLON
    IF
    PERIOD
    ELSE
    STRUCT
    PPHASH

Grammar

Rule 0     S' -> first
Rule 1     first -> beginning_list
Rule 2     first -> empty
Rule 3     beginning_list -> beginning_list comment
Rule 4     beginning_list -> beginning_list function_declaration
Rule 5     beginning_list -> beginning_list type
Rule 6     beginning_list -> beginning_list declaration
Rule 7     beginning_list -> beginning_list compound
Rule 8     beginning_list -> beginning_list assignment_expression_semi
Rule 9     beginning_list -> beginning_list expr
Rule 10    beginning_list -> beginning_list for_loop
Rule 11    beginning_list -> empty
Rule 12    comment -> COMMENT
Rule 13    arg_params -> typeid COMMA arg_params
Rule 14    arg_params -> typeid
Rule 15    arg_params -> empty
Rule 16    arglist -> LPAREN arg_params RPAREN
Rule 17    assignment_operator -> EQUALS
Rule 18    assignment_operator -> PLUSEQUALS
Rule 19    assignment_operator -> MINUSEQUALS
Rule 20    assignment_operator -> TIMESEQUALS
Rule 21    assignment_expression -> typeid assignment_operator expr
Rule 22    assignment_expression -> identifier assignment_operator expr
Rule 23    assignment_expression -> array_reference assignment_operator expr
Rule 24    assignment_expression_semi -> assignment_expression SEMI
Rule 25    constant -> INT_CONST
Rule 26    constant -> FLOAT_CONST
Rule 27    constant -> STRING_LITERAL
Rule 28    unary_token_before -> MINUS
Rule 29    unary_token_before -> LOGNOT
Rule 30    unary_token_after -> PLUSPLUS
Rule 31    unary_token_after -> MINUSMINUS
Rule 32    unary_expression -> unary_token_before term
Rule 33    increment -> term unary_token_after
Rule 34    binop_paren -> LPAREN binop_expression RPAREN
Rule 35    binop_paren -> binop_expression
Rule 36    binop_expression -> term
Rule 37    binop_expression -> binop_paren TIMES binop_paren
Rule 38    binop_expression -> binop_paren DIVIDE binop_paren
Rule 39    binop_expression -> binop_paren binary_token binop_paren
Rule 40    binop -> binop_expression
Rule 41    expr -> unary_expression
Rule 42    expr -> binop
Rule 43    expr -> term
Rule 44    binary_token -> PLUS
Rule 45    binary_token -> MINUS
Rule 46    binary_token -> MOD
Rule 47    binary_token -> OR
Rule 48    binary_token -> AND
Rule 49    binary_token -> LSHIFT
Rule 50    binary_token -> RSHIFT
Rule 51    binary_token -> LOGOR
Rule 52    binary_token -> LOGAND
Rule 53    binary_token -> LT
Rule 54    binary_token -> GT
Rule 55    binary_token -> LE
Rule 56    binary_token -> GE
Rule 57    binary_token -> EQ
Rule 58    binary_token -> NE
Rule 59    subscript -> LBRACKET expr RBRACKET
Rule 60    subscript_list -> subscript
Rule 61    subscript_list -> subscript subscript_list
Rule 62    array_reference -> identifier subscript_list
Rule 63    for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
Rule 64    term -> identifier
Rule 65    term -> constant
Rule 66    term -> array_reference
Rule 67    compound -> LBRACE beginning_list RBRACE
Rule 68    function_declaration -> typeid arglist SEMI
Rule 69    function_declaration -> typeid arglist compound
Rule 70    declaration -> typeid SEMI
Rule 71    typeid -> type identifier
Rule 72    native_type -> VOID
Rule 73    native_type -> CHAR
Rule 74    native_type -> SHORT
Rule 75    native_type -> INT
Rule 76    native_type -> LONG
Rule 77    native_type -> FLOAT
Rule 78    native_type -> DOUBLE
Rule 79    native_type -> SIGNED
Rule 80    native_type -> UNSIGNED
Rule 81    type -> native_type
Rule 82    type -> native_type TIMES
Rule 83    identifier -> ID
Rule 84    empty -> <empty>

Terminals, with rules where they appear

AND                  : 48
CHAR                 : 73
COLON                : 
COMMA                : 13
COMMENT              : 12
DIVIDE               : 38
DO                   : 
DOUBLE               : 78
ELSE                 : 
EQ                   : 57
EQUALS               : 17
EXTERN               : 
FLOAT                : 77
FLOAT_CONST          : 26
FOR                  : 63
GE                   : 56
GT                   : 54
ID                   : 83
IF                   : 
INT                  : 75
INT_CONST            : 25
LBRACE               : 67
LBRACKET             : 59
LE                   : 55
LOGAND               : 52
LOGNOT               : 29
LOGOR                : 51
LONG                 : 76
LPAREN               : 16 34 63
LSHIFT               : 49
LT                   : 53
MINUS                : 28 45
MINUSEQUALS          : 19
MINUSMINUS           : 31
MOD                  : 46
NE                   : 58
OR                   : 47
PERIOD               : 
PLUS                 : 44
PLUSEQUALS           : 18
PLUSPLUS             : 30
PPHASH               : 
RBRACE               : 67
RBRACKET             : 59
RETURN               : 
RPAREN               : 16 34 63
RSHIFT               : 50
SEMI                 : 24 63 63 68 70
SHORT                : 74
SIGNED               : 79
SIZEOF               : 
STRING_LITERAL       : 27
STRUCT               : 
TIMES                : 37 82
TIMESEQUALS          : 20
UNSIGNED             : 80
VOID                 : 72
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arg_params           : 13 16
arglist              : 68 69
array_reference      : 23 66
assignment_expression : 24 63
assignment_expression_semi : 8
assignment_operator  : 21 22 23
beginning_list       : 1 3 4 5 6 7 8 9 10 67
binary_token         : 39
binop                : 42 63
binop_expression     : 34 35 40
binop_paren          : 37 37 38 38 39 39
comment              : 3
compound             : 7 63 69
constant             : 65
declaration          : 6
empty                : 2 11 15
expr                 : 9 21 22 23 59
first                : 0
for_loop             : 10
function_declaration : 4
identifier           : 22 62 64 71
increment            : 63
native_type          : 81 82
subscript            : 60 61
subscript_list       : 61 62
term                 : 32 33 36 43
type                 : 5 71
typeid               : 13 14 21 68 69 70
unary_expression     : 41
unary_token_after    : 33
unary_token_before   : 32

Parsing method: LALR

state 0

    (0) S' -> . first
    (1) first -> . beginning_list
    (2) first -> . empty
    (3) beginning_list -> . beginning_list comment
    (4) beginning_list -> . beginning_list function_declaration
    (5) beginning_list -> . beginning_list type
    (6) beginning_list -> . beginning_list declaration
    (7) beginning_list -> . beginning_list compound
    (8) beginning_list -> . beginning_list assignment_expression_semi
    (9) beginning_list -> . beginning_list expr
    (10) beginning_list -> . beginning_list for_loop
    (11) beginning_list -> . empty
    (84) empty -> .

    $end            reduce using rule 84 (empty -> .)
    COMMENT         reduce using rule 84 (empty -> .)
    LBRACE          reduce using rule 84 (empty -> .)
    FOR             reduce using rule 84 (empty -> .)
    VOID            reduce using rule 84 (empty -> .)
    CHAR            reduce using rule 84 (empty -> .)
    SHORT           reduce using rule 84 (empty -> .)
    INT             reduce using rule 84 (empty -> .)
    LONG            reduce using rule 84 (empty -> .)
    FLOAT           reduce using rule 84 (empty -> .)
    DOUBLE          reduce using rule 84 (empty -> .)
    SIGNED          reduce using rule 84 (empty -> .)
    UNSIGNED        reduce using rule 84 (empty -> .)
    ID              reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    LOGNOT          reduce using rule 84 (empty -> .)
    INT_CONST       reduce using rule 84 (empty -> .)
    FLOAT_CONST     reduce using rule 84 (empty -> .)
    STRING_LITERAL  reduce using rule 84 (empty -> .)
    LPAREN          reduce using rule 84 (empty -> .)

    beginning_list                 shift and go to state 1
    empty                          shift and go to state 2
    first                          shift and go to state 3

state 1

    (1) first -> beginning_list .
    (3) beginning_list -> beginning_list . comment
    (4) beginning_list -> beginning_list . function_declaration
    (5) beginning_list -> beginning_list . type
    (6) beginning_list -> beginning_list . declaration
    (7) beginning_list -> beginning_list . compound
    (8) beginning_list -> beginning_list . assignment_expression_semi
    (9) beginning_list -> beginning_list . expr
    (10) beginning_list -> beginning_list . for_loop
    (12) comment -> . COMMENT
    (68) function_declaration -> . typeid arglist SEMI
    (69) function_declaration -> . typeid arglist compound
    (81) type -> . native_type
    (82) type -> . native_type TIMES
    (70) declaration -> . typeid SEMI
    (67) compound -> . LBRACE beginning_list RBRACE
    (24) assignment_expression_semi -> . assignment_expression SEMI
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (63) for_loop -> . FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
    (71) typeid -> . type identifier
    (72) native_type -> . VOID
    (73) native_type -> . CHAR
    (74) native_type -> . SHORT
    (75) native_type -> . INT
    (76) native_type -> . LONG
    (77) native_type -> . FLOAT
    (78) native_type -> . DOUBLE
    (79) native_type -> . SIGNED
    (80) native_type -> . UNSIGNED
    (21) assignment_expression -> . typeid assignment_operator expr
    (22) assignment_expression -> . identifier assignment_operator expr
    (23) assignment_expression -> . array_reference assignment_operator expr
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (62) array_reference -> . identifier subscript_list
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    $end            reduce using rule 1 (first -> beginning_list .)
    COMMENT         shift and go to state 18
    LBRACE          shift and go to state 27
    FOR             shift and go to state 20
    VOID            shift and go to state 9
    CHAR            shift and go to state 13
    SHORT           shift and go to state 6
    INT             shift and go to state 36
    LONG            shift and go to state 22
    FLOAT           shift and go to state 38
    DOUBLE          shift and go to state 40
    SIGNED          shift and go to state 39
    UNSIGNED        shift and go to state 21
    ID              shift and go to state 30
    MINUS           shift and go to state 17
    LOGNOT          shift and go to state 14
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 28

    comment                        shift and go to state 4
    unary_token_before             shift and go to state 5
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    compound                       shift and go to state 10
    binop_paren                    shift and go to state 11
    binop_expression               shift and go to state 12
    native_type                    shift and go to state 16
    array_reference                shift and go to state 15
    type                           shift and go to state 23
    for_loop                       shift and go to state 24
    assignment_expression          shift and go to state 25
    binop                          shift and go to state 26
    declaration                    shift and go to state 29
    typeid                         shift and go to state 32
    term                           shift and go to state 33
    assignment_expression_semi     shift and go to state 34
    function_declaration           shift and go to state 35
    expr                           shift and go to state 37
    identifier                     shift and go to state 41

state 2

    (2) first -> empty .
    (11) beginning_list -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (first -> empty .)
    $end            reduce using rule 2 (first -> empty .)
    COMMENT         reduce using rule 11 (beginning_list -> empty .)
    LBRACE          reduce using rule 11 (beginning_list -> empty .)
    FOR             reduce using rule 11 (beginning_list -> empty .)
    VOID            reduce using rule 11 (beginning_list -> empty .)
    CHAR            reduce using rule 11 (beginning_list -> empty .)
    SHORT           reduce using rule 11 (beginning_list -> empty .)
    INT             reduce using rule 11 (beginning_list -> empty .)
    LONG            reduce using rule 11 (beginning_list -> empty .)
    FLOAT           reduce using rule 11 (beginning_list -> empty .)
    DOUBLE          reduce using rule 11 (beginning_list -> empty .)
    SIGNED          reduce using rule 11 (beginning_list -> empty .)
    UNSIGNED        reduce using rule 11 (beginning_list -> empty .)
    ID              reduce using rule 11 (beginning_list -> empty .)
    MINUS           reduce using rule 11 (beginning_list -> empty .)
    LOGNOT          reduce using rule 11 (beginning_list -> empty .)
    INT_CONST       reduce using rule 11 (beginning_list -> empty .)
    FLOAT_CONST     reduce using rule 11 (beginning_list -> empty .)
    STRING_LITERAL  reduce using rule 11 (beginning_list -> empty .)
    LPAREN          reduce using rule 11 (beginning_list -> empty .)

  ! $end            [ reduce using rule 11 (beginning_list -> empty .) ]


state 3

    (0) S' -> first .



state 4

    (3) beginning_list -> beginning_list comment .

    COMMENT         reduce using rule 3 (beginning_list -> beginning_list comment .)
    LBRACE          reduce using rule 3 (beginning_list -> beginning_list comment .)
    FOR             reduce using rule 3 (beginning_list -> beginning_list comment .)
    VOID            reduce using rule 3 (beginning_list -> beginning_list comment .)
    CHAR            reduce using rule 3 (beginning_list -> beginning_list comment .)
    SHORT           reduce using rule 3 (beginning_list -> beginning_list comment .)
    INT             reduce using rule 3 (beginning_list -> beginning_list comment .)
    LONG            reduce using rule 3 (beginning_list -> beginning_list comment .)
    FLOAT           reduce using rule 3 (beginning_list -> beginning_list comment .)
    DOUBLE          reduce using rule 3 (beginning_list -> beginning_list comment .)
    SIGNED          reduce using rule 3 (beginning_list -> beginning_list comment .)
    UNSIGNED        reduce using rule 3 (beginning_list -> beginning_list comment .)
    ID              reduce using rule 3 (beginning_list -> beginning_list comment .)
    MINUS           reduce using rule 3 (beginning_list -> beginning_list comment .)
    LOGNOT          reduce using rule 3 (beginning_list -> beginning_list comment .)
    INT_CONST       reduce using rule 3 (beginning_list -> beginning_list comment .)
    FLOAT_CONST     reduce using rule 3 (beginning_list -> beginning_list comment .)
    STRING_LITERAL  reduce using rule 3 (beginning_list -> beginning_list comment .)
    LPAREN          reduce using rule 3 (beginning_list -> beginning_list comment .)
    $end            reduce using rule 3 (beginning_list -> beginning_list comment .)
    RBRACE          reduce using rule 3 (beginning_list -> beginning_list comment .)


state 5

    (32) unary_expression -> unary_token_before . term
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 43
    constant                       shift and go to state 7
    array_reference                shift and go to state 44
    identifier                     shift and go to state 45

state 6

    (74) native_type -> SHORT .

    TIMES           reduce using rule 74 (native_type -> SHORT .)
    ID              reduce using rule 74 (native_type -> SHORT .)
    RBRACE          reduce using rule 74 (native_type -> SHORT .)
    COMMENT         reduce using rule 74 (native_type -> SHORT .)
    LBRACE          reduce using rule 74 (native_type -> SHORT .)
    FOR             reduce using rule 74 (native_type -> SHORT .)
    VOID            reduce using rule 74 (native_type -> SHORT .)
    CHAR            reduce using rule 74 (native_type -> SHORT .)
    SHORT           reduce using rule 74 (native_type -> SHORT .)
    INT             reduce using rule 74 (native_type -> SHORT .)
    LONG            reduce using rule 74 (native_type -> SHORT .)
    FLOAT           reduce using rule 74 (native_type -> SHORT .)
    DOUBLE          reduce using rule 74 (native_type -> SHORT .)
    SIGNED          reduce using rule 74 (native_type -> SHORT .)
    UNSIGNED        reduce using rule 74 (native_type -> SHORT .)
    MINUS           reduce using rule 74 (native_type -> SHORT .)
    LOGNOT          reduce using rule 74 (native_type -> SHORT .)
    INT_CONST       reduce using rule 74 (native_type -> SHORT .)
    FLOAT_CONST     reduce using rule 74 (native_type -> SHORT .)
    STRING_LITERAL  reduce using rule 74 (native_type -> SHORT .)
    LPAREN          reduce using rule 74 (native_type -> SHORT .)
    $end            reduce using rule 74 (native_type -> SHORT .)


state 7

    (65) term -> constant .

    SEMI            reduce using rule 65 (term -> constant .)
    TIMES           reduce using rule 65 (term -> constant .)
    DIVIDE          reduce using rule 65 (term -> constant .)
    PLUS            reduce using rule 65 (term -> constant .)
    MINUS           reduce using rule 65 (term -> constant .)
    MOD             reduce using rule 65 (term -> constant .)
    OR              reduce using rule 65 (term -> constant .)
    AND             reduce using rule 65 (term -> constant .)
    LSHIFT          reduce using rule 65 (term -> constant .)
    RSHIFT          reduce using rule 65 (term -> constant .)
    LOGOR           reduce using rule 65 (term -> constant .)
    LOGAND          reduce using rule 65 (term -> constant .)
    LT              reduce using rule 65 (term -> constant .)
    GT              reduce using rule 65 (term -> constant .)
    LE              reduce using rule 65 (term -> constant .)
    GE              reduce using rule 65 (term -> constant .)
    EQ              reduce using rule 65 (term -> constant .)
    NE              reduce using rule 65 (term -> constant .)
    COMMENT         reduce using rule 65 (term -> constant .)
    LBRACE          reduce using rule 65 (term -> constant .)
    FOR             reduce using rule 65 (term -> constant .)
    VOID            reduce using rule 65 (term -> constant .)
    CHAR            reduce using rule 65 (term -> constant .)
    SHORT           reduce using rule 65 (term -> constant .)
    INT             reduce using rule 65 (term -> constant .)
    LONG            reduce using rule 65 (term -> constant .)
    FLOAT           reduce using rule 65 (term -> constant .)
    DOUBLE          reduce using rule 65 (term -> constant .)
    SIGNED          reduce using rule 65 (term -> constant .)
    UNSIGNED        reduce using rule 65 (term -> constant .)
    ID              reduce using rule 65 (term -> constant .)
    LOGNOT          reduce using rule 65 (term -> constant .)
    INT_CONST       reduce using rule 65 (term -> constant .)
    FLOAT_CONST     reduce using rule 65 (term -> constant .)
    STRING_LITERAL  reduce using rule 65 (term -> constant .)
    LPAREN          reduce using rule 65 (term -> constant .)
    $end            reduce using rule 65 (term -> constant .)
    RPAREN          reduce using rule 65 (term -> constant .)
    RBRACE          reduce using rule 65 (term -> constant .)
    RBRACKET        reduce using rule 65 (term -> constant .)
    PLUSPLUS        reduce using rule 65 (term -> constant .)
    MINUSMINUS      reduce using rule 65 (term -> constant .)


state 8

    (41) expr -> unary_expression .

    RBRACE          reduce using rule 41 (expr -> unary_expression .)
    COMMENT         reduce using rule 41 (expr -> unary_expression .)
    LBRACE          reduce using rule 41 (expr -> unary_expression .)
    FOR             reduce using rule 41 (expr -> unary_expression .)
    VOID            reduce using rule 41 (expr -> unary_expression .)
    CHAR            reduce using rule 41 (expr -> unary_expression .)
    SHORT           reduce using rule 41 (expr -> unary_expression .)
    INT             reduce using rule 41 (expr -> unary_expression .)
    LONG            reduce using rule 41 (expr -> unary_expression .)
    FLOAT           reduce using rule 41 (expr -> unary_expression .)
    DOUBLE          reduce using rule 41 (expr -> unary_expression .)
    SIGNED          reduce using rule 41 (expr -> unary_expression .)
    UNSIGNED        reduce using rule 41 (expr -> unary_expression .)
    ID              reduce using rule 41 (expr -> unary_expression .)
    MINUS           reduce using rule 41 (expr -> unary_expression .)
    LOGNOT          reduce using rule 41 (expr -> unary_expression .)
    INT_CONST       reduce using rule 41 (expr -> unary_expression .)
    FLOAT_CONST     reduce using rule 41 (expr -> unary_expression .)
    STRING_LITERAL  reduce using rule 41 (expr -> unary_expression .)
    LPAREN          reduce using rule 41 (expr -> unary_expression .)
    SEMI            reduce using rule 41 (expr -> unary_expression .)
    RBRACKET        reduce using rule 41 (expr -> unary_expression .)
    $end            reduce using rule 41 (expr -> unary_expression .)


state 9

    (72) native_type -> VOID .

    TIMES           reduce using rule 72 (native_type -> VOID .)
    ID              reduce using rule 72 (native_type -> VOID .)
    RBRACE          reduce using rule 72 (native_type -> VOID .)
    COMMENT         reduce using rule 72 (native_type -> VOID .)
    LBRACE          reduce using rule 72 (native_type -> VOID .)
    FOR             reduce using rule 72 (native_type -> VOID .)
    VOID            reduce using rule 72 (native_type -> VOID .)
    CHAR            reduce using rule 72 (native_type -> VOID .)
    SHORT           reduce using rule 72 (native_type -> VOID .)
    INT             reduce using rule 72 (native_type -> VOID .)
    LONG            reduce using rule 72 (native_type -> VOID .)
    FLOAT           reduce using rule 72 (native_type -> VOID .)
    DOUBLE          reduce using rule 72 (native_type -> VOID .)
    SIGNED          reduce using rule 72 (native_type -> VOID .)
    UNSIGNED        reduce using rule 72 (native_type -> VOID .)
    MINUS           reduce using rule 72 (native_type -> VOID .)
    LOGNOT          reduce using rule 72 (native_type -> VOID .)
    INT_CONST       reduce using rule 72 (native_type -> VOID .)
    FLOAT_CONST     reduce using rule 72 (native_type -> VOID .)
    STRING_LITERAL  reduce using rule 72 (native_type -> VOID .)
    LPAREN          reduce using rule 72 (native_type -> VOID .)
    $end            reduce using rule 72 (native_type -> VOID .)


state 10

    (7) beginning_list -> beginning_list compound .

    COMMENT         reduce using rule 7 (beginning_list -> beginning_list compound .)
    LBRACE          reduce using rule 7 (beginning_list -> beginning_list compound .)
    FOR             reduce using rule 7 (beginning_list -> beginning_list compound .)
    VOID            reduce using rule 7 (beginning_list -> beginning_list compound .)
    CHAR            reduce using rule 7 (beginning_list -> beginning_list compound .)
    SHORT           reduce using rule 7 (beginning_list -> beginning_list compound .)
    INT             reduce using rule 7 (beginning_list -> beginning_list compound .)
    LONG            reduce using rule 7 (beginning_list -> beginning_list compound .)
    FLOAT           reduce using rule 7 (beginning_list -> beginning_list compound .)
    DOUBLE          reduce using rule 7 (beginning_list -> beginning_list compound .)
    SIGNED          reduce using rule 7 (beginning_list -> beginning_list compound .)
    UNSIGNED        reduce using rule 7 (beginning_list -> beginning_list compound .)
    ID              reduce using rule 7 (beginning_list -> beginning_list compound .)
    MINUS           reduce using rule 7 (beginning_list -> beginning_list compound .)
    LOGNOT          reduce using rule 7 (beginning_list -> beginning_list compound .)
    INT_CONST       reduce using rule 7 (beginning_list -> beginning_list compound .)
    FLOAT_CONST     reduce using rule 7 (beginning_list -> beginning_list compound .)
    STRING_LITERAL  reduce using rule 7 (beginning_list -> beginning_list compound .)
    LPAREN          reduce using rule 7 (beginning_list -> beginning_list compound .)
    $end            reduce using rule 7 (beginning_list -> beginning_list compound .)
    RBRACE          reduce using rule 7 (beginning_list -> beginning_list compound .)


state 11

    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

    TIMES           shift and go to state 54
    DIVIDE          shift and go to state 50
    PLUS            shift and go to state 57
    MINUS           shift and go to state 61
    MOD             shift and go to state 59
    OR              shift and go to state 47
    AND             shift and go to state 46
    LSHIFT          shift and go to state 58
    RSHIFT          shift and go to state 49
    LOGOR           shift and go to state 51
    LOGAND          shift and go to state 52
    LT              shift and go to state 55
    GT              shift and go to state 48
    LE              shift and go to state 56
    GE              shift and go to state 53
    EQ              shift and go to state 60
    NE              shift and go to state 62

    binary_token                   shift and go to state 63

state 12

    (40) binop -> binop_expression .
    (35) binop_paren -> binop_expression .

  ! reduce/reduce conflict for MINUS resolved using rule 35 (binop_paren -> binop_expression .)
    SEMI            reduce using rule 40 (binop -> binop_expression .)
    RBRACE          reduce using rule 40 (binop -> binop_expression .)
    COMMENT         reduce using rule 40 (binop -> binop_expression .)
    LBRACE          reduce using rule 40 (binop -> binop_expression .)
    FOR             reduce using rule 40 (binop -> binop_expression .)
    VOID            reduce using rule 40 (binop -> binop_expression .)
    CHAR            reduce using rule 40 (binop -> binop_expression .)
    SHORT           reduce using rule 40 (binop -> binop_expression .)
    INT             reduce using rule 40 (binop -> binop_expression .)
    LONG            reduce using rule 40 (binop -> binop_expression .)
    FLOAT           reduce using rule 40 (binop -> binop_expression .)
    DOUBLE          reduce using rule 40 (binop -> binop_expression .)
    SIGNED          reduce using rule 40 (binop -> binop_expression .)
    UNSIGNED        reduce using rule 40 (binop -> binop_expression .)
    ID              reduce using rule 40 (binop -> binop_expression .)
    LOGNOT          reduce using rule 40 (binop -> binop_expression .)
    INT_CONST       reduce using rule 40 (binop -> binop_expression .)
    FLOAT_CONST     reduce using rule 40 (binop -> binop_expression .)
    STRING_LITERAL  reduce using rule 40 (binop -> binop_expression .)
    LPAREN          reduce using rule 40 (binop -> binop_expression .)
    RBRACKET        reduce using rule 40 (binop -> binop_expression .)
    $end            reduce using rule 40 (binop -> binop_expression .)
    TIMES           reduce using rule 35 (binop_paren -> binop_expression .)
    DIVIDE          reduce using rule 35 (binop_paren -> binop_expression .)
    PLUS            reduce using rule 35 (binop_paren -> binop_expression .)
    MINUS           reduce using rule 35 (binop_paren -> binop_expression .)
    MOD             reduce using rule 35 (binop_paren -> binop_expression .)
    OR              reduce using rule 35 (binop_paren -> binop_expression .)
    AND             reduce using rule 35 (binop_paren -> binop_expression .)
    LSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    RSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    LOGOR           reduce using rule 35 (binop_paren -> binop_expression .)
    LOGAND          reduce using rule 35 (binop_paren -> binop_expression .)
    LT              reduce using rule 35 (binop_paren -> binop_expression .)
    GT              reduce using rule 35 (binop_paren -> binop_expression .)
    LE              reduce using rule 35 (binop_paren -> binop_expression .)
    GE              reduce using rule 35 (binop_paren -> binop_expression .)
    EQ              reduce using rule 35 (binop_paren -> binop_expression .)
    NE              reduce using rule 35 (binop_paren -> binop_expression .)

  ! MINUS           [ reduce using rule 40 (binop -> binop_expression .) ]


state 13

    (73) native_type -> CHAR .

    TIMES           reduce using rule 73 (native_type -> CHAR .)
    ID              reduce using rule 73 (native_type -> CHAR .)
    RBRACE          reduce using rule 73 (native_type -> CHAR .)
    COMMENT         reduce using rule 73 (native_type -> CHAR .)
    LBRACE          reduce using rule 73 (native_type -> CHAR .)
    FOR             reduce using rule 73 (native_type -> CHAR .)
    VOID            reduce using rule 73 (native_type -> CHAR .)
    CHAR            reduce using rule 73 (native_type -> CHAR .)
    SHORT           reduce using rule 73 (native_type -> CHAR .)
    INT             reduce using rule 73 (native_type -> CHAR .)
    LONG            reduce using rule 73 (native_type -> CHAR .)
    FLOAT           reduce using rule 73 (native_type -> CHAR .)
    DOUBLE          reduce using rule 73 (native_type -> CHAR .)
    SIGNED          reduce using rule 73 (native_type -> CHAR .)
    UNSIGNED        reduce using rule 73 (native_type -> CHAR .)
    MINUS           reduce using rule 73 (native_type -> CHAR .)
    LOGNOT          reduce using rule 73 (native_type -> CHAR .)
    INT_CONST       reduce using rule 73 (native_type -> CHAR .)
    FLOAT_CONST     reduce using rule 73 (native_type -> CHAR .)
    STRING_LITERAL  reduce using rule 73 (native_type -> CHAR .)
    LPAREN          reduce using rule 73 (native_type -> CHAR .)
    $end            reduce using rule 73 (native_type -> CHAR .)


state 14

    (29) unary_token_before -> LOGNOT .

    ID              reduce using rule 29 (unary_token_before -> LOGNOT .)
    INT_CONST       reduce using rule 29 (unary_token_before -> LOGNOT .)
    FLOAT_CONST     reduce using rule 29 (unary_token_before -> LOGNOT .)
    STRING_LITERAL  reduce using rule 29 (unary_token_before -> LOGNOT .)


state 15

    (23) assignment_expression -> array_reference . assignment_operator expr
    (66) term -> array_reference .
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    COMMENT         reduce using rule 66 (term -> array_reference .)
    LBRACE          reduce using rule 66 (term -> array_reference .)
    FOR             reduce using rule 66 (term -> array_reference .)
    VOID            reduce using rule 66 (term -> array_reference .)
    CHAR            reduce using rule 66 (term -> array_reference .)
    SHORT           reduce using rule 66 (term -> array_reference .)
    INT             reduce using rule 66 (term -> array_reference .)
    LONG            reduce using rule 66 (term -> array_reference .)
    FLOAT           reduce using rule 66 (term -> array_reference .)
    DOUBLE          reduce using rule 66 (term -> array_reference .)
    SIGNED          reduce using rule 66 (term -> array_reference .)
    UNSIGNED        reduce using rule 66 (term -> array_reference .)
    ID              reduce using rule 66 (term -> array_reference .)
    MINUS           reduce using rule 66 (term -> array_reference .)
    LOGNOT          reduce using rule 66 (term -> array_reference .)
    INT_CONST       reduce using rule 66 (term -> array_reference .)
    FLOAT_CONST     reduce using rule 66 (term -> array_reference .)
    STRING_LITERAL  reduce using rule 66 (term -> array_reference .)
    LPAREN          reduce using rule 66 (term -> array_reference .)
    $end            reduce using rule 66 (term -> array_reference .)
    TIMES           reduce using rule 66 (term -> array_reference .)
    DIVIDE          reduce using rule 66 (term -> array_reference .)
    PLUS            reduce using rule 66 (term -> array_reference .)
    MOD             reduce using rule 66 (term -> array_reference .)
    OR              reduce using rule 66 (term -> array_reference .)
    AND             reduce using rule 66 (term -> array_reference .)
    LSHIFT          reduce using rule 66 (term -> array_reference .)
    RSHIFT          reduce using rule 66 (term -> array_reference .)
    LOGOR           reduce using rule 66 (term -> array_reference .)
    LOGAND          reduce using rule 66 (term -> array_reference .)
    LT              reduce using rule 66 (term -> array_reference .)
    GT              reduce using rule 66 (term -> array_reference .)
    LE              reduce using rule 66 (term -> array_reference .)
    GE              reduce using rule 66 (term -> array_reference .)
    EQ              reduce using rule 66 (term -> array_reference .)
    NE              reduce using rule 66 (term -> array_reference .)
    RBRACE          reduce using rule 66 (term -> array_reference .)
    EQUALS          shift and go to state 64
    PLUSEQUALS      shift and go to state 65
    MINUSEQUALS     shift and go to state 67
    TIMESEQUALS     shift and go to state 68

    assignment_operator            shift and go to state 66

state 16

    (81) type -> native_type .
    (82) type -> native_type . TIMES

    ID              reduce using rule 81 (type -> native_type .)
    RBRACE          reduce using rule 81 (type -> native_type .)
    COMMENT         reduce using rule 81 (type -> native_type .)
    LBRACE          reduce using rule 81 (type -> native_type .)
    FOR             reduce using rule 81 (type -> native_type .)
    VOID            reduce using rule 81 (type -> native_type .)
    CHAR            reduce using rule 81 (type -> native_type .)
    SHORT           reduce using rule 81 (type -> native_type .)
    INT             reduce using rule 81 (type -> native_type .)
    LONG            reduce using rule 81 (type -> native_type .)
    FLOAT           reduce using rule 81 (type -> native_type .)
    DOUBLE          reduce using rule 81 (type -> native_type .)
    SIGNED          reduce using rule 81 (type -> native_type .)
    UNSIGNED        reduce using rule 81 (type -> native_type .)
    MINUS           reduce using rule 81 (type -> native_type .)
    LOGNOT          reduce using rule 81 (type -> native_type .)
    INT_CONST       reduce using rule 81 (type -> native_type .)
    FLOAT_CONST     reduce using rule 81 (type -> native_type .)
    STRING_LITERAL  reduce using rule 81 (type -> native_type .)
    LPAREN          reduce using rule 81 (type -> native_type .)
    $end            reduce using rule 81 (type -> native_type .)
    TIMES           shift and go to state 69


state 17

    (28) unary_token_before -> MINUS .

    ID              reduce using rule 28 (unary_token_before -> MINUS .)
    INT_CONST       reduce using rule 28 (unary_token_before -> MINUS .)
    FLOAT_CONST     reduce using rule 28 (unary_token_before -> MINUS .)
    STRING_LITERAL  reduce using rule 28 (unary_token_before -> MINUS .)


state 18

    (12) comment -> COMMENT .

    RBRACE          reduce using rule 12 (comment -> COMMENT .)
    COMMENT         reduce using rule 12 (comment -> COMMENT .)
    LBRACE          reduce using rule 12 (comment -> COMMENT .)
    FOR             reduce using rule 12 (comment -> COMMENT .)
    VOID            reduce using rule 12 (comment -> COMMENT .)
    CHAR            reduce using rule 12 (comment -> COMMENT .)
    SHORT           reduce using rule 12 (comment -> COMMENT .)
    INT             reduce using rule 12 (comment -> COMMENT .)
    LONG            reduce using rule 12 (comment -> COMMENT .)
    FLOAT           reduce using rule 12 (comment -> COMMENT .)
    DOUBLE          reduce using rule 12 (comment -> COMMENT .)
    SIGNED          reduce using rule 12 (comment -> COMMENT .)
    UNSIGNED        reduce using rule 12 (comment -> COMMENT .)
    ID              reduce using rule 12 (comment -> COMMENT .)
    MINUS           reduce using rule 12 (comment -> COMMENT .)
    LOGNOT          reduce using rule 12 (comment -> COMMENT .)
    INT_CONST       reduce using rule 12 (comment -> COMMENT .)
    FLOAT_CONST     reduce using rule 12 (comment -> COMMENT .)
    STRING_LITERAL  reduce using rule 12 (comment -> COMMENT .)
    LPAREN          reduce using rule 12 (comment -> COMMENT .)
    $end            reduce using rule 12 (comment -> COMMENT .)


state 19

    (25) constant -> INT_CONST .

    TIMES           reduce using rule 25 (constant -> INT_CONST .)
    DIVIDE          reduce using rule 25 (constant -> INT_CONST .)
    PLUS            reduce using rule 25 (constant -> INT_CONST .)
    MINUS           reduce using rule 25 (constant -> INT_CONST .)
    MOD             reduce using rule 25 (constant -> INT_CONST .)
    OR              reduce using rule 25 (constant -> INT_CONST .)
    AND             reduce using rule 25 (constant -> INT_CONST .)
    LSHIFT          reduce using rule 25 (constant -> INT_CONST .)
    RSHIFT          reduce using rule 25 (constant -> INT_CONST .)
    LOGOR           reduce using rule 25 (constant -> INT_CONST .)
    LOGAND          reduce using rule 25 (constant -> INT_CONST .)
    LT              reduce using rule 25 (constant -> INT_CONST .)
    GT              reduce using rule 25 (constant -> INT_CONST .)
    LE              reduce using rule 25 (constant -> INT_CONST .)
    GE              reduce using rule 25 (constant -> INT_CONST .)
    EQ              reduce using rule 25 (constant -> INT_CONST .)
    NE              reduce using rule 25 (constant -> INT_CONST .)
    COMMENT         reduce using rule 25 (constant -> INT_CONST .)
    LBRACE          reduce using rule 25 (constant -> INT_CONST .)
    FOR             reduce using rule 25 (constant -> INT_CONST .)
    VOID            reduce using rule 25 (constant -> INT_CONST .)
    CHAR            reduce using rule 25 (constant -> INT_CONST .)
    SHORT           reduce using rule 25 (constant -> INT_CONST .)
    INT             reduce using rule 25 (constant -> INT_CONST .)
    LONG            reduce using rule 25 (constant -> INT_CONST .)
    FLOAT           reduce using rule 25 (constant -> INT_CONST .)
    DOUBLE          reduce using rule 25 (constant -> INT_CONST .)
    SIGNED          reduce using rule 25 (constant -> INT_CONST .)
    UNSIGNED        reduce using rule 25 (constant -> INT_CONST .)
    ID              reduce using rule 25 (constant -> INT_CONST .)
    LOGNOT          reduce using rule 25 (constant -> INT_CONST .)
    INT_CONST       reduce using rule 25 (constant -> INT_CONST .)
    FLOAT_CONST     reduce using rule 25 (constant -> INT_CONST .)
    STRING_LITERAL  reduce using rule 25 (constant -> INT_CONST .)
    LPAREN          reduce using rule 25 (constant -> INT_CONST .)
    $end            reduce using rule 25 (constant -> INT_CONST .)
    RPAREN          reduce using rule 25 (constant -> INT_CONST .)
    SEMI            reduce using rule 25 (constant -> INT_CONST .)
    RBRACE          reduce using rule 25 (constant -> INT_CONST .)
    RBRACKET        reduce using rule 25 (constant -> INT_CONST .)
    PLUSPLUS        reduce using rule 25 (constant -> INT_CONST .)
    MINUSMINUS      reduce using rule 25 (constant -> INT_CONST .)


state 20

    (63) for_loop -> FOR . LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound

    LPAREN          shift and go to state 70


state 21

    (80) native_type -> UNSIGNED .

    TIMES           reduce using rule 80 (native_type -> UNSIGNED .)
    ID              reduce using rule 80 (native_type -> UNSIGNED .)
    RBRACE          reduce using rule 80 (native_type -> UNSIGNED .)
    COMMENT         reduce using rule 80 (native_type -> UNSIGNED .)
    LBRACE          reduce using rule 80 (native_type -> UNSIGNED .)
    FOR             reduce using rule 80 (native_type -> UNSIGNED .)
    VOID            reduce using rule 80 (native_type -> UNSIGNED .)
    CHAR            reduce using rule 80 (native_type -> UNSIGNED .)
    SHORT           reduce using rule 80 (native_type -> UNSIGNED .)
    INT             reduce using rule 80 (native_type -> UNSIGNED .)
    LONG            reduce using rule 80 (native_type -> UNSIGNED .)
    FLOAT           reduce using rule 80 (native_type -> UNSIGNED .)
    DOUBLE          reduce using rule 80 (native_type -> UNSIGNED .)
    SIGNED          reduce using rule 80 (native_type -> UNSIGNED .)
    UNSIGNED        reduce using rule 80 (native_type -> UNSIGNED .)
    MINUS           reduce using rule 80 (native_type -> UNSIGNED .)
    LOGNOT          reduce using rule 80 (native_type -> UNSIGNED .)
    INT_CONST       reduce using rule 80 (native_type -> UNSIGNED .)
    FLOAT_CONST     reduce using rule 80 (native_type -> UNSIGNED .)
    STRING_LITERAL  reduce using rule 80 (native_type -> UNSIGNED .)
    LPAREN          reduce using rule 80 (native_type -> UNSIGNED .)
    $end            reduce using rule 80 (native_type -> UNSIGNED .)


state 22

    (76) native_type -> LONG .

    TIMES           reduce using rule 76 (native_type -> LONG .)
    ID              reduce using rule 76 (native_type -> LONG .)
    RBRACE          reduce using rule 76 (native_type -> LONG .)
    COMMENT         reduce using rule 76 (native_type -> LONG .)
    LBRACE          reduce using rule 76 (native_type -> LONG .)
    FOR             reduce using rule 76 (native_type -> LONG .)
    VOID            reduce using rule 76 (native_type -> LONG .)
    CHAR            reduce using rule 76 (native_type -> LONG .)
    SHORT           reduce using rule 76 (native_type -> LONG .)
    INT             reduce using rule 76 (native_type -> LONG .)
    LONG            reduce using rule 76 (native_type -> LONG .)
    FLOAT           reduce using rule 76 (native_type -> LONG .)
    DOUBLE          reduce using rule 76 (native_type -> LONG .)
    SIGNED          reduce using rule 76 (native_type -> LONG .)
    UNSIGNED        reduce using rule 76 (native_type -> LONG .)
    MINUS           reduce using rule 76 (native_type -> LONG .)
    LOGNOT          reduce using rule 76 (native_type -> LONG .)
    INT_CONST       reduce using rule 76 (native_type -> LONG .)
    FLOAT_CONST     reduce using rule 76 (native_type -> LONG .)
    STRING_LITERAL  reduce using rule 76 (native_type -> LONG .)
    LPAREN          reduce using rule 76 (native_type -> LONG .)
    $end            reduce using rule 76 (native_type -> LONG .)


state 23

    (5) beginning_list -> beginning_list type .
    (71) typeid -> type . identifier
    (83) identifier -> . ID

  ! shift/reduce conflict for ID resolved as shift
    COMMENT         reduce using rule 5 (beginning_list -> beginning_list type .)
    LBRACE          reduce using rule 5 (beginning_list -> beginning_list type .)
    FOR             reduce using rule 5 (beginning_list -> beginning_list type .)
    VOID            reduce using rule 5 (beginning_list -> beginning_list type .)
    CHAR            reduce using rule 5 (beginning_list -> beginning_list type .)
    SHORT           reduce using rule 5 (beginning_list -> beginning_list type .)
    INT             reduce using rule 5 (beginning_list -> beginning_list type .)
    LONG            reduce using rule 5 (beginning_list -> beginning_list type .)
    FLOAT           reduce using rule 5 (beginning_list -> beginning_list type .)
    DOUBLE          reduce using rule 5 (beginning_list -> beginning_list type .)
    SIGNED          reduce using rule 5 (beginning_list -> beginning_list type .)
    UNSIGNED        reduce using rule 5 (beginning_list -> beginning_list type .)
    MINUS           reduce using rule 5 (beginning_list -> beginning_list type .)
    LOGNOT          reduce using rule 5 (beginning_list -> beginning_list type .)
    INT_CONST       reduce using rule 5 (beginning_list -> beginning_list type .)
    FLOAT_CONST     reduce using rule 5 (beginning_list -> beginning_list type .)
    STRING_LITERAL  reduce using rule 5 (beginning_list -> beginning_list type .)
    LPAREN          reduce using rule 5 (beginning_list -> beginning_list type .)
    $end            reduce using rule 5 (beginning_list -> beginning_list type .)
    RBRACE          reduce using rule 5 (beginning_list -> beginning_list type .)
    ID              shift and go to state 30

  ! ID              [ reduce using rule 5 (beginning_list -> beginning_list type .) ]

    identifier                     shift and go to state 71

state 24

    (10) beginning_list -> beginning_list for_loop .

    COMMENT         reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LBRACE          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    FOR             reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    VOID            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    CHAR            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    SHORT           reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    INT             reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LONG            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    FLOAT           reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    DOUBLE          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    SIGNED          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    UNSIGNED        reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    ID              reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    MINUS           reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LOGNOT          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    INT_CONST       reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    FLOAT_CONST     reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    STRING_LITERAL  reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LPAREN          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    $end            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    RBRACE          reduce using rule 10 (beginning_list -> beginning_list for_loop .)


state 25

    (24) assignment_expression_semi -> assignment_expression . SEMI

    SEMI            shift and go to state 72


state 26

    (42) expr -> binop .

    RBRACE          reduce using rule 42 (expr -> binop .)
    COMMENT         reduce using rule 42 (expr -> binop .)
    LBRACE          reduce using rule 42 (expr -> binop .)
    FOR             reduce using rule 42 (expr -> binop .)
    VOID            reduce using rule 42 (expr -> binop .)
    CHAR            reduce using rule 42 (expr -> binop .)
    SHORT           reduce using rule 42 (expr -> binop .)
    INT             reduce using rule 42 (expr -> binop .)
    LONG            reduce using rule 42 (expr -> binop .)
    FLOAT           reduce using rule 42 (expr -> binop .)
    DOUBLE          reduce using rule 42 (expr -> binop .)
    SIGNED          reduce using rule 42 (expr -> binop .)
    UNSIGNED        reduce using rule 42 (expr -> binop .)
    ID              reduce using rule 42 (expr -> binop .)
    MINUS           reduce using rule 42 (expr -> binop .)
    LOGNOT          reduce using rule 42 (expr -> binop .)
    INT_CONST       reduce using rule 42 (expr -> binop .)
    FLOAT_CONST     reduce using rule 42 (expr -> binop .)
    STRING_LITERAL  reduce using rule 42 (expr -> binop .)
    LPAREN          reduce using rule 42 (expr -> binop .)
    SEMI            reduce using rule 42 (expr -> binop .)
    RBRACKET        reduce using rule 42 (expr -> binop .)
    $end            reduce using rule 42 (expr -> binop .)


state 27

    (67) compound -> LBRACE . beginning_list RBRACE
    (3) beginning_list -> . beginning_list comment
    (4) beginning_list -> . beginning_list function_declaration
    (5) beginning_list -> . beginning_list type
    (6) beginning_list -> . beginning_list declaration
    (7) beginning_list -> . beginning_list compound
    (8) beginning_list -> . beginning_list assignment_expression_semi
    (9) beginning_list -> . beginning_list expr
    (10) beginning_list -> . beginning_list for_loop
    (11) beginning_list -> . empty
    (84) empty -> .

    RBRACE          reduce using rule 84 (empty -> .)
    COMMENT         reduce using rule 84 (empty -> .)
    LBRACE          reduce using rule 84 (empty -> .)
    FOR             reduce using rule 84 (empty -> .)
    VOID            reduce using rule 84 (empty -> .)
    CHAR            reduce using rule 84 (empty -> .)
    SHORT           reduce using rule 84 (empty -> .)
    INT             reduce using rule 84 (empty -> .)
    LONG            reduce using rule 84 (empty -> .)
    FLOAT           reduce using rule 84 (empty -> .)
    DOUBLE          reduce using rule 84 (empty -> .)
    SIGNED          reduce using rule 84 (empty -> .)
    UNSIGNED        reduce using rule 84 (empty -> .)
    ID              reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    LOGNOT          reduce using rule 84 (empty -> .)
    INT_CONST       reduce using rule 84 (empty -> .)
    FLOAT_CONST     reduce using rule 84 (empty -> .)
    STRING_LITERAL  reduce using rule 84 (empty -> .)
    LPAREN          reduce using rule 84 (empty -> .)

    beginning_list                 shift and go to state 73
    empty                          shift and go to state 74

state 28

    (34) binop_paren -> LPAREN . binop_expression RPAREN
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 75
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 11
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 76
    identifier                     shift and go to state 45

state 29

    (6) beginning_list -> beginning_list declaration .

    COMMENT         reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LBRACE          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    FOR             reduce using rule 6 (beginning_list -> beginning_list declaration .)
    VOID            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    CHAR            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    SHORT           reduce using rule 6 (beginning_list -> beginning_list declaration .)
    INT             reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LONG            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    FLOAT           reduce using rule 6 (beginning_list -> beginning_list declaration .)
    DOUBLE          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    SIGNED          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    UNSIGNED        reduce using rule 6 (beginning_list -> beginning_list declaration .)
    ID              reduce using rule 6 (beginning_list -> beginning_list declaration .)
    MINUS           reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LOGNOT          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    INT_CONST       reduce using rule 6 (beginning_list -> beginning_list declaration .)
    FLOAT_CONST     reduce using rule 6 (beginning_list -> beginning_list declaration .)
    STRING_LITERAL  reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LPAREN          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    $end            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    RBRACE          reduce using rule 6 (beginning_list -> beginning_list declaration .)


state 30

    (83) identifier -> ID .

    EQUALS          reduce using rule 83 (identifier -> ID .)
    PLUSEQUALS      reduce using rule 83 (identifier -> ID .)
    MINUSEQUALS     reduce using rule 83 (identifier -> ID .)
    TIMESEQUALS     reduce using rule 83 (identifier -> ID .)
    LBRACKET        reduce using rule 83 (identifier -> ID .)
    RBRACE          reduce using rule 83 (identifier -> ID .)
    COMMENT         reduce using rule 83 (identifier -> ID .)
    LBRACE          reduce using rule 83 (identifier -> ID .)
    FOR             reduce using rule 83 (identifier -> ID .)
    VOID            reduce using rule 83 (identifier -> ID .)
    CHAR            reduce using rule 83 (identifier -> ID .)
    SHORT           reduce using rule 83 (identifier -> ID .)
    INT             reduce using rule 83 (identifier -> ID .)
    LONG            reduce using rule 83 (identifier -> ID .)
    FLOAT           reduce using rule 83 (identifier -> ID .)
    DOUBLE          reduce using rule 83 (identifier -> ID .)
    SIGNED          reduce using rule 83 (identifier -> ID .)
    UNSIGNED        reduce using rule 83 (identifier -> ID .)
    ID              reduce using rule 83 (identifier -> ID .)
    MINUS           reduce using rule 83 (identifier -> ID .)
    LOGNOT          reduce using rule 83 (identifier -> ID .)
    INT_CONST       reduce using rule 83 (identifier -> ID .)
    FLOAT_CONST     reduce using rule 83 (identifier -> ID .)
    STRING_LITERAL  reduce using rule 83 (identifier -> ID .)
    LPAREN          reduce using rule 83 (identifier -> ID .)
    TIMES           reduce using rule 83 (identifier -> ID .)
    DIVIDE          reduce using rule 83 (identifier -> ID .)
    PLUS            reduce using rule 83 (identifier -> ID .)
    MOD             reduce using rule 83 (identifier -> ID .)
    OR              reduce using rule 83 (identifier -> ID .)
    AND             reduce using rule 83 (identifier -> ID .)
    LSHIFT          reduce using rule 83 (identifier -> ID .)
    RSHIFT          reduce using rule 83 (identifier -> ID .)
    LOGOR           reduce using rule 83 (identifier -> ID .)
    LOGAND          reduce using rule 83 (identifier -> ID .)
    LT              reduce using rule 83 (identifier -> ID .)
    GT              reduce using rule 83 (identifier -> ID .)
    LE              reduce using rule 83 (identifier -> ID .)
    GE              reduce using rule 83 (identifier -> ID .)
    EQ              reduce using rule 83 (identifier -> ID .)
    NE              reduce using rule 83 (identifier -> ID .)
    RBRACKET        reduce using rule 83 (identifier -> ID .)
    $end            reduce using rule 83 (identifier -> ID .)
    SEMI            reduce using rule 83 (identifier -> ID .)
    RPAREN          reduce using rule 83 (identifier -> ID .)
    COMMA           reduce using rule 83 (identifier -> ID .)
    PLUSPLUS        reduce using rule 83 (identifier -> ID .)
    MINUSMINUS      reduce using rule 83 (identifier -> ID .)


state 31

    (27) constant -> STRING_LITERAL .

    TIMES           reduce using rule 27 (constant -> STRING_LITERAL .)
    DIVIDE          reduce using rule 27 (constant -> STRING_LITERAL .)
    PLUS            reduce using rule 27 (constant -> STRING_LITERAL .)
    MINUS           reduce using rule 27 (constant -> STRING_LITERAL .)
    MOD             reduce using rule 27 (constant -> STRING_LITERAL .)
    OR              reduce using rule 27 (constant -> STRING_LITERAL .)
    AND             reduce using rule 27 (constant -> STRING_LITERAL .)
    LSHIFT          reduce using rule 27 (constant -> STRING_LITERAL .)
    RSHIFT          reduce using rule 27 (constant -> STRING_LITERAL .)
    LOGOR           reduce using rule 27 (constant -> STRING_LITERAL .)
    LOGAND          reduce using rule 27 (constant -> STRING_LITERAL .)
    LT              reduce using rule 27 (constant -> STRING_LITERAL .)
    GT              reduce using rule 27 (constant -> STRING_LITERAL .)
    LE              reduce using rule 27 (constant -> STRING_LITERAL .)
    GE              reduce using rule 27 (constant -> STRING_LITERAL .)
    EQ              reduce using rule 27 (constant -> STRING_LITERAL .)
    NE              reduce using rule 27 (constant -> STRING_LITERAL .)
    COMMENT         reduce using rule 27 (constant -> STRING_LITERAL .)
    LBRACE          reduce using rule 27 (constant -> STRING_LITERAL .)
    FOR             reduce using rule 27 (constant -> STRING_LITERAL .)
    VOID            reduce using rule 27 (constant -> STRING_LITERAL .)
    CHAR            reduce using rule 27 (constant -> STRING_LITERAL .)
    SHORT           reduce using rule 27 (constant -> STRING_LITERAL .)
    INT             reduce using rule 27 (constant -> STRING_LITERAL .)
    LONG            reduce using rule 27 (constant -> STRING_LITERAL .)
    FLOAT           reduce using rule 27 (constant -> STRING_LITERAL .)
    DOUBLE          reduce using rule 27 (constant -> STRING_LITERAL .)
    SIGNED          reduce using rule 27 (constant -> STRING_LITERAL .)
    UNSIGNED        reduce using rule 27 (constant -> STRING_LITERAL .)
    ID              reduce using rule 27 (constant -> STRING_LITERAL .)
    LOGNOT          reduce using rule 27 (constant -> STRING_LITERAL .)
    INT_CONST       reduce using rule 27 (constant -> STRING_LITERAL .)
    FLOAT_CONST     reduce using rule 27 (constant -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 27 (constant -> STRING_LITERAL .)
    LPAREN          reduce using rule 27 (constant -> STRING_LITERAL .)
    $end            reduce using rule 27 (constant -> STRING_LITERAL .)
    RPAREN          reduce using rule 27 (constant -> STRING_LITERAL .)
    SEMI            reduce using rule 27 (constant -> STRING_LITERAL .)
    RBRACE          reduce using rule 27 (constant -> STRING_LITERAL .)
    RBRACKET        reduce using rule 27 (constant -> STRING_LITERAL .)
    PLUSPLUS        reduce using rule 27 (constant -> STRING_LITERAL .)
    MINUSMINUS      reduce using rule 27 (constant -> STRING_LITERAL .)


state 32

    (68) function_declaration -> typeid . arglist SEMI
    (69) function_declaration -> typeid . arglist compound
    (70) declaration -> typeid . SEMI
    (21) assignment_expression -> typeid . assignment_operator expr
    (16) arglist -> . LPAREN arg_params RPAREN
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    SEMI            shift and go to state 77
    LPAREN          shift and go to state 79
    EQUALS          shift and go to state 64
    PLUSEQUALS      shift and go to state 65
    MINUSEQUALS     shift and go to state 67
    TIMESEQUALS     shift and go to state 68

    assignment_operator            shift and go to state 78
    arglist                        shift and go to state 80

state 33

    (43) expr -> term .
    (36) binop_expression -> term .

  ! reduce/reduce conflict for SEMI resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for MINUS resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for RBRACE resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for COMMENT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LBRACE resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for FOR resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for VOID resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for CHAR resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for SHORT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for INT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LONG resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for FLOAT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for SIGNED resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for UNSIGNED resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for ID resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LOGNOT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for INT_CONST resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for STRING_LITERAL resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LPAREN resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for $end resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 36 (binop_expression -> term .)
    SEMI            reduce using rule 36 (binop_expression -> term .)
    TIMES           reduce using rule 36 (binop_expression -> term .)
    DIVIDE          reduce using rule 36 (binop_expression -> term .)
    PLUS            reduce using rule 36 (binop_expression -> term .)
    MINUS           reduce using rule 36 (binop_expression -> term .)
    MOD             reduce using rule 36 (binop_expression -> term .)
    OR              reduce using rule 36 (binop_expression -> term .)
    AND             reduce using rule 36 (binop_expression -> term .)
    LSHIFT          reduce using rule 36 (binop_expression -> term .)
    RSHIFT          reduce using rule 36 (binop_expression -> term .)
    LOGOR           reduce using rule 36 (binop_expression -> term .)
    LOGAND          reduce using rule 36 (binop_expression -> term .)
    LT              reduce using rule 36 (binop_expression -> term .)
    GT              reduce using rule 36 (binop_expression -> term .)
    LE              reduce using rule 36 (binop_expression -> term .)
    GE              reduce using rule 36 (binop_expression -> term .)
    EQ              reduce using rule 36 (binop_expression -> term .)
    NE              reduce using rule 36 (binop_expression -> term .)
    RBRACE          reduce using rule 36 (binop_expression -> term .)
    COMMENT         reduce using rule 36 (binop_expression -> term .)
    LBRACE          reduce using rule 36 (binop_expression -> term .)
    FOR             reduce using rule 36 (binop_expression -> term .)
    VOID            reduce using rule 36 (binop_expression -> term .)
    CHAR            reduce using rule 36 (binop_expression -> term .)
    SHORT           reduce using rule 36 (binop_expression -> term .)
    INT             reduce using rule 36 (binop_expression -> term .)
    LONG            reduce using rule 36 (binop_expression -> term .)
    FLOAT           reduce using rule 36 (binop_expression -> term .)
    DOUBLE          reduce using rule 36 (binop_expression -> term .)
    SIGNED          reduce using rule 36 (binop_expression -> term .)
    UNSIGNED        reduce using rule 36 (binop_expression -> term .)
    ID              reduce using rule 36 (binop_expression -> term .)
    LOGNOT          reduce using rule 36 (binop_expression -> term .)
    INT_CONST       reduce using rule 36 (binop_expression -> term .)
    FLOAT_CONST     reduce using rule 36 (binop_expression -> term .)
    STRING_LITERAL  reduce using rule 36 (binop_expression -> term .)
    LPAREN          reduce using rule 36 (binop_expression -> term .)
    $end            reduce using rule 36 (binop_expression -> term .)
    RBRACKET        reduce using rule 36 (binop_expression -> term .)

  ! RBRACE          [ reduce using rule 43 (expr -> term .) ]
  ! COMMENT         [ reduce using rule 43 (expr -> term .) ]
  ! LBRACE          [ reduce using rule 43 (expr -> term .) ]
  ! FOR             [ reduce using rule 43 (expr -> term .) ]
  ! VOID            [ reduce using rule 43 (expr -> term .) ]
  ! CHAR            [ reduce using rule 43 (expr -> term .) ]
  ! SHORT           [ reduce using rule 43 (expr -> term .) ]
  ! INT             [ reduce using rule 43 (expr -> term .) ]
  ! LONG            [ reduce using rule 43 (expr -> term .) ]
  ! FLOAT           [ reduce using rule 43 (expr -> term .) ]
  ! DOUBLE          [ reduce using rule 43 (expr -> term .) ]
  ! SIGNED          [ reduce using rule 43 (expr -> term .) ]
  ! UNSIGNED        [ reduce using rule 43 (expr -> term .) ]
  ! ID              [ reduce using rule 43 (expr -> term .) ]
  ! MINUS           [ reduce using rule 43 (expr -> term .) ]
  ! LOGNOT          [ reduce using rule 43 (expr -> term .) ]
  ! INT_CONST       [ reduce using rule 43 (expr -> term .) ]
  ! FLOAT_CONST     [ reduce using rule 43 (expr -> term .) ]
  ! STRING_LITERAL  [ reduce using rule 43 (expr -> term .) ]
  ! LPAREN          [ reduce using rule 43 (expr -> term .) ]
  ! SEMI            [ reduce using rule 43 (expr -> term .) ]
  ! RBRACKET        [ reduce using rule 43 (expr -> term .) ]
  ! $end            [ reduce using rule 43 (expr -> term .) ]


state 34

    (8) beginning_list -> beginning_list assignment_expression_semi .

    COMMENT         reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LBRACE          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    FOR             reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    VOID            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    CHAR            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    SHORT           reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    INT             reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LONG            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    FLOAT           reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    DOUBLE          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    SIGNED          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    UNSIGNED        reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    ID              reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    MINUS           reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LOGNOT          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    INT_CONST       reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    FLOAT_CONST     reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    STRING_LITERAL  reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LPAREN          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    $end            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    RBRACE          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)


state 35

    (4) beginning_list -> beginning_list function_declaration .

    COMMENT         reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LBRACE          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    FOR             reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    VOID            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    CHAR            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    SHORT           reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    INT             reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LONG            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    FLOAT           reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    DOUBLE          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    SIGNED          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    UNSIGNED        reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    ID              reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    MINUS           reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LOGNOT          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    INT_CONST       reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    FLOAT_CONST     reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    STRING_LITERAL  reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LPAREN          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    $end            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    RBRACE          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)


state 36

    (75) native_type -> INT .

    TIMES           reduce using rule 75 (native_type -> INT .)
    ID              reduce using rule 75 (native_type -> INT .)
    RBRACE          reduce using rule 75 (native_type -> INT .)
    COMMENT         reduce using rule 75 (native_type -> INT .)
    LBRACE          reduce using rule 75 (native_type -> INT .)
    FOR             reduce using rule 75 (native_type -> INT .)
    VOID            reduce using rule 75 (native_type -> INT .)
    CHAR            reduce using rule 75 (native_type -> INT .)
    SHORT           reduce using rule 75 (native_type -> INT .)
    INT             reduce using rule 75 (native_type -> INT .)
    LONG            reduce using rule 75 (native_type -> INT .)
    FLOAT           reduce using rule 75 (native_type -> INT .)
    DOUBLE          reduce using rule 75 (native_type -> INT .)
    SIGNED          reduce using rule 75 (native_type -> INT .)
    UNSIGNED        reduce using rule 75 (native_type -> INT .)
    MINUS           reduce using rule 75 (native_type -> INT .)
    LOGNOT          reduce using rule 75 (native_type -> INT .)
    INT_CONST       reduce using rule 75 (native_type -> INT .)
    FLOAT_CONST     reduce using rule 75 (native_type -> INT .)
    STRING_LITERAL  reduce using rule 75 (native_type -> INT .)
    LPAREN          reduce using rule 75 (native_type -> INT .)
    $end            reduce using rule 75 (native_type -> INT .)


state 37

    (9) beginning_list -> beginning_list expr .

    COMMENT         reduce using rule 9 (beginning_list -> beginning_list expr .)
    LBRACE          reduce using rule 9 (beginning_list -> beginning_list expr .)
    FOR             reduce using rule 9 (beginning_list -> beginning_list expr .)
    VOID            reduce using rule 9 (beginning_list -> beginning_list expr .)
    CHAR            reduce using rule 9 (beginning_list -> beginning_list expr .)
    SHORT           reduce using rule 9 (beginning_list -> beginning_list expr .)
    INT             reduce using rule 9 (beginning_list -> beginning_list expr .)
    LONG            reduce using rule 9 (beginning_list -> beginning_list expr .)
    FLOAT           reduce using rule 9 (beginning_list -> beginning_list expr .)
    DOUBLE          reduce using rule 9 (beginning_list -> beginning_list expr .)
    SIGNED          reduce using rule 9 (beginning_list -> beginning_list expr .)
    UNSIGNED        reduce using rule 9 (beginning_list -> beginning_list expr .)
    ID              reduce using rule 9 (beginning_list -> beginning_list expr .)
    MINUS           reduce using rule 9 (beginning_list -> beginning_list expr .)
    LOGNOT          reduce using rule 9 (beginning_list -> beginning_list expr .)
    INT_CONST       reduce using rule 9 (beginning_list -> beginning_list expr .)
    FLOAT_CONST     reduce using rule 9 (beginning_list -> beginning_list expr .)
    STRING_LITERAL  reduce using rule 9 (beginning_list -> beginning_list expr .)
    LPAREN          reduce using rule 9 (beginning_list -> beginning_list expr .)
    $end            reduce using rule 9 (beginning_list -> beginning_list expr .)
    RBRACE          reduce using rule 9 (beginning_list -> beginning_list expr .)


state 38

    (77) native_type -> FLOAT .

    TIMES           reduce using rule 77 (native_type -> FLOAT .)
    ID              reduce using rule 77 (native_type -> FLOAT .)
    RBRACE          reduce using rule 77 (native_type -> FLOAT .)
    COMMENT         reduce using rule 77 (native_type -> FLOAT .)
    LBRACE          reduce using rule 77 (native_type -> FLOAT .)
    FOR             reduce using rule 77 (native_type -> FLOAT .)
    VOID            reduce using rule 77 (native_type -> FLOAT .)
    CHAR            reduce using rule 77 (native_type -> FLOAT .)
    SHORT           reduce using rule 77 (native_type -> FLOAT .)
    INT             reduce using rule 77 (native_type -> FLOAT .)
    LONG            reduce using rule 77 (native_type -> FLOAT .)
    FLOAT           reduce using rule 77 (native_type -> FLOAT .)
    DOUBLE          reduce using rule 77 (native_type -> FLOAT .)
    SIGNED          reduce using rule 77 (native_type -> FLOAT .)
    UNSIGNED        reduce using rule 77 (native_type -> FLOAT .)
    MINUS           reduce using rule 77 (native_type -> FLOAT .)
    LOGNOT          reduce using rule 77 (native_type -> FLOAT .)
    INT_CONST       reduce using rule 77 (native_type -> FLOAT .)
    FLOAT_CONST     reduce using rule 77 (native_type -> FLOAT .)
    STRING_LITERAL  reduce using rule 77 (native_type -> FLOAT .)
    LPAREN          reduce using rule 77 (native_type -> FLOAT .)
    $end            reduce using rule 77 (native_type -> FLOAT .)


state 39

    (79) native_type -> SIGNED .

    TIMES           reduce using rule 79 (native_type -> SIGNED .)
    ID              reduce using rule 79 (native_type -> SIGNED .)
    RBRACE          reduce using rule 79 (native_type -> SIGNED .)
    COMMENT         reduce using rule 79 (native_type -> SIGNED .)
    LBRACE          reduce using rule 79 (native_type -> SIGNED .)
    FOR             reduce using rule 79 (native_type -> SIGNED .)
    VOID            reduce using rule 79 (native_type -> SIGNED .)
    CHAR            reduce using rule 79 (native_type -> SIGNED .)
    SHORT           reduce using rule 79 (native_type -> SIGNED .)
    INT             reduce using rule 79 (native_type -> SIGNED .)
    LONG            reduce using rule 79 (native_type -> SIGNED .)
    FLOAT           reduce using rule 79 (native_type -> SIGNED .)
    DOUBLE          reduce using rule 79 (native_type -> SIGNED .)
    SIGNED          reduce using rule 79 (native_type -> SIGNED .)
    UNSIGNED        reduce using rule 79 (native_type -> SIGNED .)
    MINUS           reduce using rule 79 (native_type -> SIGNED .)
    LOGNOT          reduce using rule 79 (native_type -> SIGNED .)
    INT_CONST       reduce using rule 79 (native_type -> SIGNED .)
    FLOAT_CONST     reduce using rule 79 (native_type -> SIGNED .)
    STRING_LITERAL  reduce using rule 79 (native_type -> SIGNED .)
    LPAREN          reduce using rule 79 (native_type -> SIGNED .)
    $end            reduce using rule 79 (native_type -> SIGNED .)


state 40

    (78) native_type -> DOUBLE .

    TIMES           reduce using rule 78 (native_type -> DOUBLE .)
    ID              reduce using rule 78 (native_type -> DOUBLE .)
    RBRACE          reduce using rule 78 (native_type -> DOUBLE .)
    COMMENT         reduce using rule 78 (native_type -> DOUBLE .)
    LBRACE          reduce using rule 78 (native_type -> DOUBLE .)
    FOR             reduce using rule 78 (native_type -> DOUBLE .)
    VOID            reduce using rule 78 (native_type -> DOUBLE .)
    CHAR            reduce using rule 78 (native_type -> DOUBLE .)
    SHORT           reduce using rule 78 (native_type -> DOUBLE .)
    INT             reduce using rule 78 (native_type -> DOUBLE .)
    LONG            reduce using rule 78 (native_type -> DOUBLE .)
    FLOAT           reduce using rule 78 (native_type -> DOUBLE .)
    DOUBLE          reduce using rule 78 (native_type -> DOUBLE .)
    SIGNED          reduce using rule 78 (native_type -> DOUBLE .)
    UNSIGNED        reduce using rule 78 (native_type -> DOUBLE .)
    MINUS           reduce using rule 78 (native_type -> DOUBLE .)
    LOGNOT          reduce using rule 78 (native_type -> DOUBLE .)
    INT_CONST       reduce using rule 78 (native_type -> DOUBLE .)
    FLOAT_CONST     reduce using rule 78 (native_type -> DOUBLE .)
    STRING_LITERAL  reduce using rule 78 (native_type -> DOUBLE .)
    LPAREN          reduce using rule 78 (native_type -> DOUBLE .)
    $end            reduce using rule 78 (native_type -> DOUBLE .)


state 41

    (22) assignment_expression -> identifier . assignment_operator expr
    (64) term -> identifier .
    (62) array_reference -> identifier . subscript_list
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    COMMENT         reduce using rule 64 (term -> identifier .)
    LBRACE          reduce using rule 64 (term -> identifier .)
    FOR             reduce using rule 64 (term -> identifier .)
    VOID            reduce using rule 64 (term -> identifier .)
    CHAR            reduce using rule 64 (term -> identifier .)
    SHORT           reduce using rule 64 (term -> identifier .)
    INT             reduce using rule 64 (term -> identifier .)
    LONG            reduce using rule 64 (term -> identifier .)
    FLOAT           reduce using rule 64 (term -> identifier .)
    DOUBLE          reduce using rule 64 (term -> identifier .)
    SIGNED          reduce using rule 64 (term -> identifier .)
    UNSIGNED        reduce using rule 64 (term -> identifier .)
    ID              reduce using rule 64 (term -> identifier .)
    MINUS           reduce using rule 64 (term -> identifier .)
    LOGNOT          reduce using rule 64 (term -> identifier .)
    INT_CONST       reduce using rule 64 (term -> identifier .)
    FLOAT_CONST     reduce using rule 64 (term -> identifier .)
    STRING_LITERAL  reduce using rule 64 (term -> identifier .)
    LPAREN          reduce using rule 64 (term -> identifier .)
    $end            reduce using rule 64 (term -> identifier .)
    TIMES           reduce using rule 64 (term -> identifier .)
    DIVIDE          reduce using rule 64 (term -> identifier .)
    PLUS            reduce using rule 64 (term -> identifier .)
    MOD             reduce using rule 64 (term -> identifier .)
    OR              reduce using rule 64 (term -> identifier .)
    AND             reduce using rule 64 (term -> identifier .)
    LSHIFT          reduce using rule 64 (term -> identifier .)
    RSHIFT          reduce using rule 64 (term -> identifier .)
    LOGOR           reduce using rule 64 (term -> identifier .)
    LOGAND          reduce using rule 64 (term -> identifier .)
    LT              reduce using rule 64 (term -> identifier .)
    GT              reduce using rule 64 (term -> identifier .)
    LE              reduce using rule 64 (term -> identifier .)
    GE              reduce using rule 64 (term -> identifier .)
    EQ              reduce using rule 64 (term -> identifier .)
    NE              reduce using rule 64 (term -> identifier .)
    RBRACE          reduce using rule 64 (term -> identifier .)
    EQUALS          shift and go to state 64
    PLUSEQUALS      shift and go to state 65
    MINUSEQUALS     shift and go to state 67
    TIMESEQUALS     shift and go to state 68
    LBRACKET        shift and go to state 82

    subscript                      shift and go to state 84
    subscript_list                 shift and go to state 81
    assignment_operator            shift and go to state 83

state 42

    (26) constant -> FLOAT_CONST .

    TIMES           reduce using rule 26 (constant -> FLOAT_CONST .)
    DIVIDE          reduce using rule 26 (constant -> FLOAT_CONST .)
    PLUS            reduce using rule 26 (constant -> FLOAT_CONST .)
    MINUS           reduce using rule 26 (constant -> FLOAT_CONST .)
    MOD             reduce using rule 26 (constant -> FLOAT_CONST .)
    OR              reduce using rule 26 (constant -> FLOAT_CONST .)
    AND             reduce using rule 26 (constant -> FLOAT_CONST .)
    LSHIFT          reduce using rule 26 (constant -> FLOAT_CONST .)
    RSHIFT          reduce using rule 26 (constant -> FLOAT_CONST .)
    LOGOR           reduce using rule 26 (constant -> FLOAT_CONST .)
    LOGAND          reduce using rule 26 (constant -> FLOAT_CONST .)
    LT              reduce using rule 26 (constant -> FLOAT_CONST .)
    GT              reduce using rule 26 (constant -> FLOAT_CONST .)
    LE              reduce using rule 26 (constant -> FLOAT_CONST .)
    GE              reduce using rule 26 (constant -> FLOAT_CONST .)
    EQ              reduce using rule 26 (constant -> FLOAT_CONST .)
    NE              reduce using rule 26 (constant -> FLOAT_CONST .)
    COMMENT         reduce using rule 26 (constant -> FLOAT_CONST .)
    LBRACE          reduce using rule 26 (constant -> FLOAT_CONST .)
    FOR             reduce using rule 26 (constant -> FLOAT_CONST .)
    VOID            reduce using rule 26 (constant -> FLOAT_CONST .)
    CHAR            reduce using rule 26 (constant -> FLOAT_CONST .)
    SHORT           reduce using rule 26 (constant -> FLOAT_CONST .)
    INT             reduce using rule 26 (constant -> FLOAT_CONST .)
    LONG            reduce using rule 26 (constant -> FLOAT_CONST .)
    FLOAT           reduce using rule 26 (constant -> FLOAT_CONST .)
    DOUBLE          reduce using rule 26 (constant -> FLOAT_CONST .)
    SIGNED          reduce using rule 26 (constant -> FLOAT_CONST .)
    UNSIGNED        reduce using rule 26 (constant -> FLOAT_CONST .)
    ID              reduce using rule 26 (constant -> FLOAT_CONST .)
    LOGNOT          reduce using rule 26 (constant -> FLOAT_CONST .)
    INT_CONST       reduce using rule 26 (constant -> FLOAT_CONST .)
    FLOAT_CONST     reduce using rule 26 (constant -> FLOAT_CONST .)
    STRING_LITERAL  reduce using rule 26 (constant -> FLOAT_CONST .)
    LPAREN          reduce using rule 26 (constant -> FLOAT_CONST .)
    $end            reduce using rule 26 (constant -> FLOAT_CONST .)
    RPAREN          reduce using rule 26 (constant -> FLOAT_CONST .)
    SEMI            reduce using rule 26 (constant -> FLOAT_CONST .)
    RBRACE          reduce using rule 26 (constant -> FLOAT_CONST .)
    RBRACKET        reduce using rule 26 (constant -> FLOAT_CONST .)
    PLUSPLUS        reduce using rule 26 (constant -> FLOAT_CONST .)
    MINUSMINUS      reduce using rule 26 (constant -> FLOAT_CONST .)


state 43

    (32) unary_expression -> unary_token_before term .

    SEMI            reduce using rule 32 (unary_expression -> unary_token_before term .)
    RBRACKET        reduce using rule 32 (unary_expression -> unary_token_before term .)
    RBRACE          reduce using rule 32 (unary_expression -> unary_token_before term .)
    COMMENT         reduce using rule 32 (unary_expression -> unary_token_before term .)
    LBRACE          reduce using rule 32 (unary_expression -> unary_token_before term .)
    FOR             reduce using rule 32 (unary_expression -> unary_token_before term .)
    VOID            reduce using rule 32 (unary_expression -> unary_token_before term .)
    CHAR            reduce using rule 32 (unary_expression -> unary_token_before term .)
    SHORT           reduce using rule 32 (unary_expression -> unary_token_before term .)
    INT             reduce using rule 32 (unary_expression -> unary_token_before term .)
    LONG            reduce using rule 32 (unary_expression -> unary_token_before term .)
    FLOAT           reduce using rule 32 (unary_expression -> unary_token_before term .)
    DOUBLE          reduce using rule 32 (unary_expression -> unary_token_before term .)
    SIGNED          reduce using rule 32 (unary_expression -> unary_token_before term .)
    UNSIGNED        reduce using rule 32 (unary_expression -> unary_token_before term .)
    ID              reduce using rule 32 (unary_expression -> unary_token_before term .)
    MINUS           reduce using rule 32 (unary_expression -> unary_token_before term .)
    LOGNOT          reduce using rule 32 (unary_expression -> unary_token_before term .)
    INT_CONST       reduce using rule 32 (unary_expression -> unary_token_before term .)
    FLOAT_CONST     reduce using rule 32 (unary_expression -> unary_token_before term .)
    STRING_LITERAL  reduce using rule 32 (unary_expression -> unary_token_before term .)
    LPAREN          reduce using rule 32 (unary_expression -> unary_token_before term .)
    $end            reduce using rule 32 (unary_expression -> unary_token_before term .)


state 44

    (66) term -> array_reference .

    SEMI            reduce using rule 66 (term -> array_reference .)
    TIMES           reduce using rule 66 (term -> array_reference .)
    DIVIDE          reduce using rule 66 (term -> array_reference .)
    PLUS            reduce using rule 66 (term -> array_reference .)
    MINUS           reduce using rule 66 (term -> array_reference .)
    MOD             reduce using rule 66 (term -> array_reference .)
    OR              reduce using rule 66 (term -> array_reference .)
    AND             reduce using rule 66 (term -> array_reference .)
    LSHIFT          reduce using rule 66 (term -> array_reference .)
    RSHIFT          reduce using rule 66 (term -> array_reference .)
    LOGOR           reduce using rule 66 (term -> array_reference .)
    LOGAND          reduce using rule 66 (term -> array_reference .)
    LT              reduce using rule 66 (term -> array_reference .)
    GT              reduce using rule 66 (term -> array_reference .)
    LE              reduce using rule 66 (term -> array_reference .)
    GE              reduce using rule 66 (term -> array_reference .)
    EQ              reduce using rule 66 (term -> array_reference .)
    NE              reduce using rule 66 (term -> array_reference .)
    COMMENT         reduce using rule 66 (term -> array_reference .)
    LBRACE          reduce using rule 66 (term -> array_reference .)
    FOR             reduce using rule 66 (term -> array_reference .)
    VOID            reduce using rule 66 (term -> array_reference .)
    CHAR            reduce using rule 66 (term -> array_reference .)
    SHORT           reduce using rule 66 (term -> array_reference .)
    INT             reduce using rule 66 (term -> array_reference .)
    LONG            reduce using rule 66 (term -> array_reference .)
    FLOAT           reduce using rule 66 (term -> array_reference .)
    DOUBLE          reduce using rule 66 (term -> array_reference .)
    SIGNED          reduce using rule 66 (term -> array_reference .)
    UNSIGNED        reduce using rule 66 (term -> array_reference .)
    ID              reduce using rule 66 (term -> array_reference .)
    LOGNOT          reduce using rule 66 (term -> array_reference .)
    INT_CONST       reduce using rule 66 (term -> array_reference .)
    FLOAT_CONST     reduce using rule 66 (term -> array_reference .)
    STRING_LITERAL  reduce using rule 66 (term -> array_reference .)
    LPAREN          reduce using rule 66 (term -> array_reference .)
    $end            reduce using rule 66 (term -> array_reference .)
    RPAREN          reduce using rule 66 (term -> array_reference .)
    RBRACE          reduce using rule 66 (term -> array_reference .)
    RBRACKET        reduce using rule 66 (term -> array_reference .)
    PLUSPLUS        reduce using rule 66 (term -> array_reference .)
    MINUSMINUS      reduce using rule 66 (term -> array_reference .)


state 45

    (64) term -> identifier .
    (62) array_reference -> identifier . subscript_list
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    SEMI            reduce using rule 64 (term -> identifier .)
    TIMES           reduce using rule 64 (term -> identifier .)
    DIVIDE          reduce using rule 64 (term -> identifier .)
    PLUS            reduce using rule 64 (term -> identifier .)
    MINUS           reduce using rule 64 (term -> identifier .)
    MOD             reduce using rule 64 (term -> identifier .)
    OR              reduce using rule 64 (term -> identifier .)
    AND             reduce using rule 64 (term -> identifier .)
    LSHIFT          reduce using rule 64 (term -> identifier .)
    RSHIFT          reduce using rule 64 (term -> identifier .)
    LOGOR           reduce using rule 64 (term -> identifier .)
    LOGAND          reduce using rule 64 (term -> identifier .)
    LT              reduce using rule 64 (term -> identifier .)
    GT              reduce using rule 64 (term -> identifier .)
    LE              reduce using rule 64 (term -> identifier .)
    GE              reduce using rule 64 (term -> identifier .)
    EQ              reduce using rule 64 (term -> identifier .)
    NE              reduce using rule 64 (term -> identifier .)
    COMMENT         reduce using rule 64 (term -> identifier .)
    LBRACE          reduce using rule 64 (term -> identifier .)
    FOR             reduce using rule 64 (term -> identifier .)
    VOID            reduce using rule 64 (term -> identifier .)
    CHAR            reduce using rule 64 (term -> identifier .)
    SHORT           reduce using rule 64 (term -> identifier .)
    INT             reduce using rule 64 (term -> identifier .)
    LONG            reduce using rule 64 (term -> identifier .)
    FLOAT           reduce using rule 64 (term -> identifier .)
    DOUBLE          reduce using rule 64 (term -> identifier .)
    SIGNED          reduce using rule 64 (term -> identifier .)
    UNSIGNED        reduce using rule 64 (term -> identifier .)
    ID              reduce using rule 64 (term -> identifier .)
    LOGNOT          reduce using rule 64 (term -> identifier .)
    INT_CONST       reduce using rule 64 (term -> identifier .)
    FLOAT_CONST     reduce using rule 64 (term -> identifier .)
    STRING_LITERAL  reduce using rule 64 (term -> identifier .)
    LPAREN          reduce using rule 64 (term -> identifier .)
    $end            reduce using rule 64 (term -> identifier .)
    RPAREN          reduce using rule 64 (term -> identifier .)
    RBRACE          reduce using rule 64 (term -> identifier .)
    RBRACKET        reduce using rule 64 (term -> identifier .)
    PLUSPLUS        reduce using rule 64 (term -> identifier .)
    MINUSMINUS      reduce using rule 64 (term -> identifier .)
    LBRACKET        shift and go to state 82

    subscript                      shift and go to state 84
    subscript_list                 shift and go to state 81

state 46

    (48) binary_token -> AND .

    LPAREN          reduce using rule 48 (binary_token -> AND .)
    ID              reduce using rule 48 (binary_token -> AND .)
    INT_CONST       reduce using rule 48 (binary_token -> AND .)
    FLOAT_CONST     reduce using rule 48 (binary_token -> AND .)
    STRING_LITERAL  reduce using rule 48 (binary_token -> AND .)


state 47

    (47) binary_token -> OR .

    LPAREN          reduce using rule 47 (binary_token -> OR .)
    ID              reduce using rule 47 (binary_token -> OR .)
    INT_CONST       reduce using rule 47 (binary_token -> OR .)
    FLOAT_CONST     reduce using rule 47 (binary_token -> OR .)
    STRING_LITERAL  reduce using rule 47 (binary_token -> OR .)


state 48

    (54) binary_token -> GT .

    LPAREN          reduce using rule 54 (binary_token -> GT .)
    ID              reduce using rule 54 (binary_token -> GT .)
    INT_CONST       reduce using rule 54 (binary_token -> GT .)
    FLOAT_CONST     reduce using rule 54 (binary_token -> GT .)
    STRING_LITERAL  reduce using rule 54 (binary_token -> GT .)


state 49

    (50) binary_token -> RSHIFT .

    LPAREN          reduce using rule 50 (binary_token -> RSHIFT .)
    ID              reduce using rule 50 (binary_token -> RSHIFT .)
    INT_CONST       reduce using rule 50 (binary_token -> RSHIFT .)
    FLOAT_CONST     reduce using rule 50 (binary_token -> RSHIFT .)
    STRING_LITERAL  reduce using rule 50 (binary_token -> RSHIFT .)


state 50

    (38) binop_expression -> binop_paren DIVIDE . binop_paren
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 75
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 85
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 86
    identifier                     shift and go to state 45

state 51

    (51) binary_token -> LOGOR .

    LPAREN          reduce using rule 51 (binary_token -> LOGOR .)
    ID              reduce using rule 51 (binary_token -> LOGOR .)
    INT_CONST       reduce using rule 51 (binary_token -> LOGOR .)
    FLOAT_CONST     reduce using rule 51 (binary_token -> LOGOR .)
    STRING_LITERAL  reduce using rule 51 (binary_token -> LOGOR .)


state 52

    (52) binary_token -> LOGAND .

    LPAREN          reduce using rule 52 (binary_token -> LOGAND .)
    ID              reduce using rule 52 (binary_token -> LOGAND .)
    INT_CONST       reduce using rule 52 (binary_token -> LOGAND .)
    FLOAT_CONST     reduce using rule 52 (binary_token -> LOGAND .)
    STRING_LITERAL  reduce using rule 52 (binary_token -> LOGAND .)


state 53

    (56) binary_token -> GE .

    LPAREN          reduce using rule 56 (binary_token -> GE .)
    ID              reduce using rule 56 (binary_token -> GE .)
    INT_CONST       reduce using rule 56 (binary_token -> GE .)
    FLOAT_CONST     reduce using rule 56 (binary_token -> GE .)
    STRING_LITERAL  reduce using rule 56 (binary_token -> GE .)


state 54

    (37) binop_expression -> binop_paren TIMES . binop_paren
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 75
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 87
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 86
    identifier                     shift and go to state 45

state 55

    (53) binary_token -> LT .

    LPAREN          reduce using rule 53 (binary_token -> LT .)
    ID              reduce using rule 53 (binary_token -> LT .)
    INT_CONST       reduce using rule 53 (binary_token -> LT .)
    FLOAT_CONST     reduce using rule 53 (binary_token -> LT .)
    STRING_LITERAL  reduce using rule 53 (binary_token -> LT .)


state 56

    (55) binary_token -> LE .

    LPAREN          reduce using rule 55 (binary_token -> LE .)
    ID              reduce using rule 55 (binary_token -> LE .)
    INT_CONST       reduce using rule 55 (binary_token -> LE .)
    FLOAT_CONST     reduce using rule 55 (binary_token -> LE .)
    STRING_LITERAL  reduce using rule 55 (binary_token -> LE .)


state 57

    (44) binary_token -> PLUS .

    LPAREN          reduce using rule 44 (binary_token -> PLUS .)
    ID              reduce using rule 44 (binary_token -> PLUS .)
    INT_CONST       reduce using rule 44 (binary_token -> PLUS .)
    FLOAT_CONST     reduce using rule 44 (binary_token -> PLUS .)
    STRING_LITERAL  reduce using rule 44 (binary_token -> PLUS .)


state 58

    (49) binary_token -> LSHIFT .

    LPAREN          reduce using rule 49 (binary_token -> LSHIFT .)
    ID              reduce using rule 49 (binary_token -> LSHIFT .)
    INT_CONST       reduce using rule 49 (binary_token -> LSHIFT .)
    FLOAT_CONST     reduce using rule 49 (binary_token -> LSHIFT .)
    STRING_LITERAL  reduce using rule 49 (binary_token -> LSHIFT .)


state 59

    (46) binary_token -> MOD .

    LPAREN          reduce using rule 46 (binary_token -> MOD .)
    ID              reduce using rule 46 (binary_token -> MOD .)
    INT_CONST       reduce using rule 46 (binary_token -> MOD .)
    FLOAT_CONST     reduce using rule 46 (binary_token -> MOD .)
    STRING_LITERAL  reduce using rule 46 (binary_token -> MOD .)


state 60

    (57) binary_token -> EQ .

    LPAREN          reduce using rule 57 (binary_token -> EQ .)
    ID              reduce using rule 57 (binary_token -> EQ .)
    INT_CONST       reduce using rule 57 (binary_token -> EQ .)
    FLOAT_CONST     reduce using rule 57 (binary_token -> EQ .)
    STRING_LITERAL  reduce using rule 57 (binary_token -> EQ .)


state 61

    (45) binary_token -> MINUS .

    LPAREN          reduce using rule 45 (binary_token -> MINUS .)
    ID              reduce using rule 45 (binary_token -> MINUS .)
    INT_CONST       reduce using rule 45 (binary_token -> MINUS .)
    FLOAT_CONST     reduce using rule 45 (binary_token -> MINUS .)
    STRING_LITERAL  reduce using rule 45 (binary_token -> MINUS .)


state 62

    (58) binary_token -> NE .

    LPAREN          reduce using rule 58 (binary_token -> NE .)
    ID              reduce using rule 58 (binary_token -> NE .)
    INT_CONST       reduce using rule 58 (binary_token -> NE .)
    FLOAT_CONST     reduce using rule 58 (binary_token -> NE .)
    STRING_LITERAL  reduce using rule 58 (binary_token -> NE .)


state 63

    (39) binop_expression -> binop_paren binary_token . binop_paren
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 75
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 88
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 86
    identifier                     shift and go to state 45

state 64

    (17) assignment_operator -> EQUALS .

    MINUS           reduce using rule 17 (assignment_operator -> EQUALS .)
    LOGNOT          reduce using rule 17 (assignment_operator -> EQUALS .)
    ID              reduce using rule 17 (assignment_operator -> EQUALS .)
    INT_CONST       reduce using rule 17 (assignment_operator -> EQUALS .)
    FLOAT_CONST     reduce using rule 17 (assignment_operator -> EQUALS .)
    STRING_LITERAL  reduce using rule 17 (assignment_operator -> EQUALS .)
    LPAREN          reduce using rule 17 (assignment_operator -> EQUALS .)


state 65

    (18) assignment_operator -> PLUSEQUALS .

    MINUS           reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    LOGNOT          reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    ID              reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    INT_CONST       reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    FLOAT_CONST     reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    STRING_LITERAL  reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    LPAREN          reduce using rule 18 (assignment_operator -> PLUSEQUALS .)


state 66

    (23) assignment_expression -> array_reference assignment_operator . expr
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 17
    LOGNOT          shift and go to state 14
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 28

    unary_token_before             shift and go to state 5
    term                           shift and go to state 33
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 26
    expr                           shift and go to state 89
    binop_paren                    shift and go to state 11
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 45

state 67

    (19) assignment_operator -> MINUSEQUALS .

    MINUS           reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    LOGNOT          reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    ID              reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    INT_CONST       reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    FLOAT_CONST     reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    STRING_LITERAL  reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    LPAREN          reduce using rule 19 (assignment_operator -> MINUSEQUALS .)


state 68

    (20) assignment_operator -> TIMESEQUALS .

    MINUS           reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    LOGNOT          reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    ID              reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    INT_CONST       reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    FLOAT_CONST     reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    STRING_LITERAL  reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    LPAREN          reduce using rule 20 (assignment_operator -> TIMESEQUALS .)


state 69

    (82) type -> native_type TIMES .

    ID              reduce using rule 82 (type -> native_type TIMES .)
    RBRACE          reduce using rule 82 (type -> native_type TIMES .)
    COMMENT         reduce using rule 82 (type -> native_type TIMES .)
    LBRACE          reduce using rule 82 (type -> native_type TIMES .)
    FOR             reduce using rule 82 (type -> native_type TIMES .)
    VOID            reduce using rule 82 (type -> native_type TIMES .)
    CHAR            reduce using rule 82 (type -> native_type TIMES .)
    SHORT           reduce using rule 82 (type -> native_type TIMES .)
    INT             reduce using rule 82 (type -> native_type TIMES .)
    LONG            reduce using rule 82 (type -> native_type TIMES .)
    FLOAT           reduce using rule 82 (type -> native_type TIMES .)
    DOUBLE          reduce using rule 82 (type -> native_type TIMES .)
    SIGNED          reduce using rule 82 (type -> native_type TIMES .)
    UNSIGNED        reduce using rule 82 (type -> native_type TIMES .)
    MINUS           reduce using rule 82 (type -> native_type TIMES .)
    LOGNOT          reduce using rule 82 (type -> native_type TIMES .)
    INT_CONST       reduce using rule 82 (type -> native_type TIMES .)
    FLOAT_CONST     reduce using rule 82 (type -> native_type TIMES .)
    STRING_LITERAL  reduce using rule 82 (type -> native_type TIMES .)
    LPAREN          reduce using rule 82 (type -> native_type TIMES .)
    $end            reduce using rule 82 (type -> native_type TIMES .)


state 70

    (63) for_loop -> FOR LPAREN . assignment_expression SEMI binop SEMI increment RPAREN compound
    (21) assignment_expression -> . typeid assignment_operator expr
    (22) assignment_expression -> . identifier assignment_operator expr
    (23) assignment_expression -> . array_reference assignment_operator expr
    (71) typeid -> . type identifier
    (83) identifier -> . ID
    (62) array_reference -> . identifier subscript_list
    (81) type -> . native_type
    (82) type -> . native_type TIMES
    (72) native_type -> . VOID
    (73) native_type -> . CHAR
    (74) native_type -> . SHORT
    (75) native_type -> . INT
    (76) native_type -> . LONG
    (77) native_type -> . FLOAT
    (78) native_type -> . DOUBLE
    (79) native_type -> . SIGNED
    (80) native_type -> . UNSIGNED

    ID              shift and go to state 30
    VOID            shift and go to state 9
    CHAR            shift and go to state 13
    SHORT           shift and go to state 6
    INT             shift and go to state 36
    LONG            shift and go to state 22
    FLOAT           shift and go to state 38
    DOUBLE          shift and go to state 40
    SIGNED          shift and go to state 39
    UNSIGNED        shift and go to state 21

    typeid                         shift and go to state 93
    assignment_expression          shift and go to state 92
    native_type                    shift and go to state 16
    array_reference                shift and go to state 90
    identifier                     shift and go to state 94
    type                           shift and go to state 91

state 71

    (71) typeid -> type identifier .

    SEMI            reduce using rule 71 (typeid -> type identifier .)
    LPAREN          reduce using rule 71 (typeid -> type identifier .)
    EQUALS          reduce using rule 71 (typeid -> type identifier .)
    PLUSEQUALS      reduce using rule 71 (typeid -> type identifier .)
    MINUSEQUALS     reduce using rule 71 (typeid -> type identifier .)
    TIMESEQUALS     reduce using rule 71 (typeid -> type identifier .)
    COMMA           reduce using rule 71 (typeid -> type identifier .)
    RPAREN          reduce using rule 71 (typeid -> type identifier .)


state 72

    (24) assignment_expression_semi -> assignment_expression SEMI .

    COMMENT         reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LBRACE          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    FOR             reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    VOID            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    CHAR            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    SHORT           reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    INT             reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LONG            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    FLOAT           reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    DOUBLE          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    SIGNED          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    UNSIGNED        reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    ID              reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    MINUS           reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LOGNOT          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    INT_CONST       reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    FLOAT_CONST     reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    STRING_LITERAL  reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LPAREN          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    $end            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    RBRACE          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)


state 73

    (67) compound -> LBRACE beginning_list . RBRACE
    (3) beginning_list -> beginning_list . comment
    (4) beginning_list -> beginning_list . function_declaration
    (5) beginning_list -> beginning_list . type
    (6) beginning_list -> beginning_list . declaration
    (7) beginning_list -> beginning_list . compound
    (8) beginning_list -> beginning_list . assignment_expression_semi
    (9) beginning_list -> beginning_list . expr
    (10) beginning_list -> beginning_list . for_loop
    (12) comment -> . COMMENT
    (68) function_declaration -> . typeid arglist SEMI
    (69) function_declaration -> . typeid arglist compound
    (81) type -> . native_type
    (82) type -> . native_type TIMES
    (70) declaration -> . typeid SEMI
    (67) compound -> . LBRACE beginning_list RBRACE
    (24) assignment_expression_semi -> . assignment_expression SEMI
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (63) for_loop -> . FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
    (71) typeid -> . type identifier
    (72) native_type -> . VOID
    (73) native_type -> . CHAR
    (74) native_type -> . SHORT
    (75) native_type -> . INT
    (76) native_type -> . LONG
    (77) native_type -> . FLOAT
    (78) native_type -> . DOUBLE
    (79) native_type -> . SIGNED
    (80) native_type -> . UNSIGNED
    (21) assignment_expression -> . typeid assignment_operator expr
    (22) assignment_expression -> . identifier assignment_operator expr
    (23) assignment_expression -> . array_reference assignment_operator expr
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (62) array_reference -> . identifier subscript_list
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    RBRACE          shift and go to state 95
    COMMENT         shift and go to state 18
    LBRACE          shift and go to state 27
    FOR             shift and go to state 20
    VOID            shift and go to state 9
    CHAR            shift and go to state 13
    SHORT           shift and go to state 6
    INT             shift and go to state 36
    LONG            shift and go to state 22
    FLOAT           shift and go to state 38
    DOUBLE          shift and go to state 40
    SIGNED          shift and go to state 39
    UNSIGNED        shift and go to state 21
    ID              shift and go to state 30
    MINUS           shift and go to state 17
    LOGNOT          shift and go to state 14
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 28

    comment                        shift and go to state 4
    unary_token_before             shift and go to state 5
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    compound                       shift and go to state 10
    binop_paren                    shift and go to state 11
    binop_expression               shift and go to state 12
    native_type                    shift and go to state 16
    array_reference                shift and go to state 15
    type                           shift and go to state 23
    for_loop                       shift and go to state 24
    assignment_expression          shift and go to state 25
    binop                          shift and go to state 26
    declaration                    shift and go to state 29
    typeid                         shift and go to state 32
    term                           shift and go to state 33
    assignment_expression_semi     shift and go to state 34
    function_declaration           shift and go to state 35
    expr                           shift and go to state 37
    identifier                     shift and go to state 41

state 74

    (11) beginning_list -> empty .

    RBRACE          reduce using rule 11 (beginning_list -> empty .)
    COMMENT         reduce using rule 11 (beginning_list -> empty .)
    LBRACE          reduce using rule 11 (beginning_list -> empty .)
    FOR             reduce using rule 11 (beginning_list -> empty .)
    VOID            reduce using rule 11 (beginning_list -> empty .)
    CHAR            reduce using rule 11 (beginning_list -> empty .)
    SHORT           reduce using rule 11 (beginning_list -> empty .)
    INT             reduce using rule 11 (beginning_list -> empty .)
    LONG            reduce using rule 11 (beginning_list -> empty .)
    FLOAT           reduce using rule 11 (beginning_list -> empty .)
    DOUBLE          reduce using rule 11 (beginning_list -> empty .)
    SIGNED          reduce using rule 11 (beginning_list -> empty .)
    UNSIGNED        reduce using rule 11 (beginning_list -> empty .)
    ID              reduce using rule 11 (beginning_list -> empty .)
    MINUS           reduce using rule 11 (beginning_list -> empty .)
    LOGNOT          reduce using rule 11 (beginning_list -> empty .)
    INT_CONST       reduce using rule 11 (beginning_list -> empty .)
    FLOAT_CONST     reduce using rule 11 (beginning_list -> empty .)
    STRING_LITERAL  reduce using rule 11 (beginning_list -> empty .)
    LPAREN          reduce using rule 11 (beginning_list -> empty .)


state 75

    (36) binop_expression -> term .

    TIMES           reduce using rule 36 (binop_expression -> term .)
    DIVIDE          reduce using rule 36 (binop_expression -> term .)
    PLUS            reduce using rule 36 (binop_expression -> term .)
    MINUS           reduce using rule 36 (binop_expression -> term .)
    MOD             reduce using rule 36 (binop_expression -> term .)
    OR              reduce using rule 36 (binop_expression -> term .)
    AND             reduce using rule 36 (binop_expression -> term .)
    LSHIFT          reduce using rule 36 (binop_expression -> term .)
    RSHIFT          reduce using rule 36 (binop_expression -> term .)
    LOGOR           reduce using rule 36 (binop_expression -> term .)
    LOGAND          reduce using rule 36 (binop_expression -> term .)
    LT              reduce using rule 36 (binop_expression -> term .)
    GT              reduce using rule 36 (binop_expression -> term .)
    LE              reduce using rule 36 (binop_expression -> term .)
    GE              reduce using rule 36 (binop_expression -> term .)
    EQ              reduce using rule 36 (binop_expression -> term .)
    NE              reduce using rule 36 (binop_expression -> term .)
    COMMENT         reduce using rule 36 (binop_expression -> term .)
    LBRACE          reduce using rule 36 (binop_expression -> term .)
    FOR             reduce using rule 36 (binop_expression -> term .)
    VOID            reduce using rule 36 (binop_expression -> term .)
    CHAR            reduce using rule 36 (binop_expression -> term .)
    SHORT           reduce using rule 36 (binop_expression -> term .)
    INT             reduce using rule 36 (binop_expression -> term .)
    LONG            reduce using rule 36 (binop_expression -> term .)
    FLOAT           reduce using rule 36 (binop_expression -> term .)
    DOUBLE          reduce using rule 36 (binop_expression -> term .)
    SIGNED          reduce using rule 36 (binop_expression -> term .)
    UNSIGNED        reduce using rule 36 (binop_expression -> term .)
    ID              reduce using rule 36 (binop_expression -> term .)
    LOGNOT          reduce using rule 36 (binop_expression -> term .)
    INT_CONST       reduce using rule 36 (binop_expression -> term .)
    FLOAT_CONST     reduce using rule 36 (binop_expression -> term .)
    STRING_LITERAL  reduce using rule 36 (binop_expression -> term .)
    LPAREN          reduce using rule 36 (binop_expression -> term .)
    $end            reduce using rule 36 (binop_expression -> term .)
    RPAREN          reduce using rule 36 (binop_expression -> term .)
    SEMI            reduce using rule 36 (binop_expression -> term .)
    RBRACE          reduce using rule 36 (binop_expression -> term .)
    RBRACKET        reduce using rule 36 (binop_expression -> term .)


state 76

    (34) binop_paren -> LPAREN binop_expression . RPAREN
    (35) binop_paren -> binop_expression .

    RPAREN          shift and go to state 96
    TIMES           reduce using rule 35 (binop_paren -> binop_expression .)
    DIVIDE          reduce using rule 35 (binop_paren -> binop_expression .)
    PLUS            reduce using rule 35 (binop_paren -> binop_expression .)
    MINUS           reduce using rule 35 (binop_paren -> binop_expression .)
    MOD             reduce using rule 35 (binop_paren -> binop_expression .)
    OR              reduce using rule 35 (binop_paren -> binop_expression .)
    AND             reduce using rule 35 (binop_paren -> binop_expression .)
    LSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    RSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    LOGOR           reduce using rule 35 (binop_paren -> binop_expression .)
    LOGAND          reduce using rule 35 (binop_paren -> binop_expression .)
    LT              reduce using rule 35 (binop_paren -> binop_expression .)
    GT              reduce using rule 35 (binop_paren -> binop_expression .)
    LE              reduce using rule 35 (binop_paren -> binop_expression .)
    GE              reduce using rule 35 (binop_paren -> binop_expression .)
    EQ              reduce using rule 35 (binop_paren -> binop_expression .)
    NE              reduce using rule 35 (binop_paren -> binop_expression .)


state 77

    (70) declaration -> typeid SEMI .

    RBRACE          reduce using rule 70 (declaration -> typeid SEMI .)
    COMMENT         reduce using rule 70 (declaration -> typeid SEMI .)
    LBRACE          reduce using rule 70 (declaration -> typeid SEMI .)
    FOR             reduce using rule 70 (declaration -> typeid SEMI .)
    VOID            reduce using rule 70 (declaration -> typeid SEMI .)
    CHAR            reduce using rule 70 (declaration -> typeid SEMI .)
    SHORT           reduce using rule 70 (declaration -> typeid SEMI .)
    INT             reduce using rule 70 (declaration -> typeid SEMI .)
    LONG            reduce using rule 70 (declaration -> typeid SEMI .)
    FLOAT           reduce using rule 70 (declaration -> typeid SEMI .)
    DOUBLE          reduce using rule 70 (declaration -> typeid SEMI .)
    SIGNED          reduce using rule 70 (declaration -> typeid SEMI .)
    UNSIGNED        reduce using rule 70 (declaration -> typeid SEMI .)
    ID              reduce using rule 70 (declaration -> typeid SEMI .)
    MINUS           reduce using rule 70 (declaration -> typeid SEMI .)
    LOGNOT          reduce using rule 70 (declaration -> typeid SEMI .)
    INT_CONST       reduce using rule 70 (declaration -> typeid SEMI .)
    FLOAT_CONST     reduce using rule 70 (declaration -> typeid SEMI .)
    STRING_LITERAL  reduce using rule 70 (declaration -> typeid SEMI .)
    LPAREN          reduce using rule 70 (declaration -> typeid SEMI .)
    $end            reduce using rule 70 (declaration -> typeid SEMI .)


state 78

    (21) assignment_expression -> typeid assignment_operator . expr
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 17
    LOGNOT          shift and go to state 14
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 28

    term                           shift and go to state 33
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 26
    expr                           shift and go to state 97
    binop_paren                    shift and go to state 11
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 45
    unary_token_before             shift and go to state 5

state 79

    (16) arglist -> LPAREN . arg_params RPAREN
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . typeid
    (15) arg_params -> . empty
    (71) typeid -> . type identifier
    (84) empty -> .
    (81) type -> . native_type
    (82) type -> . native_type TIMES
    (72) native_type -> . VOID
    (73) native_type -> . CHAR
    (74) native_type -> . SHORT
    (75) native_type -> . INT
    (76) native_type -> . LONG
    (77) native_type -> . FLOAT
    (78) native_type -> . DOUBLE
    (79) native_type -> . SIGNED
    (80) native_type -> . UNSIGNED

    RPAREN          reduce using rule 84 (empty -> .)
    VOID            shift and go to state 9
    CHAR            shift and go to state 13
    SHORT           shift and go to state 6
    INT             shift and go to state 36
    LONG            shift and go to state 22
    FLOAT           shift and go to state 38
    DOUBLE          shift and go to state 40
    SIGNED          shift and go to state 39
    UNSIGNED        shift and go to state 21

    typeid                         shift and go to state 98
    native_type                    shift and go to state 16
    type                           shift and go to state 91
    empty                          shift and go to state 99
    arg_params                     shift and go to state 100

state 80

    (68) function_declaration -> typeid arglist . SEMI
    (69) function_declaration -> typeid arglist . compound
    (67) compound -> . LBRACE beginning_list RBRACE

    SEMI            shift and go to state 101
    LBRACE          shift and go to state 27

    compound                       shift and go to state 102

state 81

    (62) array_reference -> identifier subscript_list .

    EQUALS          reduce using rule 62 (array_reference -> identifier subscript_list .)
    PLUSEQUALS      reduce using rule 62 (array_reference -> identifier subscript_list .)
    MINUSEQUALS     reduce using rule 62 (array_reference -> identifier subscript_list .)
    TIMESEQUALS     reduce using rule 62 (array_reference -> identifier subscript_list .)
    COMMENT         reduce using rule 62 (array_reference -> identifier subscript_list .)
    LBRACE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    FOR             reduce using rule 62 (array_reference -> identifier subscript_list .)
    VOID            reduce using rule 62 (array_reference -> identifier subscript_list .)
    CHAR            reduce using rule 62 (array_reference -> identifier subscript_list .)
    SHORT           reduce using rule 62 (array_reference -> identifier subscript_list .)
    INT             reduce using rule 62 (array_reference -> identifier subscript_list .)
    LONG            reduce using rule 62 (array_reference -> identifier subscript_list .)
    FLOAT           reduce using rule 62 (array_reference -> identifier subscript_list .)
    DOUBLE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    SIGNED          reduce using rule 62 (array_reference -> identifier subscript_list .)
    UNSIGNED        reduce using rule 62 (array_reference -> identifier subscript_list .)
    ID              reduce using rule 62 (array_reference -> identifier subscript_list .)
    MINUS           reduce using rule 62 (array_reference -> identifier subscript_list .)
    LOGNOT          reduce using rule 62 (array_reference -> identifier subscript_list .)
    INT_CONST       reduce using rule 62 (array_reference -> identifier subscript_list .)
    FLOAT_CONST     reduce using rule 62 (array_reference -> identifier subscript_list .)
    STRING_LITERAL  reduce using rule 62 (array_reference -> identifier subscript_list .)
    LPAREN          reduce using rule 62 (array_reference -> identifier subscript_list .)
    $end            reduce using rule 62 (array_reference -> identifier subscript_list .)
    TIMES           reduce using rule 62 (array_reference -> identifier subscript_list .)
    DIVIDE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    PLUS            reduce using rule 62 (array_reference -> identifier subscript_list .)
    MOD             reduce using rule 62 (array_reference -> identifier subscript_list .)
    OR              reduce using rule 62 (array_reference -> identifier subscript_list .)
    AND             reduce using rule 62 (array_reference -> identifier subscript_list .)
    LSHIFT          reduce using rule 62 (array_reference -> identifier subscript_list .)
    RSHIFT          reduce using rule 62 (array_reference -> identifier subscript_list .)
    LOGOR           reduce using rule 62 (array_reference -> identifier subscript_list .)
    LOGAND          reduce using rule 62 (array_reference -> identifier subscript_list .)
    LT              reduce using rule 62 (array_reference -> identifier subscript_list .)
    GT              reduce using rule 62 (array_reference -> identifier subscript_list .)
    LE              reduce using rule 62 (array_reference -> identifier subscript_list .)
    GE              reduce using rule 62 (array_reference -> identifier subscript_list .)
    EQ              reduce using rule 62 (array_reference -> identifier subscript_list .)
    NE              reduce using rule 62 (array_reference -> identifier subscript_list .)
    RPAREN          reduce using rule 62 (array_reference -> identifier subscript_list .)
    SEMI            reduce using rule 62 (array_reference -> identifier subscript_list .)
    RBRACE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    RBRACKET        reduce using rule 62 (array_reference -> identifier subscript_list .)
    PLUSPLUS        reduce using rule 62 (array_reference -> identifier subscript_list .)
    MINUSMINUS      reduce using rule 62 (array_reference -> identifier subscript_list .)


state 82

    (59) subscript -> LBRACKET . expr RBRACKET
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 17
    LOGNOT          shift and go to state 14
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 28

    unary_token_before             shift and go to state 5
    term                           shift and go to state 33
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 26
    expr                           shift and go to state 103
    binop_paren                    shift and go to state 11
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 45

state 83

    (22) assignment_expression -> identifier assignment_operator . expr
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 17
    LOGNOT          shift and go to state 14
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31
    LPAREN          shift and go to state 28

    unary_token_before             shift and go to state 5
    term                           shift and go to state 33
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 26
    expr                           shift and go to state 104
    binop_paren                    shift and go to state 11
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 45

state 84

    (60) subscript_list -> subscript .
    (61) subscript_list -> subscript . subscript_list
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    COMMENT         reduce using rule 60 (subscript_list -> subscript .)
    LBRACE          reduce using rule 60 (subscript_list -> subscript .)
    FOR             reduce using rule 60 (subscript_list -> subscript .)
    VOID            reduce using rule 60 (subscript_list -> subscript .)
    CHAR            reduce using rule 60 (subscript_list -> subscript .)
    SHORT           reduce using rule 60 (subscript_list -> subscript .)
    INT             reduce using rule 60 (subscript_list -> subscript .)
    LONG            reduce using rule 60 (subscript_list -> subscript .)
    FLOAT           reduce using rule 60 (subscript_list -> subscript .)
    DOUBLE          reduce using rule 60 (subscript_list -> subscript .)
    SIGNED          reduce using rule 60 (subscript_list -> subscript .)
    UNSIGNED        reduce using rule 60 (subscript_list -> subscript .)
    ID              reduce using rule 60 (subscript_list -> subscript .)
    MINUS           reduce using rule 60 (subscript_list -> subscript .)
    LOGNOT          reduce using rule 60 (subscript_list -> subscript .)
    INT_CONST       reduce using rule 60 (subscript_list -> subscript .)
    FLOAT_CONST     reduce using rule 60 (subscript_list -> subscript .)
    STRING_LITERAL  reduce using rule 60 (subscript_list -> subscript .)
    LPAREN          reduce using rule 60 (subscript_list -> subscript .)
    $end            reduce using rule 60 (subscript_list -> subscript .)
    SEMI            reduce using rule 60 (subscript_list -> subscript .)
    RBRACE          reduce using rule 60 (subscript_list -> subscript .)
    RBRACKET        reduce using rule 60 (subscript_list -> subscript .)
    RPAREN          reduce using rule 60 (subscript_list -> subscript .)
    TIMES           reduce using rule 60 (subscript_list -> subscript .)
    DIVIDE          reduce using rule 60 (subscript_list -> subscript .)
    PLUS            reduce using rule 60 (subscript_list -> subscript .)
    MOD             reduce using rule 60 (subscript_list -> subscript .)
    OR              reduce using rule 60 (subscript_list -> subscript .)
    AND             reduce using rule 60 (subscript_list -> subscript .)
    LSHIFT          reduce using rule 60 (subscript_list -> subscript .)
    RSHIFT          reduce using rule 60 (subscript_list -> subscript .)
    LOGOR           reduce using rule 60 (subscript_list -> subscript .)
    LOGAND          reduce using rule 60 (subscript_list -> subscript .)
    LT              reduce using rule 60 (subscript_list -> subscript .)
    GT              reduce using rule 60 (subscript_list -> subscript .)
    LE              reduce using rule 60 (subscript_list -> subscript .)
    GE              reduce using rule 60 (subscript_list -> subscript .)
    EQ              reduce using rule 60 (subscript_list -> subscript .)
    NE              reduce using rule 60 (subscript_list -> subscript .)
    PLUSPLUS        reduce using rule 60 (subscript_list -> subscript .)
    MINUSMINUS      reduce using rule 60 (subscript_list -> subscript .)
    EQUALS          reduce using rule 60 (subscript_list -> subscript .)
    PLUSEQUALS      reduce using rule 60 (subscript_list -> subscript .)
    MINUSEQUALS     reduce using rule 60 (subscript_list -> subscript .)
    TIMESEQUALS     reduce using rule 60 (subscript_list -> subscript .)
    LBRACKET        shift and go to state 82

    subscript                      shift and go to state 84
    subscript_list                 shift and go to state 105

state 85

    (38) binop_expression -> binop_paren DIVIDE binop_paren .
    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

    TIMES           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    DIVIDE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    PLUS            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    MINUS           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    MOD             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    OR              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    AND             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LSHIFT          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RSHIFT          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LOGOR           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LOGAND          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LT              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    GT              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LE              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    GE              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    EQ              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    NE              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    COMMENT         reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LBRACE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    FOR             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    VOID            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    CHAR            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SHORT           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    INT             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LONG            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    FLOAT           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    DOUBLE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SIGNED          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    UNSIGNED        reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    ID              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LOGNOT          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    INT_CONST       reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    FLOAT_CONST     reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    STRING_LITERAL  reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LPAREN          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    $end            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RPAREN          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SEMI            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RBRACE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RBRACKET        reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)

  ! TIMES           [ shift and go to state 54 ]
  ! DIVIDE          [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 46 ]
  ! LSHIFT          [ shift and go to state 58 ]
  ! RSHIFT          [ shift and go to state 49 ]
  ! LOGOR           [ shift and go to state 51 ]
  ! LOGAND          [ shift and go to state 52 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 48 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 53 ]
  ! EQ              [ shift and go to state 60 ]
  ! NE              [ shift and go to state 62 ]

    binary_token                   shift and go to state 63

state 86

    (35) binop_paren -> binop_expression .

    TIMES           reduce using rule 35 (binop_paren -> binop_expression .)
    DIVIDE          reduce using rule 35 (binop_paren -> binop_expression .)
    PLUS            reduce using rule 35 (binop_paren -> binop_expression .)
    MINUS           reduce using rule 35 (binop_paren -> binop_expression .)
    MOD             reduce using rule 35 (binop_paren -> binop_expression .)
    OR              reduce using rule 35 (binop_paren -> binop_expression .)
    AND             reduce using rule 35 (binop_paren -> binop_expression .)
    LSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    RSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    LOGOR           reduce using rule 35 (binop_paren -> binop_expression .)
    LOGAND          reduce using rule 35 (binop_paren -> binop_expression .)
    LT              reduce using rule 35 (binop_paren -> binop_expression .)
    GT              reduce using rule 35 (binop_paren -> binop_expression .)
    LE              reduce using rule 35 (binop_paren -> binop_expression .)
    GE              reduce using rule 35 (binop_paren -> binop_expression .)
    EQ              reduce using rule 35 (binop_paren -> binop_expression .)
    NE              reduce using rule 35 (binop_paren -> binop_expression .)
    COMMENT         reduce using rule 35 (binop_paren -> binop_expression .)
    LBRACE          reduce using rule 35 (binop_paren -> binop_expression .)
    FOR             reduce using rule 35 (binop_paren -> binop_expression .)
    VOID            reduce using rule 35 (binop_paren -> binop_expression .)
    CHAR            reduce using rule 35 (binop_paren -> binop_expression .)
    SHORT           reduce using rule 35 (binop_paren -> binop_expression .)
    INT             reduce using rule 35 (binop_paren -> binop_expression .)
    LONG            reduce using rule 35 (binop_paren -> binop_expression .)
    FLOAT           reduce using rule 35 (binop_paren -> binop_expression .)
    DOUBLE          reduce using rule 35 (binop_paren -> binop_expression .)
    SIGNED          reduce using rule 35 (binop_paren -> binop_expression .)
    UNSIGNED        reduce using rule 35 (binop_paren -> binop_expression .)
    ID              reduce using rule 35 (binop_paren -> binop_expression .)
    LOGNOT          reduce using rule 35 (binop_paren -> binop_expression .)
    INT_CONST       reduce using rule 35 (binop_paren -> binop_expression .)
    FLOAT_CONST     reduce using rule 35 (binop_paren -> binop_expression .)
    STRING_LITERAL  reduce using rule 35 (binop_paren -> binop_expression .)
    LPAREN          reduce using rule 35 (binop_paren -> binop_expression .)
    $end            reduce using rule 35 (binop_paren -> binop_expression .)
    RPAREN          reduce using rule 35 (binop_paren -> binop_expression .)
    SEMI            reduce using rule 35 (binop_paren -> binop_expression .)
    RBRACE          reduce using rule 35 (binop_paren -> binop_expression .)
    RBRACKET        reduce using rule 35 (binop_paren -> binop_expression .)


state 87

    (37) binop_expression -> binop_paren TIMES binop_paren .
    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

    TIMES           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    DIVIDE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    PLUS            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    MINUS           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    MOD             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    OR              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    AND             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LSHIFT          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RSHIFT          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LOGOR           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LOGAND          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LT              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    GT              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LE              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    GE              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    EQ              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    NE              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    COMMENT         reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LBRACE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    FOR             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    VOID            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    CHAR            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SHORT           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    INT             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LONG            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    FLOAT           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    DOUBLE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SIGNED          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    UNSIGNED        reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    ID              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LOGNOT          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    INT_CONST       reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    FLOAT_CONST     reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    STRING_LITERAL  reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LPAREN          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    $end            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RPAREN          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SEMI            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RBRACE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RBRACKET        reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)

  ! TIMES           [ shift and go to state 54 ]
  ! DIVIDE          [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 47 ]
  ! AND             [ shift and go to state 46 ]
  ! LSHIFT          [ shift and go to state 58 ]
  ! RSHIFT          [ shift and go to state 49 ]
  ! LOGOR           [ shift and go to state 51 ]
  ! LOGAND          [ shift and go to state 52 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 48 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 53 ]
  ! EQ              [ shift and go to state 60 ]
  ! NE              [ shift and go to state 62 ]

    binary_token                   shift and go to state 63

state 88

    (39) binop_expression -> binop_paren binary_token binop_paren .
    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LBRACE          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    FOR             reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    VOID            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    CHAR            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SHORT           reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    INT             reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LONG            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    FLOAT           reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    DOUBLE          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SIGNED          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    UNSIGNED        reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    ID              reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LOGNOT          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    INT_CONST       reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    FLOAT_CONST     reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    STRING_LITERAL  reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LPAREN          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    $end            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    RPAREN          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SEMI            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    RBRACE          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    RBRACKET        reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    TIMES           shift and go to state 54
    DIVIDE          shift and go to state 50
    PLUS            shift and go to state 57
    MINUS           shift and go to state 61
    MOD             shift and go to state 59
    OR              shift and go to state 47
    AND             shift and go to state 46
    LSHIFT          shift and go to state 58
    RSHIFT          shift and go to state 49
    LOGOR           shift and go to state 51
    LOGAND          shift and go to state 52
    LT              shift and go to state 55
    GT              shift and go to state 48
    LE              shift and go to state 56
    GE              shift and go to state 53
    EQ              shift and go to state 60
    NE              shift and go to state 62

  ! TIMES           [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! DIVIDE          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! PLUS            [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! MINUS           [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! MOD             [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! OR              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! AND             [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LSHIFT          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! RSHIFT          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LOGOR           [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LOGAND          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LT              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! GT              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LE              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! GE              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! EQ              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! NE              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]

    binary_token                   shift and go to state 63

state 89

    (23) assignment_expression -> array_reference assignment_operator expr .

    SEMI            reduce using rule 23 (assignment_expression -> array_reference assignment_operator expr .)


state 90

    (23) assignment_expression -> array_reference . assignment_operator expr
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    EQUALS          shift and go to state 64
    PLUSEQUALS      shift and go to state 65
    MINUSEQUALS     shift and go to state 67
    TIMESEQUALS     shift and go to state 68

    assignment_operator            shift and go to state 66

state 91

    (71) typeid -> type . identifier
    (83) identifier -> . ID

    ID              shift and go to state 30

    identifier                     shift and go to state 71

state 92

    (63) for_loop -> FOR LPAREN assignment_expression . SEMI binop SEMI increment RPAREN compound

    SEMI            shift and go to state 106


state 93

    (21) assignment_expression -> typeid . assignment_operator expr
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    EQUALS          shift and go to state 64
    PLUSEQUALS      shift and go to state 65
    MINUSEQUALS     shift and go to state 67
    TIMESEQUALS     shift and go to state 68

    assignment_operator            shift and go to state 78

state 94

    (22) assignment_expression -> identifier . assignment_operator expr
    (62) array_reference -> identifier . subscript_list
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    EQUALS          shift and go to state 64
    PLUSEQUALS      shift and go to state 65
    MINUSEQUALS     shift and go to state 67
    TIMESEQUALS     shift and go to state 68
    LBRACKET        shift and go to state 82

    subscript                      shift and go to state 84
    subscript_list                 shift and go to state 81
    assignment_operator            shift and go to state 83

state 95

    (67) compound -> LBRACE beginning_list RBRACE .

    COMMENT         reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LBRACE          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    FOR             reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    VOID            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    CHAR            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    SHORT           reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    INT             reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LONG            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    FLOAT           reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    DOUBLE          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    SIGNED          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    UNSIGNED        reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    ID              reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    MINUS           reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LOGNOT          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    INT_CONST       reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    FLOAT_CONST     reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    STRING_LITERAL  reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LPAREN          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    $end            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    RBRACE          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)


state 96

    (34) binop_paren -> LPAREN binop_expression RPAREN .

    TIMES           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    DIVIDE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    PLUS            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    MINUS           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    MOD             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    OR              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    AND             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LSHIFT          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RSHIFT          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LOGOR           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LOGAND          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LT              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    GT              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LE              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    GE              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    EQ              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    NE              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    COMMENT         reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LBRACE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    FOR             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    VOID            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    CHAR            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SHORT           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    INT             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LONG            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    FLOAT           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    DOUBLE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SIGNED          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    UNSIGNED        reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    ID              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LOGNOT          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    INT_CONST       reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    FLOAT_CONST     reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    STRING_LITERAL  reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LPAREN          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    $end            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RPAREN          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SEMI            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RBRACE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RBRACKET        reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)


state 97

    (21) assignment_expression -> typeid assignment_operator expr .

    SEMI            reduce using rule 21 (assignment_expression -> typeid assignment_operator expr .)


state 98

    (13) arg_params -> typeid . COMMA arg_params
    (14) arg_params -> typeid .

    COMMA           shift and go to state 107
    RPAREN          reduce using rule 14 (arg_params -> typeid .)


state 99

    (15) arg_params -> empty .

    RPAREN          reduce using rule 15 (arg_params -> empty .)


state 100

    (16) arglist -> LPAREN arg_params . RPAREN

    RPAREN          shift and go to state 108


state 101

    (68) function_declaration -> typeid arglist SEMI .

    RBRACE          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    COMMENT         reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LBRACE          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    FOR             reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    VOID            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    CHAR            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    SHORT           reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    INT             reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LONG            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    FLOAT           reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    DOUBLE          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    SIGNED          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    UNSIGNED        reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    ID              reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    MINUS           reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LOGNOT          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    INT_CONST       reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    FLOAT_CONST     reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    STRING_LITERAL  reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LPAREN          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    $end            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)


state 102

    (69) function_declaration -> typeid arglist compound .

    RBRACE          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    COMMENT         reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LBRACE          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    FOR             reduce using rule 69 (function_declaration -> typeid arglist compound .)
    VOID            reduce using rule 69 (function_declaration -> typeid arglist compound .)
    CHAR            reduce using rule 69 (function_declaration -> typeid arglist compound .)
    SHORT           reduce using rule 69 (function_declaration -> typeid arglist compound .)
    INT             reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LONG            reduce using rule 69 (function_declaration -> typeid arglist compound .)
    FLOAT           reduce using rule 69 (function_declaration -> typeid arglist compound .)
    DOUBLE          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    SIGNED          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    UNSIGNED        reduce using rule 69 (function_declaration -> typeid arglist compound .)
    ID              reduce using rule 69 (function_declaration -> typeid arglist compound .)
    MINUS           reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LOGNOT          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    INT_CONST       reduce using rule 69 (function_declaration -> typeid arglist compound .)
    FLOAT_CONST     reduce using rule 69 (function_declaration -> typeid arglist compound .)
    STRING_LITERAL  reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LPAREN          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    $end            reduce using rule 69 (function_declaration -> typeid arglist compound .)


state 103

    (59) subscript -> LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 109


state 104

    (22) assignment_expression -> identifier assignment_operator expr .

    SEMI            reduce using rule 22 (assignment_expression -> identifier assignment_operator expr .)


state 105

    (61) subscript_list -> subscript subscript_list .

    COMMENT         reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LBRACE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    FOR             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    VOID            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    CHAR            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SHORT           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    INT             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LONG            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    FLOAT           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    DOUBLE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SIGNED          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    UNSIGNED        reduce using rule 61 (subscript_list -> subscript subscript_list .)
    ID              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MINUS           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LOGNOT          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    INT_CONST       reduce using rule 61 (subscript_list -> subscript subscript_list .)
    FLOAT_CONST     reduce using rule 61 (subscript_list -> subscript subscript_list .)
    STRING_LITERAL  reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LPAREN          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    $end            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SEMI            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RBRACE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RBRACKET        reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RPAREN          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    TIMES           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    DIVIDE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    PLUS            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MOD             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    OR              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    AND             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LSHIFT          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RSHIFT          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LOGOR           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LOGAND          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LT              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    GT              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LE              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    GE              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    EQ              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    NE              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    PLUSPLUS        reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MINUSMINUS      reduce using rule 61 (subscript_list -> subscript subscript_list .)
    EQUALS          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    PLUSEQUALS      reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MINUSEQUALS     reduce using rule 61 (subscript_list -> subscript subscript_list .)
    TIMESEQUALS     reduce using rule 61 (subscript_list -> subscript subscript_list .)


state 106

    (63) for_loop -> FOR LPAREN assignment_expression SEMI . binop SEMI increment RPAREN compound
    (40) binop -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 75
    constant                       shift and go to state 7
    binop                          shift and go to state 110
    binop_paren                    shift and go to state 11
    array_reference                shift and go to state 44
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 45

state 107

    (13) arg_params -> typeid COMMA . arg_params
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . typeid
    (15) arg_params -> . empty
    (71) typeid -> . type identifier
    (84) empty -> .
    (81) type -> . native_type
    (82) type -> . native_type TIMES
    (72) native_type -> . VOID
    (73) native_type -> . CHAR
    (74) native_type -> . SHORT
    (75) native_type -> . INT
    (76) native_type -> . LONG
    (77) native_type -> . FLOAT
    (78) native_type -> . DOUBLE
    (79) native_type -> . SIGNED
    (80) native_type -> . UNSIGNED

    RPAREN          reduce using rule 84 (empty -> .)
    VOID            shift and go to state 9
    CHAR            shift and go to state 13
    SHORT           shift and go to state 6
    INT             shift and go to state 36
    LONG            shift and go to state 22
    FLOAT           shift and go to state 38
    DOUBLE          shift and go to state 40
    SIGNED          shift and go to state 39
    UNSIGNED        shift and go to state 21

    typeid                         shift and go to state 98
    native_type                    shift and go to state 16
    type                           shift and go to state 91
    empty                          shift and go to state 99
    arg_params                     shift and go to state 111

state 108

    (16) arglist -> LPAREN arg_params RPAREN .

    SEMI            reduce using rule 16 (arglist -> LPAREN arg_params RPAREN .)
    LBRACE          reduce using rule 16 (arglist -> LPAREN arg_params RPAREN .)


state 109

    (59) subscript -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    EQUALS          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    PLUSEQUALS      reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MINUSEQUALS     reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    TIMESEQUALS     reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    COMMENT         reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    FOR             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    VOID            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    CHAR            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SHORT           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    INT             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LONG            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    FLOAT           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    DOUBLE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SIGNED          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    UNSIGNED        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    ID              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LOGNOT          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    INT_CONST       reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    FLOAT_CONST     reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    STRING_LITERAL  reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    $end            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MOD             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LSHIFT          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RSHIFT          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LOGOR           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LOGAND          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LE              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    GE              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    EQ              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    NE              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    PLUSPLUS        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MINUSMINUS      reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)


state 110

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop . SEMI increment RPAREN compound

    SEMI            shift and go to state 112


state 111

    (13) arg_params -> typeid COMMA arg_params .

    RPAREN          reduce using rule 13 (arg_params -> typeid COMMA arg_params .)


state 112

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI . increment RPAREN compound
    (33) increment -> . term unary_token_after
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (83) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    ID              shift and go to state 30
    INT_CONST       shift and go to state 19
    FLOAT_CONST     shift and go to state 42
    STRING_LITERAL  shift and go to state 31

    term                           shift and go to state 113
    constant                       shift and go to state 7
    array_reference                shift and go to state 44
    increment                      shift and go to state 114
    identifier                     shift and go to state 45

state 113

    (33) increment -> term . unary_token_after
    (30) unary_token_after -> . PLUSPLUS
    (31) unary_token_after -> . MINUSMINUS

    PLUSPLUS        shift and go to state 115
    MINUSMINUS      shift and go to state 116

    unary_token_after              shift and go to state 117

state 114

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment . RPAREN compound

    RPAREN          shift and go to state 118


state 115

    (30) unary_token_after -> PLUSPLUS .

    RPAREN          reduce using rule 30 (unary_token_after -> PLUSPLUS .)


state 116

    (31) unary_token_after -> MINUSMINUS .

    RPAREN          reduce using rule 31 (unary_token_after -> MINUSMINUS .)


state 117

    (33) increment -> term unary_token_after .

    RPAREN          reduce using rule 33 (increment -> term unary_token_after .)


state 118

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN . compound
    (67) compound -> . LBRACE beginning_list RBRACE

    LBRACE          shift and go to state 27

    compound                       shift and go to state 119

state 119

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .

    COMMENT         reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LBRACE          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FOR             reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    VOID            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    CHAR            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SHORT           reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    INT             reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LONG            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FLOAT           reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    DOUBLE          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SIGNED          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    UNSIGNED        reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    ID              reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    MINUS           reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LOGNOT          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    INT_CONST       reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FLOAT_CONST     reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    STRING_LITERAL  reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LPAREN          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    $end            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    RBRACE          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 23 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MOD in state 88 resolved as shift
WARNING: shift/reduce conflict for OR in state 88 resolved as shift
WARNING: shift/reduce conflict for AND in state 88 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 88 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 88 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 88 resolved as shift
WARNING: shift/reduce conflict for LT in state 88 resolved as shift
WARNING: shift/reduce conflict for GT in state 88 resolved as shift
WARNING: shift/reduce conflict for LE in state 88 resolved as shift
WARNING: shift/reduce conflict for GE in state 88 resolved as shift
WARNING: shift/reduce conflict for EQ in state 88 resolved as shift
WARNING: shift/reduce conflict for NE in state 88 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (first -> empty)
WARNING: rejected rule (beginning_list -> empty) in state 2
WARNING: reduce/reduce conflict in state 12 resolved using rule (binop_paren -> binop_expression)
WARNING: rejected rule (binop -> binop_expression) in state 12
WARNING: reduce/reduce conflict in state 33 resolved using rule (binop_expression -> term)
WARNING: rejected rule (expr -> term) in state 33
WARNING: Rule (expr -> term) is never reduced
