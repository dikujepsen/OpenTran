Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    RETURN
    WHILE
    EXTERN
    SIZEOF
    COLON
    PERIOD
    ELSE
    IF
    STRUCT
    PPHASH

Grammar

Rule 0     S' -> first
Rule 1     first -> beginning_list
Rule 2     first -> empty
Rule 3     beginning_list -> beginning_list comment
Rule 4     beginning_list -> beginning_list function_declaration
Rule 5     beginning_list -> beginning_list type
Rule 6     beginning_list -> beginning_list declaration
Rule 7     beginning_list -> beginning_list compound
Rule 8     beginning_list -> beginning_list assignment_expression_semi
Rule 9     beginning_list -> beginning_list expr
Rule 10    beginning_list -> beginning_list for_loop
Rule 11    beginning_list -> empty
Rule 12    comment -> COMMENT
Rule 13    arg_params -> typeid COMMA arg_params
Rule 14    arg_params -> typeid
Rule 15    arg_params -> empty
Rule 16    arglist -> LPAREN arg_params RPAREN
Rule 17    assignment_operator -> EQUALS
Rule 18    assignment_operator -> PLUSEQUALS
Rule 19    assignment_operator -> MINUSEQUALS
Rule 20    assignment_operator -> TIMESEQUALS
Rule 21    assignment_expression -> typeid assignment_operator expr
Rule 22    assignment_expression -> identifier assignment_operator expr
Rule 23    assignment_expression -> array_reference assignment_operator expr
Rule 24    assignment_expression_semi -> assignment_expression SEMI
Rule 25    constant -> INT_CONST
Rule 26    constant -> FLOAT_CONST
Rule 27    constant -> STRING_LITERAL
Rule 28    unary_token_before -> MINUS
Rule 29    unary_token_before -> LOGNOT
Rule 30    unary_token_after -> PLUSPLUS
Rule 31    unary_token_after -> MINUSMINUS
Rule 32    unary_expression -> unary_token_before term
Rule 33    increment -> term unary_token_after
Rule 34    binop_paren -> LPAREN binop_expression RPAREN
Rule 35    binop_paren -> binop_expression
Rule 36    binop_expression -> term
Rule 37    binop_expression -> binop_paren TIMES binop_paren
Rule 38    binop_expression -> binop_paren DIVIDE binop_paren
Rule 39    binop_expression -> binop_paren binary_token binop_paren
Rule 40    binop -> binop_expression
Rule 41    expr -> unary_expression
Rule 42    expr -> binop
Rule 43    expr -> term
Rule 44    binary_token -> PLUS
Rule 45    binary_token -> MINUS
Rule 46    binary_token -> MOD
Rule 47    binary_token -> OR
Rule 48    binary_token -> AND
Rule 49    binary_token -> LSHIFT
Rule 50    binary_token -> RSHIFT
Rule 51    binary_token -> LOGOR
Rule 52    binary_token -> LOGAND
Rule 53    binary_token -> LT
Rule 54    binary_token -> GT
Rule 55    binary_token -> LE
Rule 56    binary_token -> GE
Rule 57    binary_token -> EQ
Rule 58    binary_token -> NE
Rule 59    subscript -> LBRACKET expr RBRACKET
Rule 60    subscript_list -> subscript
Rule 61    subscript_list -> subscript subscript_list
Rule 62    array_reference -> identifier subscript_list
Rule 63    for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
Rule 64    term -> identifier
Rule 65    term -> constant
Rule 66    term -> array_reference
Rule 67    compound -> LBRACE beginning_list RBRACE
Rule 68    function_declaration -> typeid arglist SEMI
Rule 69    function_declaration -> typeid arglist compound
Rule 70    declaration -> typeid SEMI
Rule 71    typeid -> type identifier
Rule 72    native_type -> VOID
Rule 73    native_type -> SIZE_T
Rule 74    native_type -> UNKNOWN
Rule 75    native_type -> CHAR
Rule 76    native_type -> SHORT
Rule 77    native_type -> INT
Rule 78    native_type -> LONG
Rule 79    native_type -> FLOAT
Rule 80    native_type -> DOUBLE
Rule 81    native_type -> SIGNED
Rule 82    native_type -> UNSIGNED
Rule 83    type -> native_type
Rule 84    type -> native_type TIMES
Rule 85    identifier -> ID
Rule 86    empty -> <empty>

Terminals, with rules where they appear

AND                  : 48
CHAR                 : 75
COLON                : 
COMMA                : 13
COMMENT              : 12
DIVIDE               : 38
DO                   : 
DOUBLE               : 80
ELSE                 : 
EQ                   : 57
EQUALS               : 17
EXTERN               : 
FLOAT                : 79
FLOAT_CONST          : 26
FOR                  : 63
GE                   : 56
GT                   : 54
ID                   : 85
IF                   : 
INT                  : 77
INT_CONST            : 25
LBRACE               : 67
LBRACKET             : 59
LE                   : 55
LOGAND               : 52
LOGNOT               : 29
LOGOR                : 51
LONG                 : 78
LPAREN               : 16 34 63
LSHIFT               : 49
LT                   : 53
MINUS                : 28 45
MINUSEQUALS          : 19
MINUSMINUS           : 31
MOD                  : 46
NE                   : 58
OR                   : 47
PERIOD               : 
PLUS                 : 44
PLUSEQUALS           : 18
PLUSPLUS             : 30
PPHASH               : 
RBRACE               : 67
RBRACKET             : 59
RETURN               : 
RPAREN               : 16 34 63
RSHIFT               : 50
SEMI                 : 24 63 63 68 70
SHORT                : 76
SIGNED               : 81
SIZEOF               : 
SIZE_T               : 73
STRING_LITERAL       : 27
STRUCT               : 
TIMES                : 37 84
TIMESEQUALS          : 20
UNKNOWN              : 74
UNSIGNED             : 82
VOID                 : 72
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arg_params           : 13 16
arglist              : 68 69
array_reference      : 23 66
assignment_expression : 24 63
assignment_expression_semi : 8
assignment_operator  : 21 22 23
beginning_list       : 1 3 4 5 6 7 8 9 10 67
binary_token         : 39
binop                : 42 63
binop_expression     : 34 35 40
binop_paren          : 37 37 38 38 39 39
comment              : 3
compound             : 7 63 69
constant             : 65
declaration          : 6
empty                : 2 11 15
expr                 : 9 21 22 23 59
first                : 0
for_loop             : 10
function_declaration : 4
identifier           : 22 62 64 71
increment            : 63
native_type          : 83 84
subscript            : 60 61
subscript_list       : 61 62
term                 : 32 33 36 43
type                 : 5 71
typeid               : 13 14 21 68 69 70
unary_expression     : 41
unary_token_after    : 33
unary_token_before   : 32

Parsing method: LALR

state 0

    (0) S' -> . first
    (1) first -> . beginning_list
    (2) first -> . empty
    (3) beginning_list -> . beginning_list comment
    (4) beginning_list -> . beginning_list function_declaration
    (5) beginning_list -> . beginning_list type
    (6) beginning_list -> . beginning_list declaration
    (7) beginning_list -> . beginning_list compound
    (8) beginning_list -> . beginning_list assignment_expression_semi
    (9) beginning_list -> . beginning_list expr
    (10) beginning_list -> . beginning_list for_loop
    (11) beginning_list -> . empty
    (86) empty -> .

    $end            reduce using rule 86 (empty -> .)
    COMMENT         reduce using rule 86 (empty -> .)
    LBRACE          reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    VOID            reduce using rule 86 (empty -> .)
    SIZE_T          reduce using rule 86 (empty -> .)
    UNKNOWN         reduce using rule 86 (empty -> .)
    CHAR            reduce using rule 86 (empty -> .)
    SHORT           reduce using rule 86 (empty -> .)
    INT             reduce using rule 86 (empty -> .)
    LONG            reduce using rule 86 (empty -> .)
    FLOAT           reduce using rule 86 (empty -> .)
    DOUBLE          reduce using rule 86 (empty -> .)
    SIGNED          reduce using rule 86 (empty -> .)
    UNSIGNED        reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    LOGNOT          reduce using rule 86 (empty -> .)
    INT_CONST       reduce using rule 86 (empty -> .)
    FLOAT_CONST     reduce using rule 86 (empty -> .)
    STRING_LITERAL  reduce using rule 86 (empty -> .)
    LPAREN          reduce using rule 86 (empty -> .)

    beginning_list                 shift and go to state 1
    empty                          shift and go to state 2
    first                          shift and go to state 3

state 1

    (1) first -> beginning_list .
    (3) beginning_list -> beginning_list . comment
    (4) beginning_list -> beginning_list . function_declaration
    (5) beginning_list -> beginning_list . type
    (6) beginning_list -> beginning_list . declaration
    (7) beginning_list -> beginning_list . compound
    (8) beginning_list -> beginning_list . assignment_expression_semi
    (9) beginning_list -> beginning_list . expr
    (10) beginning_list -> beginning_list . for_loop
    (12) comment -> . COMMENT
    (68) function_declaration -> . typeid arglist SEMI
    (69) function_declaration -> . typeid arglist compound
    (83) type -> . native_type
    (84) type -> . native_type TIMES
    (70) declaration -> . typeid SEMI
    (67) compound -> . LBRACE beginning_list RBRACE
    (24) assignment_expression_semi -> . assignment_expression SEMI
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (63) for_loop -> . FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
    (71) typeid -> . type identifier
    (72) native_type -> . VOID
    (73) native_type -> . SIZE_T
    (74) native_type -> . UNKNOWN
    (75) native_type -> . CHAR
    (76) native_type -> . SHORT
    (77) native_type -> . INT
    (78) native_type -> . LONG
    (79) native_type -> . FLOAT
    (80) native_type -> . DOUBLE
    (81) native_type -> . SIGNED
    (82) native_type -> . UNSIGNED
    (21) assignment_expression -> . typeid assignment_operator expr
    (22) assignment_expression -> . identifier assignment_operator expr
    (23) assignment_expression -> . array_reference assignment_operator expr
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (62) array_reference -> . identifier subscript_list
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    $end            reduce using rule 1 (first -> beginning_list .)
    COMMENT         shift and go to state 19
    LBRACE          shift and go to state 28
    FOR             shift and go to state 21
    VOID            shift and go to state 10
    SIZE_T          shift and go to state 42
    UNKNOWN         shift and go to state 9
    CHAR            shift and go to state 14
    SHORT           shift and go to state 6
    INT             shift and go to state 37
    LONG            shift and go to state 23
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 41
    SIGNED          shift and go to state 40
    UNSIGNED        shift and go to state 22
    ID              shift and go to state 31
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 15
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32
    LPAREN          shift and go to state 29

    comment                        shift and go to state 4
    unary_token_before             shift and go to state 5
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    compound                       shift and go to state 11
    binop_paren                    shift and go to state 12
    binop_expression               shift and go to state 13
    native_type                    shift and go to state 17
    array_reference                shift and go to state 16
    type                           shift and go to state 24
    for_loop                       shift and go to state 25
    assignment_expression          shift and go to state 26
    binop                          shift and go to state 27
    declaration                    shift and go to state 30
    typeid                         shift and go to state 33
    term                           shift and go to state 34
    assignment_expression_semi     shift and go to state 35
    function_declaration           shift and go to state 36
    expr                           shift and go to state 38
    identifier                     shift and go to state 43

state 2

    (2) first -> empty .
    (11) beginning_list -> empty .

  ! reduce/reduce conflict for $end resolved using rule 2 (first -> empty .)
    $end            reduce using rule 2 (first -> empty .)
    COMMENT         reduce using rule 11 (beginning_list -> empty .)
    LBRACE          reduce using rule 11 (beginning_list -> empty .)
    FOR             reduce using rule 11 (beginning_list -> empty .)
    VOID            reduce using rule 11 (beginning_list -> empty .)
    SIZE_T          reduce using rule 11 (beginning_list -> empty .)
    UNKNOWN         reduce using rule 11 (beginning_list -> empty .)
    CHAR            reduce using rule 11 (beginning_list -> empty .)
    SHORT           reduce using rule 11 (beginning_list -> empty .)
    INT             reduce using rule 11 (beginning_list -> empty .)
    LONG            reduce using rule 11 (beginning_list -> empty .)
    FLOAT           reduce using rule 11 (beginning_list -> empty .)
    DOUBLE          reduce using rule 11 (beginning_list -> empty .)
    SIGNED          reduce using rule 11 (beginning_list -> empty .)
    UNSIGNED        reduce using rule 11 (beginning_list -> empty .)
    ID              reduce using rule 11 (beginning_list -> empty .)
    MINUS           reduce using rule 11 (beginning_list -> empty .)
    LOGNOT          reduce using rule 11 (beginning_list -> empty .)
    INT_CONST       reduce using rule 11 (beginning_list -> empty .)
    FLOAT_CONST     reduce using rule 11 (beginning_list -> empty .)
    STRING_LITERAL  reduce using rule 11 (beginning_list -> empty .)
    LPAREN          reduce using rule 11 (beginning_list -> empty .)

  ! $end            [ reduce using rule 11 (beginning_list -> empty .) ]


state 3

    (0) S' -> first .



state 4

    (3) beginning_list -> beginning_list comment .

    COMMENT         reduce using rule 3 (beginning_list -> beginning_list comment .)
    LBRACE          reduce using rule 3 (beginning_list -> beginning_list comment .)
    FOR             reduce using rule 3 (beginning_list -> beginning_list comment .)
    VOID            reduce using rule 3 (beginning_list -> beginning_list comment .)
    SIZE_T          reduce using rule 3 (beginning_list -> beginning_list comment .)
    UNKNOWN         reduce using rule 3 (beginning_list -> beginning_list comment .)
    CHAR            reduce using rule 3 (beginning_list -> beginning_list comment .)
    SHORT           reduce using rule 3 (beginning_list -> beginning_list comment .)
    INT             reduce using rule 3 (beginning_list -> beginning_list comment .)
    LONG            reduce using rule 3 (beginning_list -> beginning_list comment .)
    FLOAT           reduce using rule 3 (beginning_list -> beginning_list comment .)
    DOUBLE          reduce using rule 3 (beginning_list -> beginning_list comment .)
    SIGNED          reduce using rule 3 (beginning_list -> beginning_list comment .)
    UNSIGNED        reduce using rule 3 (beginning_list -> beginning_list comment .)
    ID              reduce using rule 3 (beginning_list -> beginning_list comment .)
    MINUS           reduce using rule 3 (beginning_list -> beginning_list comment .)
    LOGNOT          reduce using rule 3 (beginning_list -> beginning_list comment .)
    INT_CONST       reduce using rule 3 (beginning_list -> beginning_list comment .)
    FLOAT_CONST     reduce using rule 3 (beginning_list -> beginning_list comment .)
    STRING_LITERAL  reduce using rule 3 (beginning_list -> beginning_list comment .)
    LPAREN          reduce using rule 3 (beginning_list -> beginning_list comment .)
    $end            reduce using rule 3 (beginning_list -> beginning_list comment .)
    RBRACE          reduce using rule 3 (beginning_list -> beginning_list comment .)


state 5

    (32) unary_expression -> unary_token_before . term
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 45
    constant                       shift and go to state 7
    array_reference                shift and go to state 46
    identifier                     shift and go to state 47

state 6

    (76) native_type -> SHORT .

    TIMES           reduce using rule 76 (native_type -> SHORT .)
    ID              reduce using rule 76 (native_type -> SHORT .)
    COMMENT         reduce using rule 76 (native_type -> SHORT .)
    LBRACE          reduce using rule 76 (native_type -> SHORT .)
    FOR             reduce using rule 76 (native_type -> SHORT .)
    VOID            reduce using rule 76 (native_type -> SHORT .)
    SIZE_T          reduce using rule 76 (native_type -> SHORT .)
    UNKNOWN         reduce using rule 76 (native_type -> SHORT .)
    CHAR            reduce using rule 76 (native_type -> SHORT .)
    SHORT           reduce using rule 76 (native_type -> SHORT .)
    INT             reduce using rule 76 (native_type -> SHORT .)
    LONG            reduce using rule 76 (native_type -> SHORT .)
    FLOAT           reduce using rule 76 (native_type -> SHORT .)
    DOUBLE          reduce using rule 76 (native_type -> SHORT .)
    SIGNED          reduce using rule 76 (native_type -> SHORT .)
    UNSIGNED        reduce using rule 76 (native_type -> SHORT .)
    MINUS           reduce using rule 76 (native_type -> SHORT .)
    LOGNOT          reduce using rule 76 (native_type -> SHORT .)
    INT_CONST       reduce using rule 76 (native_type -> SHORT .)
    FLOAT_CONST     reduce using rule 76 (native_type -> SHORT .)
    STRING_LITERAL  reduce using rule 76 (native_type -> SHORT .)
    LPAREN          reduce using rule 76 (native_type -> SHORT .)
    $end            reduce using rule 76 (native_type -> SHORT .)
    RBRACE          reduce using rule 76 (native_type -> SHORT .)


state 7

    (65) term -> constant .

    TIMES           reduce using rule 65 (term -> constant .)
    DIVIDE          reduce using rule 65 (term -> constant .)
    PLUS            reduce using rule 65 (term -> constant .)
    MINUS           reduce using rule 65 (term -> constant .)
    MOD             reduce using rule 65 (term -> constant .)
    OR              reduce using rule 65 (term -> constant .)
    AND             reduce using rule 65 (term -> constant .)
    LSHIFT          reduce using rule 65 (term -> constant .)
    RSHIFT          reduce using rule 65 (term -> constant .)
    LOGOR           reduce using rule 65 (term -> constant .)
    LOGAND          reduce using rule 65 (term -> constant .)
    LT              reduce using rule 65 (term -> constant .)
    GT              reduce using rule 65 (term -> constant .)
    LE              reduce using rule 65 (term -> constant .)
    GE              reduce using rule 65 (term -> constant .)
    EQ              reduce using rule 65 (term -> constant .)
    NE              reduce using rule 65 (term -> constant .)
    COMMENT         reduce using rule 65 (term -> constant .)
    LBRACE          reduce using rule 65 (term -> constant .)
    FOR             reduce using rule 65 (term -> constant .)
    VOID            reduce using rule 65 (term -> constant .)
    SIZE_T          reduce using rule 65 (term -> constant .)
    UNKNOWN         reduce using rule 65 (term -> constant .)
    CHAR            reduce using rule 65 (term -> constant .)
    SHORT           reduce using rule 65 (term -> constant .)
    INT             reduce using rule 65 (term -> constant .)
    LONG            reduce using rule 65 (term -> constant .)
    FLOAT           reduce using rule 65 (term -> constant .)
    DOUBLE          reduce using rule 65 (term -> constant .)
    SIGNED          reduce using rule 65 (term -> constant .)
    UNSIGNED        reduce using rule 65 (term -> constant .)
    ID              reduce using rule 65 (term -> constant .)
    LOGNOT          reduce using rule 65 (term -> constant .)
    INT_CONST       reduce using rule 65 (term -> constant .)
    FLOAT_CONST     reduce using rule 65 (term -> constant .)
    STRING_LITERAL  reduce using rule 65 (term -> constant .)
    LPAREN          reduce using rule 65 (term -> constant .)
    $end            reduce using rule 65 (term -> constant .)
    RPAREN          reduce using rule 65 (term -> constant .)
    SEMI            reduce using rule 65 (term -> constant .)
    RBRACE          reduce using rule 65 (term -> constant .)
    RBRACKET        reduce using rule 65 (term -> constant .)
    PLUSPLUS        reduce using rule 65 (term -> constant .)
    MINUSMINUS      reduce using rule 65 (term -> constant .)


state 8

    (41) expr -> unary_expression .

    RBRACKET        reduce using rule 41 (expr -> unary_expression .)
    SEMI            reduce using rule 41 (expr -> unary_expression .)
    RBRACE          reduce using rule 41 (expr -> unary_expression .)
    COMMENT         reduce using rule 41 (expr -> unary_expression .)
    LBRACE          reduce using rule 41 (expr -> unary_expression .)
    FOR             reduce using rule 41 (expr -> unary_expression .)
    VOID            reduce using rule 41 (expr -> unary_expression .)
    SIZE_T          reduce using rule 41 (expr -> unary_expression .)
    UNKNOWN         reduce using rule 41 (expr -> unary_expression .)
    CHAR            reduce using rule 41 (expr -> unary_expression .)
    SHORT           reduce using rule 41 (expr -> unary_expression .)
    INT             reduce using rule 41 (expr -> unary_expression .)
    LONG            reduce using rule 41 (expr -> unary_expression .)
    FLOAT           reduce using rule 41 (expr -> unary_expression .)
    DOUBLE          reduce using rule 41 (expr -> unary_expression .)
    SIGNED          reduce using rule 41 (expr -> unary_expression .)
    UNSIGNED        reduce using rule 41 (expr -> unary_expression .)
    ID              reduce using rule 41 (expr -> unary_expression .)
    MINUS           reduce using rule 41 (expr -> unary_expression .)
    LOGNOT          reduce using rule 41 (expr -> unary_expression .)
    INT_CONST       reduce using rule 41 (expr -> unary_expression .)
    FLOAT_CONST     reduce using rule 41 (expr -> unary_expression .)
    STRING_LITERAL  reduce using rule 41 (expr -> unary_expression .)
    LPAREN          reduce using rule 41 (expr -> unary_expression .)
    $end            reduce using rule 41 (expr -> unary_expression .)


state 9

    (74) native_type -> UNKNOWN .

    TIMES           reduce using rule 74 (native_type -> UNKNOWN .)
    ID              reduce using rule 74 (native_type -> UNKNOWN .)
    COMMENT         reduce using rule 74 (native_type -> UNKNOWN .)
    LBRACE          reduce using rule 74 (native_type -> UNKNOWN .)
    FOR             reduce using rule 74 (native_type -> UNKNOWN .)
    VOID            reduce using rule 74 (native_type -> UNKNOWN .)
    SIZE_T          reduce using rule 74 (native_type -> UNKNOWN .)
    UNKNOWN         reduce using rule 74 (native_type -> UNKNOWN .)
    CHAR            reduce using rule 74 (native_type -> UNKNOWN .)
    SHORT           reduce using rule 74 (native_type -> UNKNOWN .)
    INT             reduce using rule 74 (native_type -> UNKNOWN .)
    LONG            reduce using rule 74 (native_type -> UNKNOWN .)
    FLOAT           reduce using rule 74 (native_type -> UNKNOWN .)
    DOUBLE          reduce using rule 74 (native_type -> UNKNOWN .)
    SIGNED          reduce using rule 74 (native_type -> UNKNOWN .)
    UNSIGNED        reduce using rule 74 (native_type -> UNKNOWN .)
    MINUS           reduce using rule 74 (native_type -> UNKNOWN .)
    LOGNOT          reduce using rule 74 (native_type -> UNKNOWN .)
    INT_CONST       reduce using rule 74 (native_type -> UNKNOWN .)
    FLOAT_CONST     reduce using rule 74 (native_type -> UNKNOWN .)
    STRING_LITERAL  reduce using rule 74 (native_type -> UNKNOWN .)
    LPAREN          reduce using rule 74 (native_type -> UNKNOWN .)
    $end            reduce using rule 74 (native_type -> UNKNOWN .)
    RBRACE          reduce using rule 74 (native_type -> UNKNOWN .)


state 10

    (72) native_type -> VOID .

    TIMES           reduce using rule 72 (native_type -> VOID .)
    ID              reduce using rule 72 (native_type -> VOID .)
    COMMENT         reduce using rule 72 (native_type -> VOID .)
    LBRACE          reduce using rule 72 (native_type -> VOID .)
    FOR             reduce using rule 72 (native_type -> VOID .)
    VOID            reduce using rule 72 (native_type -> VOID .)
    SIZE_T          reduce using rule 72 (native_type -> VOID .)
    UNKNOWN         reduce using rule 72 (native_type -> VOID .)
    CHAR            reduce using rule 72 (native_type -> VOID .)
    SHORT           reduce using rule 72 (native_type -> VOID .)
    INT             reduce using rule 72 (native_type -> VOID .)
    LONG            reduce using rule 72 (native_type -> VOID .)
    FLOAT           reduce using rule 72 (native_type -> VOID .)
    DOUBLE          reduce using rule 72 (native_type -> VOID .)
    SIGNED          reduce using rule 72 (native_type -> VOID .)
    UNSIGNED        reduce using rule 72 (native_type -> VOID .)
    MINUS           reduce using rule 72 (native_type -> VOID .)
    LOGNOT          reduce using rule 72 (native_type -> VOID .)
    INT_CONST       reduce using rule 72 (native_type -> VOID .)
    FLOAT_CONST     reduce using rule 72 (native_type -> VOID .)
    STRING_LITERAL  reduce using rule 72 (native_type -> VOID .)
    LPAREN          reduce using rule 72 (native_type -> VOID .)
    $end            reduce using rule 72 (native_type -> VOID .)
    RBRACE          reduce using rule 72 (native_type -> VOID .)


state 11

    (7) beginning_list -> beginning_list compound .

    COMMENT         reduce using rule 7 (beginning_list -> beginning_list compound .)
    LBRACE          reduce using rule 7 (beginning_list -> beginning_list compound .)
    FOR             reduce using rule 7 (beginning_list -> beginning_list compound .)
    VOID            reduce using rule 7 (beginning_list -> beginning_list compound .)
    SIZE_T          reduce using rule 7 (beginning_list -> beginning_list compound .)
    UNKNOWN         reduce using rule 7 (beginning_list -> beginning_list compound .)
    CHAR            reduce using rule 7 (beginning_list -> beginning_list compound .)
    SHORT           reduce using rule 7 (beginning_list -> beginning_list compound .)
    INT             reduce using rule 7 (beginning_list -> beginning_list compound .)
    LONG            reduce using rule 7 (beginning_list -> beginning_list compound .)
    FLOAT           reduce using rule 7 (beginning_list -> beginning_list compound .)
    DOUBLE          reduce using rule 7 (beginning_list -> beginning_list compound .)
    SIGNED          reduce using rule 7 (beginning_list -> beginning_list compound .)
    UNSIGNED        reduce using rule 7 (beginning_list -> beginning_list compound .)
    ID              reduce using rule 7 (beginning_list -> beginning_list compound .)
    MINUS           reduce using rule 7 (beginning_list -> beginning_list compound .)
    LOGNOT          reduce using rule 7 (beginning_list -> beginning_list compound .)
    INT_CONST       reduce using rule 7 (beginning_list -> beginning_list compound .)
    FLOAT_CONST     reduce using rule 7 (beginning_list -> beginning_list compound .)
    STRING_LITERAL  reduce using rule 7 (beginning_list -> beginning_list compound .)
    LPAREN          reduce using rule 7 (beginning_list -> beginning_list compound .)
    $end            reduce using rule 7 (beginning_list -> beginning_list compound .)
    RBRACE          reduce using rule 7 (beginning_list -> beginning_list compound .)


state 12

    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 52
    PLUS            shift and go to state 59
    MINUS           shift and go to state 63
    MOD             shift and go to state 61
    OR              shift and go to state 49
    AND             shift and go to state 48
    LSHIFT          shift and go to state 60
    RSHIFT          shift and go to state 51
    LOGOR           shift and go to state 53
    LOGAND          shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 50
    LE              shift and go to state 58
    GE              shift and go to state 55
    EQ              shift and go to state 62
    NE              shift and go to state 64

    binary_token                   shift and go to state 65

state 13

    (40) binop -> binop_expression .
    (35) binop_paren -> binop_expression .

  ! reduce/reduce conflict for MINUS resolved using rule 35 (binop_paren -> binop_expression .)
    SEMI            reduce using rule 40 (binop -> binop_expression .)
    RBRACKET        reduce using rule 40 (binop -> binop_expression .)
    RBRACE          reduce using rule 40 (binop -> binop_expression .)
    COMMENT         reduce using rule 40 (binop -> binop_expression .)
    LBRACE          reduce using rule 40 (binop -> binop_expression .)
    FOR             reduce using rule 40 (binop -> binop_expression .)
    VOID            reduce using rule 40 (binop -> binop_expression .)
    SIZE_T          reduce using rule 40 (binop -> binop_expression .)
    UNKNOWN         reduce using rule 40 (binop -> binop_expression .)
    CHAR            reduce using rule 40 (binop -> binop_expression .)
    SHORT           reduce using rule 40 (binop -> binop_expression .)
    INT             reduce using rule 40 (binop -> binop_expression .)
    LONG            reduce using rule 40 (binop -> binop_expression .)
    FLOAT           reduce using rule 40 (binop -> binop_expression .)
    DOUBLE          reduce using rule 40 (binop -> binop_expression .)
    SIGNED          reduce using rule 40 (binop -> binop_expression .)
    UNSIGNED        reduce using rule 40 (binop -> binop_expression .)
    ID              reduce using rule 40 (binop -> binop_expression .)
    LOGNOT          reduce using rule 40 (binop -> binop_expression .)
    INT_CONST       reduce using rule 40 (binop -> binop_expression .)
    FLOAT_CONST     reduce using rule 40 (binop -> binop_expression .)
    STRING_LITERAL  reduce using rule 40 (binop -> binop_expression .)
    LPAREN          reduce using rule 40 (binop -> binop_expression .)
    $end            reduce using rule 40 (binop -> binop_expression .)
    TIMES           reduce using rule 35 (binop_paren -> binop_expression .)
    DIVIDE          reduce using rule 35 (binop_paren -> binop_expression .)
    PLUS            reduce using rule 35 (binop_paren -> binop_expression .)
    MINUS           reduce using rule 35 (binop_paren -> binop_expression .)
    MOD             reduce using rule 35 (binop_paren -> binop_expression .)
    OR              reduce using rule 35 (binop_paren -> binop_expression .)
    AND             reduce using rule 35 (binop_paren -> binop_expression .)
    LSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    RSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    LOGOR           reduce using rule 35 (binop_paren -> binop_expression .)
    LOGAND          reduce using rule 35 (binop_paren -> binop_expression .)
    LT              reduce using rule 35 (binop_paren -> binop_expression .)
    GT              reduce using rule 35 (binop_paren -> binop_expression .)
    LE              reduce using rule 35 (binop_paren -> binop_expression .)
    GE              reduce using rule 35 (binop_paren -> binop_expression .)
    EQ              reduce using rule 35 (binop_paren -> binop_expression .)
    NE              reduce using rule 35 (binop_paren -> binop_expression .)

  ! MINUS           [ reduce using rule 40 (binop -> binop_expression .) ]


state 14

    (75) native_type -> CHAR .

    TIMES           reduce using rule 75 (native_type -> CHAR .)
    ID              reduce using rule 75 (native_type -> CHAR .)
    COMMENT         reduce using rule 75 (native_type -> CHAR .)
    LBRACE          reduce using rule 75 (native_type -> CHAR .)
    FOR             reduce using rule 75 (native_type -> CHAR .)
    VOID            reduce using rule 75 (native_type -> CHAR .)
    SIZE_T          reduce using rule 75 (native_type -> CHAR .)
    UNKNOWN         reduce using rule 75 (native_type -> CHAR .)
    CHAR            reduce using rule 75 (native_type -> CHAR .)
    SHORT           reduce using rule 75 (native_type -> CHAR .)
    INT             reduce using rule 75 (native_type -> CHAR .)
    LONG            reduce using rule 75 (native_type -> CHAR .)
    FLOAT           reduce using rule 75 (native_type -> CHAR .)
    DOUBLE          reduce using rule 75 (native_type -> CHAR .)
    SIGNED          reduce using rule 75 (native_type -> CHAR .)
    UNSIGNED        reduce using rule 75 (native_type -> CHAR .)
    MINUS           reduce using rule 75 (native_type -> CHAR .)
    LOGNOT          reduce using rule 75 (native_type -> CHAR .)
    INT_CONST       reduce using rule 75 (native_type -> CHAR .)
    FLOAT_CONST     reduce using rule 75 (native_type -> CHAR .)
    STRING_LITERAL  reduce using rule 75 (native_type -> CHAR .)
    LPAREN          reduce using rule 75 (native_type -> CHAR .)
    $end            reduce using rule 75 (native_type -> CHAR .)
    RBRACE          reduce using rule 75 (native_type -> CHAR .)


state 15

    (29) unary_token_before -> LOGNOT .

    ID              reduce using rule 29 (unary_token_before -> LOGNOT .)
    INT_CONST       reduce using rule 29 (unary_token_before -> LOGNOT .)
    FLOAT_CONST     reduce using rule 29 (unary_token_before -> LOGNOT .)
    STRING_LITERAL  reduce using rule 29 (unary_token_before -> LOGNOT .)


state 16

    (23) assignment_expression -> array_reference . assignment_operator expr
    (66) term -> array_reference .
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    RBRACE          reduce using rule 66 (term -> array_reference .)
    COMMENT         reduce using rule 66 (term -> array_reference .)
    LBRACE          reduce using rule 66 (term -> array_reference .)
    FOR             reduce using rule 66 (term -> array_reference .)
    VOID            reduce using rule 66 (term -> array_reference .)
    SIZE_T          reduce using rule 66 (term -> array_reference .)
    UNKNOWN         reduce using rule 66 (term -> array_reference .)
    CHAR            reduce using rule 66 (term -> array_reference .)
    SHORT           reduce using rule 66 (term -> array_reference .)
    INT             reduce using rule 66 (term -> array_reference .)
    LONG            reduce using rule 66 (term -> array_reference .)
    FLOAT           reduce using rule 66 (term -> array_reference .)
    DOUBLE          reduce using rule 66 (term -> array_reference .)
    SIGNED          reduce using rule 66 (term -> array_reference .)
    UNSIGNED        reduce using rule 66 (term -> array_reference .)
    ID              reduce using rule 66 (term -> array_reference .)
    MINUS           reduce using rule 66 (term -> array_reference .)
    LOGNOT          reduce using rule 66 (term -> array_reference .)
    INT_CONST       reduce using rule 66 (term -> array_reference .)
    FLOAT_CONST     reduce using rule 66 (term -> array_reference .)
    STRING_LITERAL  reduce using rule 66 (term -> array_reference .)
    LPAREN          reduce using rule 66 (term -> array_reference .)
    TIMES           reduce using rule 66 (term -> array_reference .)
    DIVIDE          reduce using rule 66 (term -> array_reference .)
    PLUS            reduce using rule 66 (term -> array_reference .)
    MOD             reduce using rule 66 (term -> array_reference .)
    OR              reduce using rule 66 (term -> array_reference .)
    AND             reduce using rule 66 (term -> array_reference .)
    LSHIFT          reduce using rule 66 (term -> array_reference .)
    RSHIFT          reduce using rule 66 (term -> array_reference .)
    LOGOR           reduce using rule 66 (term -> array_reference .)
    LOGAND          reduce using rule 66 (term -> array_reference .)
    LT              reduce using rule 66 (term -> array_reference .)
    GT              reduce using rule 66 (term -> array_reference .)
    LE              reduce using rule 66 (term -> array_reference .)
    GE              reduce using rule 66 (term -> array_reference .)
    EQ              reduce using rule 66 (term -> array_reference .)
    NE              reduce using rule 66 (term -> array_reference .)
    $end            reduce using rule 66 (term -> array_reference .)
    EQUALS          shift and go to state 66
    PLUSEQUALS      shift and go to state 67
    MINUSEQUALS     shift and go to state 69
    TIMESEQUALS     shift and go to state 70

    assignment_operator            shift and go to state 68

state 17

    (83) type -> native_type .
    (84) type -> native_type . TIMES

    ID              reduce using rule 83 (type -> native_type .)
    RBRACE          reduce using rule 83 (type -> native_type .)
    COMMENT         reduce using rule 83 (type -> native_type .)
    LBRACE          reduce using rule 83 (type -> native_type .)
    FOR             reduce using rule 83 (type -> native_type .)
    VOID            reduce using rule 83 (type -> native_type .)
    SIZE_T          reduce using rule 83 (type -> native_type .)
    UNKNOWN         reduce using rule 83 (type -> native_type .)
    CHAR            reduce using rule 83 (type -> native_type .)
    SHORT           reduce using rule 83 (type -> native_type .)
    INT             reduce using rule 83 (type -> native_type .)
    LONG            reduce using rule 83 (type -> native_type .)
    FLOAT           reduce using rule 83 (type -> native_type .)
    DOUBLE          reduce using rule 83 (type -> native_type .)
    SIGNED          reduce using rule 83 (type -> native_type .)
    UNSIGNED        reduce using rule 83 (type -> native_type .)
    MINUS           reduce using rule 83 (type -> native_type .)
    LOGNOT          reduce using rule 83 (type -> native_type .)
    INT_CONST       reduce using rule 83 (type -> native_type .)
    FLOAT_CONST     reduce using rule 83 (type -> native_type .)
    STRING_LITERAL  reduce using rule 83 (type -> native_type .)
    LPAREN          reduce using rule 83 (type -> native_type .)
    $end            reduce using rule 83 (type -> native_type .)
    TIMES           shift and go to state 71


state 18

    (28) unary_token_before -> MINUS .

    ID              reduce using rule 28 (unary_token_before -> MINUS .)
    INT_CONST       reduce using rule 28 (unary_token_before -> MINUS .)
    FLOAT_CONST     reduce using rule 28 (unary_token_before -> MINUS .)
    STRING_LITERAL  reduce using rule 28 (unary_token_before -> MINUS .)


state 19

    (12) comment -> COMMENT .

    RBRACE          reduce using rule 12 (comment -> COMMENT .)
    COMMENT         reduce using rule 12 (comment -> COMMENT .)
    LBRACE          reduce using rule 12 (comment -> COMMENT .)
    FOR             reduce using rule 12 (comment -> COMMENT .)
    VOID            reduce using rule 12 (comment -> COMMENT .)
    SIZE_T          reduce using rule 12 (comment -> COMMENT .)
    UNKNOWN         reduce using rule 12 (comment -> COMMENT .)
    CHAR            reduce using rule 12 (comment -> COMMENT .)
    SHORT           reduce using rule 12 (comment -> COMMENT .)
    INT             reduce using rule 12 (comment -> COMMENT .)
    LONG            reduce using rule 12 (comment -> COMMENT .)
    FLOAT           reduce using rule 12 (comment -> COMMENT .)
    DOUBLE          reduce using rule 12 (comment -> COMMENT .)
    SIGNED          reduce using rule 12 (comment -> COMMENT .)
    UNSIGNED        reduce using rule 12 (comment -> COMMENT .)
    ID              reduce using rule 12 (comment -> COMMENT .)
    MINUS           reduce using rule 12 (comment -> COMMENT .)
    LOGNOT          reduce using rule 12 (comment -> COMMENT .)
    INT_CONST       reduce using rule 12 (comment -> COMMENT .)
    FLOAT_CONST     reduce using rule 12 (comment -> COMMENT .)
    STRING_LITERAL  reduce using rule 12 (comment -> COMMENT .)
    LPAREN          reduce using rule 12 (comment -> COMMENT .)
    $end            reduce using rule 12 (comment -> COMMENT .)


state 20

    (25) constant -> INT_CONST .

    TIMES           reduce using rule 25 (constant -> INT_CONST .)
    DIVIDE          reduce using rule 25 (constant -> INT_CONST .)
    PLUS            reduce using rule 25 (constant -> INT_CONST .)
    MINUS           reduce using rule 25 (constant -> INT_CONST .)
    MOD             reduce using rule 25 (constant -> INT_CONST .)
    OR              reduce using rule 25 (constant -> INT_CONST .)
    AND             reduce using rule 25 (constant -> INT_CONST .)
    LSHIFT          reduce using rule 25 (constant -> INT_CONST .)
    RSHIFT          reduce using rule 25 (constant -> INT_CONST .)
    LOGOR           reduce using rule 25 (constant -> INT_CONST .)
    LOGAND          reduce using rule 25 (constant -> INT_CONST .)
    LT              reduce using rule 25 (constant -> INT_CONST .)
    GT              reduce using rule 25 (constant -> INT_CONST .)
    LE              reduce using rule 25 (constant -> INT_CONST .)
    GE              reduce using rule 25 (constant -> INT_CONST .)
    EQ              reduce using rule 25 (constant -> INT_CONST .)
    NE              reduce using rule 25 (constant -> INT_CONST .)
    COMMENT         reduce using rule 25 (constant -> INT_CONST .)
    LBRACE          reduce using rule 25 (constant -> INT_CONST .)
    FOR             reduce using rule 25 (constant -> INT_CONST .)
    VOID            reduce using rule 25 (constant -> INT_CONST .)
    SIZE_T          reduce using rule 25 (constant -> INT_CONST .)
    UNKNOWN         reduce using rule 25 (constant -> INT_CONST .)
    CHAR            reduce using rule 25 (constant -> INT_CONST .)
    SHORT           reduce using rule 25 (constant -> INT_CONST .)
    INT             reduce using rule 25 (constant -> INT_CONST .)
    LONG            reduce using rule 25 (constant -> INT_CONST .)
    FLOAT           reduce using rule 25 (constant -> INT_CONST .)
    DOUBLE          reduce using rule 25 (constant -> INT_CONST .)
    SIGNED          reduce using rule 25 (constant -> INT_CONST .)
    UNSIGNED        reduce using rule 25 (constant -> INT_CONST .)
    ID              reduce using rule 25 (constant -> INT_CONST .)
    LOGNOT          reduce using rule 25 (constant -> INT_CONST .)
    INT_CONST       reduce using rule 25 (constant -> INT_CONST .)
    FLOAT_CONST     reduce using rule 25 (constant -> INT_CONST .)
    STRING_LITERAL  reduce using rule 25 (constant -> INT_CONST .)
    LPAREN          reduce using rule 25 (constant -> INT_CONST .)
    $end            reduce using rule 25 (constant -> INT_CONST .)
    RPAREN          reduce using rule 25 (constant -> INT_CONST .)
    SEMI            reduce using rule 25 (constant -> INT_CONST .)
    RBRACE          reduce using rule 25 (constant -> INT_CONST .)
    RBRACKET        reduce using rule 25 (constant -> INT_CONST .)
    PLUSPLUS        reduce using rule 25 (constant -> INT_CONST .)
    MINUSMINUS      reduce using rule 25 (constant -> INT_CONST .)


state 21

    (63) for_loop -> FOR . LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound

    LPAREN          shift and go to state 72


state 22

    (82) native_type -> UNSIGNED .

    TIMES           reduce using rule 82 (native_type -> UNSIGNED .)
    ID              reduce using rule 82 (native_type -> UNSIGNED .)
    COMMENT         reduce using rule 82 (native_type -> UNSIGNED .)
    LBRACE          reduce using rule 82 (native_type -> UNSIGNED .)
    FOR             reduce using rule 82 (native_type -> UNSIGNED .)
    VOID            reduce using rule 82 (native_type -> UNSIGNED .)
    SIZE_T          reduce using rule 82 (native_type -> UNSIGNED .)
    UNKNOWN         reduce using rule 82 (native_type -> UNSIGNED .)
    CHAR            reduce using rule 82 (native_type -> UNSIGNED .)
    SHORT           reduce using rule 82 (native_type -> UNSIGNED .)
    INT             reduce using rule 82 (native_type -> UNSIGNED .)
    LONG            reduce using rule 82 (native_type -> UNSIGNED .)
    FLOAT           reduce using rule 82 (native_type -> UNSIGNED .)
    DOUBLE          reduce using rule 82 (native_type -> UNSIGNED .)
    SIGNED          reduce using rule 82 (native_type -> UNSIGNED .)
    UNSIGNED        reduce using rule 82 (native_type -> UNSIGNED .)
    MINUS           reduce using rule 82 (native_type -> UNSIGNED .)
    LOGNOT          reduce using rule 82 (native_type -> UNSIGNED .)
    INT_CONST       reduce using rule 82 (native_type -> UNSIGNED .)
    FLOAT_CONST     reduce using rule 82 (native_type -> UNSIGNED .)
    STRING_LITERAL  reduce using rule 82 (native_type -> UNSIGNED .)
    LPAREN          reduce using rule 82 (native_type -> UNSIGNED .)
    $end            reduce using rule 82 (native_type -> UNSIGNED .)
    RBRACE          reduce using rule 82 (native_type -> UNSIGNED .)


state 23

    (78) native_type -> LONG .

    TIMES           reduce using rule 78 (native_type -> LONG .)
    ID              reduce using rule 78 (native_type -> LONG .)
    COMMENT         reduce using rule 78 (native_type -> LONG .)
    LBRACE          reduce using rule 78 (native_type -> LONG .)
    FOR             reduce using rule 78 (native_type -> LONG .)
    VOID            reduce using rule 78 (native_type -> LONG .)
    SIZE_T          reduce using rule 78 (native_type -> LONG .)
    UNKNOWN         reduce using rule 78 (native_type -> LONG .)
    CHAR            reduce using rule 78 (native_type -> LONG .)
    SHORT           reduce using rule 78 (native_type -> LONG .)
    INT             reduce using rule 78 (native_type -> LONG .)
    LONG            reduce using rule 78 (native_type -> LONG .)
    FLOAT           reduce using rule 78 (native_type -> LONG .)
    DOUBLE          reduce using rule 78 (native_type -> LONG .)
    SIGNED          reduce using rule 78 (native_type -> LONG .)
    UNSIGNED        reduce using rule 78 (native_type -> LONG .)
    MINUS           reduce using rule 78 (native_type -> LONG .)
    LOGNOT          reduce using rule 78 (native_type -> LONG .)
    INT_CONST       reduce using rule 78 (native_type -> LONG .)
    FLOAT_CONST     reduce using rule 78 (native_type -> LONG .)
    STRING_LITERAL  reduce using rule 78 (native_type -> LONG .)
    LPAREN          reduce using rule 78 (native_type -> LONG .)
    $end            reduce using rule 78 (native_type -> LONG .)
    RBRACE          reduce using rule 78 (native_type -> LONG .)


state 24

    (5) beginning_list -> beginning_list type .
    (71) typeid -> type . identifier
    (85) identifier -> . ID

  ! shift/reduce conflict for ID resolved as shift
    COMMENT         reduce using rule 5 (beginning_list -> beginning_list type .)
    LBRACE          reduce using rule 5 (beginning_list -> beginning_list type .)
    FOR             reduce using rule 5 (beginning_list -> beginning_list type .)
    VOID            reduce using rule 5 (beginning_list -> beginning_list type .)
    SIZE_T          reduce using rule 5 (beginning_list -> beginning_list type .)
    UNKNOWN         reduce using rule 5 (beginning_list -> beginning_list type .)
    CHAR            reduce using rule 5 (beginning_list -> beginning_list type .)
    SHORT           reduce using rule 5 (beginning_list -> beginning_list type .)
    INT             reduce using rule 5 (beginning_list -> beginning_list type .)
    LONG            reduce using rule 5 (beginning_list -> beginning_list type .)
    FLOAT           reduce using rule 5 (beginning_list -> beginning_list type .)
    DOUBLE          reduce using rule 5 (beginning_list -> beginning_list type .)
    SIGNED          reduce using rule 5 (beginning_list -> beginning_list type .)
    UNSIGNED        reduce using rule 5 (beginning_list -> beginning_list type .)
    MINUS           reduce using rule 5 (beginning_list -> beginning_list type .)
    LOGNOT          reduce using rule 5 (beginning_list -> beginning_list type .)
    INT_CONST       reduce using rule 5 (beginning_list -> beginning_list type .)
    FLOAT_CONST     reduce using rule 5 (beginning_list -> beginning_list type .)
    STRING_LITERAL  reduce using rule 5 (beginning_list -> beginning_list type .)
    LPAREN          reduce using rule 5 (beginning_list -> beginning_list type .)
    $end            reduce using rule 5 (beginning_list -> beginning_list type .)
    RBRACE          reduce using rule 5 (beginning_list -> beginning_list type .)
    ID              shift and go to state 31

  ! ID              [ reduce using rule 5 (beginning_list -> beginning_list type .) ]

    identifier                     shift and go to state 73

state 25

    (10) beginning_list -> beginning_list for_loop .

    COMMENT         reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LBRACE          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    FOR             reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    VOID            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    SIZE_T          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    UNKNOWN         reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    CHAR            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    SHORT           reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    INT             reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LONG            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    FLOAT           reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    DOUBLE          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    SIGNED          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    UNSIGNED        reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    ID              reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    MINUS           reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LOGNOT          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    INT_CONST       reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    FLOAT_CONST     reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    STRING_LITERAL  reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    LPAREN          reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    $end            reduce using rule 10 (beginning_list -> beginning_list for_loop .)
    RBRACE          reduce using rule 10 (beginning_list -> beginning_list for_loop .)


state 26

    (24) assignment_expression_semi -> assignment_expression . SEMI

    SEMI            shift and go to state 74


state 27

    (42) expr -> binop .

    RBRACKET        reduce using rule 42 (expr -> binop .)
    SEMI            reduce using rule 42 (expr -> binop .)
    RBRACE          reduce using rule 42 (expr -> binop .)
    COMMENT         reduce using rule 42 (expr -> binop .)
    LBRACE          reduce using rule 42 (expr -> binop .)
    FOR             reduce using rule 42 (expr -> binop .)
    VOID            reduce using rule 42 (expr -> binop .)
    SIZE_T          reduce using rule 42 (expr -> binop .)
    UNKNOWN         reduce using rule 42 (expr -> binop .)
    CHAR            reduce using rule 42 (expr -> binop .)
    SHORT           reduce using rule 42 (expr -> binop .)
    INT             reduce using rule 42 (expr -> binop .)
    LONG            reduce using rule 42 (expr -> binop .)
    FLOAT           reduce using rule 42 (expr -> binop .)
    DOUBLE          reduce using rule 42 (expr -> binop .)
    SIGNED          reduce using rule 42 (expr -> binop .)
    UNSIGNED        reduce using rule 42 (expr -> binop .)
    ID              reduce using rule 42 (expr -> binop .)
    MINUS           reduce using rule 42 (expr -> binop .)
    LOGNOT          reduce using rule 42 (expr -> binop .)
    INT_CONST       reduce using rule 42 (expr -> binop .)
    FLOAT_CONST     reduce using rule 42 (expr -> binop .)
    STRING_LITERAL  reduce using rule 42 (expr -> binop .)
    LPAREN          reduce using rule 42 (expr -> binop .)
    $end            reduce using rule 42 (expr -> binop .)


state 28

    (67) compound -> LBRACE . beginning_list RBRACE
    (3) beginning_list -> . beginning_list comment
    (4) beginning_list -> . beginning_list function_declaration
    (5) beginning_list -> . beginning_list type
    (6) beginning_list -> . beginning_list declaration
    (7) beginning_list -> . beginning_list compound
    (8) beginning_list -> . beginning_list assignment_expression_semi
    (9) beginning_list -> . beginning_list expr
    (10) beginning_list -> . beginning_list for_loop
    (11) beginning_list -> . empty
    (86) empty -> .

    RBRACE          reduce using rule 86 (empty -> .)
    COMMENT         reduce using rule 86 (empty -> .)
    LBRACE          reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    VOID            reduce using rule 86 (empty -> .)
    SIZE_T          reduce using rule 86 (empty -> .)
    UNKNOWN         reduce using rule 86 (empty -> .)
    CHAR            reduce using rule 86 (empty -> .)
    SHORT           reduce using rule 86 (empty -> .)
    INT             reduce using rule 86 (empty -> .)
    LONG            reduce using rule 86 (empty -> .)
    FLOAT           reduce using rule 86 (empty -> .)
    DOUBLE          reduce using rule 86 (empty -> .)
    SIGNED          reduce using rule 86 (empty -> .)
    UNSIGNED        reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    LOGNOT          reduce using rule 86 (empty -> .)
    INT_CONST       reduce using rule 86 (empty -> .)
    FLOAT_CONST     reduce using rule 86 (empty -> .)
    STRING_LITERAL  reduce using rule 86 (empty -> .)
    LPAREN          reduce using rule 86 (empty -> .)

    beginning_list                 shift and go to state 75
    empty                          shift and go to state 76

state 29

    (34) binop_paren -> LPAREN . binop_expression RPAREN
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 77
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 12
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 78
    identifier                     shift and go to state 47

state 30

    (6) beginning_list -> beginning_list declaration .

    COMMENT         reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LBRACE          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    FOR             reduce using rule 6 (beginning_list -> beginning_list declaration .)
    VOID            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    SIZE_T          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    UNKNOWN         reduce using rule 6 (beginning_list -> beginning_list declaration .)
    CHAR            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    SHORT           reduce using rule 6 (beginning_list -> beginning_list declaration .)
    INT             reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LONG            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    FLOAT           reduce using rule 6 (beginning_list -> beginning_list declaration .)
    DOUBLE          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    SIGNED          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    UNSIGNED        reduce using rule 6 (beginning_list -> beginning_list declaration .)
    ID              reduce using rule 6 (beginning_list -> beginning_list declaration .)
    MINUS           reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LOGNOT          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    INT_CONST       reduce using rule 6 (beginning_list -> beginning_list declaration .)
    FLOAT_CONST     reduce using rule 6 (beginning_list -> beginning_list declaration .)
    STRING_LITERAL  reduce using rule 6 (beginning_list -> beginning_list declaration .)
    LPAREN          reduce using rule 6 (beginning_list -> beginning_list declaration .)
    $end            reduce using rule 6 (beginning_list -> beginning_list declaration .)
    RBRACE          reduce using rule 6 (beginning_list -> beginning_list declaration .)


state 31

    (85) identifier -> ID .

    LBRACKET        reduce using rule 85 (identifier -> ID .)
    RBRACKET        reduce using rule 85 (identifier -> ID .)
    TIMES           reduce using rule 85 (identifier -> ID .)
    DIVIDE          reduce using rule 85 (identifier -> ID .)
    PLUS            reduce using rule 85 (identifier -> ID .)
    MINUS           reduce using rule 85 (identifier -> ID .)
    MOD             reduce using rule 85 (identifier -> ID .)
    OR              reduce using rule 85 (identifier -> ID .)
    AND             reduce using rule 85 (identifier -> ID .)
    LSHIFT          reduce using rule 85 (identifier -> ID .)
    RSHIFT          reduce using rule 85 (identifier -> ID .)
    LOGOR           reduce using rule 85 (identifier -> ID .)
    LOGAND          reduce using rule 85 (identifier -> ID .)
    LT              reduce using rule 85 (identifier -> ID .)
    GT              reduce using rule 85 (identifier -> ID .)
    LE              reduce using rule 85 (identifier -> ID .)
    GE              reduce using rule 85 (identifier -> ID .)
    EQ              reduce using rule 85 (identifier -> ID .)
    NE              reduce using rule 85 (identifier -> ID .)
    COMMENT         reduce using rule 85 (identifier -> ID .)
    LBRACE          reduce using rule 85 (identifier -> ID .)
    FOR             reduce using rule 85 (identifier -> ID .)
    VOID            reduce using rule 85 (identifier -> ID .)
    SIZE_T          reduce using rule 85 (identifier -> ID .)
    UNKNOWN         reduce using rule 85 (identifier -> ID .)
    CHAR            reduce using rule 85 (identifier -> ID .)
    SHORT           reduce using rule 85 (identifier -> ID .)
    INT             reduce using rule 85 (identifier -> ID .)
    LONG            reduce using rule 85 (identifier -> ID .)
    FLOAT           reduce using rule 85 (identifier -> ID .)
    DOUBLE          reduce using rule 85 (identifier -> ID .)
    SIGNED          reduce using rule 85 (identifier -> ID .)
    UNSIGNED        reduce using rule 85 (identifier -> ID .)
    ID              reduce using rule 85 (identifier -> ID .)
    LOGNOT          reduce using rule 85 (identifier -> ID .)
    INT_CONST       reduce using rule 85 (identifier -> ID .)
    FLOAT_CONST     reduce using rule 85 (identifier -> ID .)
    STRING_LITERAL  reduce using rule 85 (identifier -> ID .)
    LPAREN          reduce using rule 85 (identifier -> ID .)
    $end            reduce using rule 85 (identifier -> ID .)
    SEMI            reduce using rule 85 (identifier -> ID .)
    RBRACE          reduce using rule 85 (identifier -> ID .)
    EQUALS          reduce using rule 85 (identifier -> ID .)
    PLUSEQUALS      reduce using rule 85 (identifier -> ID .)
    MINUSEQUALS     reduce using rule 85 (identifier -> ID .)
    TIMESEQUALS     reduce using rule 85 (identifier -> ID .)
    RPAREN          reduce using rule 85 (identifier -> ID .)
    PLUSPLUS        reduce using rule 85 (identifier -> ID .)
    MINUSMINUS      reduce using rule 85 (identifier -> ID .)
    COMMA           reduce using rule 85 (identifier -> ID .)


state 32

    (27) constant -> STRING_LITERAL .

    TIMES           reduce using rule 27 (constant -> STRING_LITERAL .)
    DIVIDE          reduce using rule 27 (constant -> STRING_LITERAL .)
    PLUS            reduce using rule 27 (constant -> STRING_LITERAL .)
    MINUS           reduce using rule 27 (constant -> STRING_LITERAL .)
    MOD             reduce using rule 27 (constant -> STRING_LITERAL .)
    OR              reduce using rule 27 (constant -> STRING_LITERAL .)
    AND             reduce using rule 27 (constant -> STRING_LITERAL .)
    LSHIFT          reduce using rule 27 (constant -> STRING_LITERAL .)
    RSHIFT          reduce using rule 27 (constant -> STRING_LITERAL .)
    LOGOR           reduce using rule 27 (constant -> STRING_LITERAL .)
    LOGAND          reduce using rule 27 (constant -> STRING_LITERAL .)
    LT              reduce using rule 27 (constant -> STRING_LITERAL .)
    GT              reduce using rule 27 (constant -> STRING_LITERAL .)
    LE              reduce using rule 27 (constant -> STRING_LITERAL .)
    GE              reduce using rule 27 (constant -> STRING_LITERAL .)
    EQ              reduce using rule 27 (constant -> STRING_LITERAL .)
    NE              reduce using rule 27 (constant -> STRING_LITERAL .)
    COMMENT         reduce using rule 27 (constant -> STRING_LITERAL .)
    LBRACE          reduce using rule 27 (constant -> STRING_LITERAL .)
    FOR             reduce using rule 27 (constant -> STRING_LITERAL .)
    VOID            reduce using rule 27 (constant -> STRING_LITERAL .)
    SIZE_T          reduce using rule 27 (constant -> STRING_LITERAL .)
    UNKNOWN         reduce using rule 27 (constant -> STRING_LITERAL .)
    CHAR            reduce using rule 27 (constant -> STRING_LITERAL .)
    SHORT           reduce using rule 27 (constant -> STRING_LITERAL .)
    INT             reduce using rule 27 (constant -> STRING_LITERAL .)
    LONG            reduce using rule 27 (constant -> STRING_LITERAL .)
    FLOAT           reduce using rule 27 (constant -> STRING_LITERAL .)
    DOUBLE          reduce using rule 27 (constant -> STRING_LITERAL .)
    SIGNED          reduce using rule 27 (constant -> STRING_LITERAL .)
    UNSIGNED        reduce using rule 27 (constant -> STRING_LITERAL .)
    ID              reduce using rule 27 (constant -> STRING_LITERAL .)
    LOGNOT          reduce using rule 27 (constant -> STRING_LITERAL .)
    INT_CONST       reduce using rule 27 (constant -> STRING_LITERAL .)
    FLOAT_CONST     reduce using rule 27 (constant -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 27 (constant -> STRING_LITERAL .)
    LPAREN          reduce using rule 27 (constant -> STRING_LITERAL .)
    $end            reduce using rule 27 (constant -> STRING_LITERAL .)
    RPAREN          reduce using rule 27 (constant -> STRING_LITERAL .)
    SEMI            reduce using rule 27 (constant -> STRING_LITERAL .)
    RBRACE          reduce using rule 27 (constant -> STRING_LITERAL .)
    RBRACKET        reduce using rule 27 (constant -> STRING_LITERAL .)
    PLUSPLUS        reduce using rule 27 (constant -> STRING_LITERAL .)
    MINUSMINUS      reduce using rule 27 (constant -> STRING_LITERAL .)


state 33

    (68) function_declaration -> typeid . arglist SEMI
    (69) function_declaration -> typeid . arglist compound
    (70) declaration -> typeid . SEMI
    (21) assignment_expression -> typeid . assignment_operator expr
    (16) arglist -> . LPAREN arg_params RPAREN
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    SEMI            shift and go to state 79
    LPAREN          shift and go to state 81
    EQUALS          shift and go to state 66
    PLUSEQUALS      shift and go to state 67
    MINUSEQUALS     shift and go to state 69
    TIMESEQUALS     shift and go to state 70

    assignment_operator            shift and go to state 80
    arglist                        shift and go to state 82

state 34

    (43) expr -> term .
    (36) binop_expression -> term .

  ! reduce/reduce conflict for RBRACKET resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for MINUS resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for RBRACE resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for COMMENT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LBRACE resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for FOR resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for VOID resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for SIZE_T resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for UNKNOWN resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for CHAR resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for SHORT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for INT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LONG resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for FLOAT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for SIGNED resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for UNSIGNED resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for ID resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LOGNOT resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for INT_CONST resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for STRING_LITERAL resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for LPAREN resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for SEMI resolved using rule 36 (binop_expression -> term .)
  ! reduce/reduce conflict for $end resolved using rule 36 (binop_expression -> term .)
    RBRACKET        reduce using rule 36 (binop_expression -> term .)
    TIMES           reduce using rule 36 (binop_expression -> term .)
    DIVIDE          reduce using rule 36 (binop_expression -> term .)
    PLUS            reduce using rule 36 (binop_expression -> term .)
    MINUS           reduce using rule 36 (binop_expression -> term .)
    MOD             reduce using rule 36 (binop_expression -> term .)
    OR              reduce using rule 36 (binop_expression -> term .)
    AND             reduce using rule 36 (binop_expression -> term .)
    LSHIFT          reduce using rule 36 (binop_expression -> term .)
    RSHIFT          reduce using rule 36 (binop_expression -> term .)
    LOGOR           reduce using rule 36 (binop_expression -> term .)
    LOGAND          reduce using rule 36 (binop_expression -> term .)
    LT              reduce using rule 36 (binop_expression -> term .)
    GT              reduce using rule 36 (binop_expression -> term .)
    LE              reduce using rule 36 (binop_expression -> term .)
    GE              reduce using rule 36 (binop_expression -> term .)
    EQ              reduce using rule 36 (binop_expression -> term .)
    NE              reduce using rule 36 (binop_expression -> term .)
    RBRACE          reduce using rule 36 (binop_expression -> term .)
    COMMENT         reduce using rule 36 (binop_expression -> term .)
    LBRACE          reduce using rule 36 (binop_expression -> term .)
    FOR             reduce using rule 36 (binop_expression -> term .)
    VOID            reduce using rule 36 (binop_expression -> term .)
    SIZE_T          reduce using rule 36 (binop_expression -> term .)
    UNKNOWN         reduce using rule 36 (binop_expression -> term .)
    CHAR            reduce using rule 36 (binop_expression -> term .)
    SHORT           reduce using rule 36 (binop_expression -> term .)
    INT             reduce using rule 36 (binop_expression -> term .)
    LONG            reduce using rule 36 (binop_expression -> term .)
    FLOAT           reduce using rule 36 (binop_expression -> term .)
    DOUBLE          reduce using rule 36 (binop_expression -> term .)
    SIGNED          reduce using rule 36 (binop_expression -> term .)
    UNSIGNED        reduce using rule 36 (binop_expression -> term .)
    ID              reduce using rule 36 (binop_expression -> term .)
    LOGNOT          reduce using rule 36 (binop_expression -> term .)
    INT_CONST       reduce using rule 36 (binop_expression -> term .)
    FLOAT_CONST     reduce using rule 36 (binop_expression -> term .)
    STRING_LITERAL  reduce using rule 36 (binop_expression -> term .)
    LPAREN          reduce using rule 36 (binop_expression -> term .)
    SEMI            reduce using rule 36 (binop_expression -> term .)
    $end            reduce using rule 36 (binop_expression -> term .)

  ! RBRACKET        [ reduce using rule 43 (expr -> term .) ]
  ! SEMI            [ reduce using rule 43 (expr -> term .) ]
  ! RBRACE          [ reduce using rule 43 (expr -> term .) ]
  ! COMMENT         [ reduce using rule 43 (expr -> term .) ]
  ! LBRACE          [ reduce using rule 43 (expr -> term .) ]
  ! FOR             [ reduce using rule 43 (expr -> term .) ]
  ! VOID            [ reduce using rule 43 (expr -> term .) ]
  ! SIZE_T          [ reduce using rule 43 (expr -> term .) ]
  ! UNKNOWN         [ reduce using rule 43 (expr -> term .) ]
  ! CHAR            [ reduce using rule 43 (expr -> term .) ]
  ! SHORT           [ reduce using rule 43 (expr -> term .) ]
  ! INT             [ reduce using rule 43 (expr -> term .) ]
  ! LONG            [ reduce using rule 43 (expr -> term .) ]
  ! FLOAT           [ reduce using rule 43 (expr -> term .) ]
  ! DOUBLE          [ reduce using rule 43 (expr -> term .) ]
  ! SIGNED          [ reduce using rule 43 (expr -> term .) ]
  ! UNSIGNED        [ reduce using rule 43 (expr -> term .) ]
  ! ID              [ reduce using rule 43 (expr -> term .) ]
  ! MINUS           [ reduce using rule 43 (expr -> term .) ]
  ! LOGNOT          [ reduce using rule 43 (expr -> term .) ]
  ! INT_CONST       [ reduce using rule 43 (expr -> term .) ]
  ! FLOAT_CONST     [ reduce using rule 43 (expr -> term .) ]
  ! STRING_LITERAL  [ reduce using rule 43 (expr -> term .) ]
  ! LPAREN          [ reduce using rule 43 (expr -> term .) ]
  ! $end            [ reduce using rule 43 (expr -> term .) ]


state 35

    (8) beginning_list -> beginning_list assignment_expression_semi .

    COMMENT         reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LBRACE          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    FOR             reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    VOID            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    SIZE_T          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    UNKNOWN         reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    CHAR            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    SHORT           reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    INT             reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LONG            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    FLOAT           reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    DOUBLE          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    SIGNED          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    UNSIGNED        reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    ID              reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    MINUS           reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LOGNOT          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    INT_CONST       reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    FLOAT_CONST     reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    STRING_LITERAL  reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    LPAREN          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    $end            reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)
    RBRACE          reduce using rule 8 (beginning_list -> beginning_list assignment_expression_semi .)


state 36

    (4) beginning_list -> beginning_list function_declaration .

    COMMENT         reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LBRACE          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    FOR             reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    VOID            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    SIZE_T          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    UNKNOWN         reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    CHAR            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    SHORT           reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    INT             reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LONG            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    FLOAT           reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    DOUBLE          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    SIGNED          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    UNSIGNED        reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    ID              reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    MINUS           reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LOGNOT          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    INT_CONST       reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    FLOAT_CONST     reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    STRING_LITERAL  reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    LPAREN          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    $end            reduce using rule 4 (beginning_list -> beginning_list function_declaration .)
    RBRACE          reduce using rule 4 (beginning_list -> beginning_list function_declaration .)


state 37

    (77) native_type -> INT .

    TIMES           reduce using rule 77 (native_type -> INT .)
    ID              reduce using rule 77 (native_type -> INT .)
    COMMENT         reduce using rule 77 (native_type -> INT .)
    LBRACE          reduce using rule 77 (native_type -> INT .)
    FOR             reduce using rule 77 (native_type -> INT .)
    VOID            reduce using rule 77 (native_type -> INT .)
    SIZE_T          reduce using rule 77 (native_type -> INT .)
    UNKNOWN         reduce using rule 77 (native_type -> INT .)
    CHAR            reduce using rule 77 (native_type -> INT .)
    SHORT           reduce using rule 77 (native_type -> INT .)
    INT             reduce using rule 77 (native_type -> INT .)
    LONG            reduce using rule 77 (native_type -> INT .)
    FLOAT           reduce using rule 77 (native_type -> INT .)
    DOUBLE          reduce using rule 77 (native_type -> INT .)
    SIGNED          reduce using rule 77 (native_type -> INT .)
    UNSIGNED        reduce using rule 77 (native_type -> INT .)
    MINUS           reduce using rule 77 (native_type -> INT .)
    LOGNOT          reduce using rule 77 (native_type -> INT .)
    INT_CONST       reduce using rule 77 (native_type -> INT .)
    FLOAT_CONST     reduce using rule 77 (native_type -> INT .)
    STRING_LITERAL  reduce using rule 77 (native_type -> INT .)
    LPAREN          reduce using rule 77 (native_type -> INT .)
    $end            reduce using rule 77 (native_type -> INT .)
    RBRACE          reduce using rule 77 (native_type -> INT .)


state 38

    (9) beginning_list -> beginning_list expr .

    COMMENT         reduce using rule 9 (beginning_list -> beginning_list expr .)
    LBRACE          reduce using rule 9 (beginning_list -> beginning_list expr .)
    FOR             reduce using rule 9 (beginning_list -> beginning_list expr .)
    VOID            reduce using rule 9 (beginning_list -> beginning_list expr .)
    SIZE_T          reduce using rule 9 (beginning_list -> beginning_list expr .)
    UNKNOWN         reduce using rule 9 (beginning_list -> beginning_list expr .)
    CHAR            reduce using rule 9 (beginning_list -> beginning_list expr .)
    SHORT           reduce using rule 9 (beginning_list -> beginning_list expr .)
    INT             reduce using rule 9 (beginning_list -> beginning_list expr .)
    LONG            reduce using rule 9 (beginning_list -> beginning_list expr .)
    FLOAT           reduce using rule 9 (beginning_list -> beginning_list expr .)
    DOUBLE          reduce using rule 9 (beginning_list -> beginning_list expr .)
    SIGNED          reduce using rule 9 (beginning_list -> beginning_list expr .)
    UNSIGNED        reduce using rule 9 (beginning_list -> beginning_list expr .)
    ID              reduce using rule 9 (beginning_list -> beginning_list expr .)
    MINUS           reduce using rule 9 (beginning_list -> beginning_list expr .)
    LOGNOT          reduce using rule 9 (beginning_list -> beginning_list expr .)
    INT_CONST       reduce using rule 9 (beginning_list -> beginning_list expr .)
    FLOAT_CONST     reduce using rule 9 (beginning_list -> beginning_list expr .)
    STRING_LITERAL  reduce using rule 9 (beginning_list -> beginning_list expr .)
    LPAREN          reduce using rule 9 (beginning_list -> beginning_list expr .)
    $end            reduce using rule 9 (beginning_list -> beginning_list expr .)
    RBRACE          reduce using rule 9 (beginning_list -> beginning_list expr .)


state 39

    (79) native_type -> FLOAT .

    TIMES           reduce using rule 79 (native_type -> FLOAT .)
    ID              reduce using rule 79 (native_type -> FLOAT .)
    COMMENT         reduce using rule 79 (native_type -> FLOAT .)
    LBRACE          reduce using rule 79 (native_type -> FLOAT .)
    FOR             reduce using rule 79 (native_type -> FLOAT .)
    VOID            reduce using rule 79 (native_type -> FLOAT .)
    SIZE_T          reduce using rule 79 (native_type -> FLOAT .)
    UNKNOWN         reduce using rule 79 (native_type -> FLOAT .)
    CHAR            reduce using rule 79 (native_type -> FLOAT .)
    SHORT           reduce using rule 79 (native_type -> FLOAT .)
    INT             reduce using rule 79 (native_type -> FLOAT .)
    LONG            reduce using rule 79 (native_type -> FLOAT .)
    FLOAT           reduce using rule 79 (native_type -> FLOAT .)
    DOUBLE          reduce using rule 79 (native_type -> FLOAT .)
    SIGNED          reduce using rule 79 (native_type -> FLOAT .)
    UNSIGNED        reduce using rule 79 (native_type -> FLOAT .)
    MINUS           reduce using rule 79 (native_type -> FLOAT .)
    LOGNOT          reduce using rule 79 (native_type -> FLOAT .)
    INT_CONST       reduce using rule 79 (native_type -> FLOAT .)
    FLOAT_CONST     reduce using rule 79 (native_type -> FLOAT .)
    STRING_LITERAL  reduce using rule 79 (native_type -> FLOAT .)
    LPAREN          reduce using rule 79 (native_type -> FLOAT .)
    $end            reduce using rule 79 (native_type -> FLOAT .)
    RBRACE          reduce using rule 79 (native_type -> FLOAT .)


state 40

    (81) native_type -> SIGNED .

    TIMES           reduce using rule 81 (native_type -> SIGNED .)
    ID              reduce using rule 81 (native_type -> SIGNED .)
    COMMENT         reduce using rule 81 (native_type -> SIGNED .)
    LBRACE          reduce using rule 81 (native_type -> SIGNED .)
    FOR             reduce using rule 81 (native_type -> SIGNED .)
    VOID            reduce using rule 81 (native_type -> SIGNED .)
    SIZE_T          reduce using rule 81 (native_type -> SIGNED .)
    UNKNOWN         reduce using rule 81 (native_type -> SIGNED .)
    CHAR            reduce using rule 81 (native_type -> SIGNED .)
    SHORT           reduce using rule 81 (native_type -> SIGNED .)
    INT             reduce using rule 81 (native_type -> SIGNED .)
    LONG            reduce using rule 81 (native_type -> SIGNED .)
    FLOAT           reduce using rule 81 (native_type -> SIGNED .)
    DOUBLE          reduce using rule 81 (native_type -> SIGNED .)
    SIGNED          reduce using rule 81 (native_type -> SIGNED .)
    UNSIGNED        reduce using rule 81 (native_type -> SIGNED .)
    MINUS           reduce using rule 81 (native_type -> SIGNED .)
    LOGNOT          reduce using rule 81 (native_type -> SIGNED .)
    INT_CONST       reduce using rule 81 (native_type -> SIGNED .)
    FLOAT_CONST     reduce using rule 81 (native_type -> SIGNED .)
    STRING_LITERAL  reduce using rule 81 (native_type -> SIGNED .)
    LPAREN          reduce using rule 81 (native_type -> SIGNED .)
    $end            reduce using rule 81 (native_type -> SIGNED .)
    RBRACE          reduce using rule 81 (native_type -> SIGNED .)


state 41

    (80) native_type -> DOUBLE .

    TIMES           reduce using rule 80 (native_type -> DOUBLE .)
    ID              reduce using rule 80 (native_type -> DOUBLE .)
    COMMENT         reduce using rule 80 (native_type -> DOUBLE .)
    LBRACE          reduce using rule 80 (native_type -> DOUBLE .)
    FOR             reduce using rule 80 (native_type -> DOUBLE .)
    VOID            reduce using rule 80 (native_type -> DOUBLE .)
    SIZE_T          reduce using rule 80 (native_type -> DOUBLE .)
    UNKNOWN         reduce using rule 80 (native_type -> DOUBLE .)
    CHAR            reduce using rule 80 (native_type -> DOUBLE .)
    SHORT           reduce using rule 80 (native_type -> DOUBLE .)
    INT             reduce using rule 80 (native_type -> DOUBLE .)
    LONG            reduce using rule 80 (native_type -> DOUBLE .)
    FLOAT           reduce using rule 80 (native_type -> DOUBLE .)
    DOUBLE          reduce using rule 80 (native_type -> DOUBLE .)
    SIGNED          reduce using rule 80 (native_type -> DOUBLE .)
    UNSIGNED        reduce using rule 80 (native_type -> DOUBLE .)
    MINUS           reduce using rule 80 (native_type -> DOUBLE .)
    LOGNOT          reduce using rule 80 (native_type -> DOUBLE .)
    INT_CONST       reduce using rule 80 (native_type -> DOUBLE .)
    FLOAT_CONST     reduce using rule 80 (native_type -> DOUBLE .)
    STRING_LITERAL  reduce using rule 80 (native_type -> DOUBLE .)
    LPAREN          reduce using rule 80 (native_type -> DOUBLE .)
    $end            reduce using rule 80 (native_type -> DOUBLE .)
    RBRACE          reduce using rule 80 (native_type -> DOUBLE .)


state 42

    (73) native_type -> SIZE_T .

    TIMES           reduce using rule 73 (native_type -> SIZE_T .)
    ID              reduce using rule 73 (native_type -> SIZE_T .)
    COMMENT         reduce using rule 73 (native_type -> SIZE_T .)
    LBRACE          reduce using rule 73 (native_type -> SIZE_T .)
    FOR             reduce using rule 73 (native_type -> SIZE_T .)
    VOID            reduce using rule 73 (native_type -> SIZE_T .)
    SIZE_T          reduce using rule 73 (native_type -> SIZE_T .)
    UNKNOWN         reduce using rule 73 (native_type -> SIZE_T .)
    CHAR            reduce using rule 73 (native_type -> SIZE_T .)
    SHORT           reduce using rule 73 (native_type -> SIZE_T .)
    INT             reduce using rule 73 (native_type -> SIZE_T .)
    LONG            reduce using rule 73 (native_type -> SIZE_T .)
    FLOAT           reduce using rule 73 (native_type -> SIZE_T .)
    DOUBLE          reduce using rule 73 (native_type -> SIZE_T .)
    SIGNED          reduce using rule 73 (native_type -> SIZE_T .)
    UNSIGNED        reduce using rule 73 (native_type -> SIZE_T .)
    MINUS           reduce using rule 73 (native_type -> SIZE_T .)
    LOGNOT          reduce using rule 73 (native_type -> SIZE_T .)
    INT_CONST       reduce using rule 73 (native_type -> SIZE_T .)
    FLOAT_CONST     reduce using rule 73 (native_type -> SIZE_T .)
    STRING_LITERAL  reduce using rule 73 (native_type -> SIZE_T .)
    LPAREN          reduce using rule 73 (native_type -> SIZE_T .)
    $end            reduce using rule 73 (native_type -> SIZE_T .)
    RBRACE          reduce using rule 73 (native_type -> SIZE_T .)


state 43

    (22) assignment_expression -> identifier . assignment_operator expr
    (64) term -> identifier .
    (62) array_reference -> identifier . subscript_list
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    RBRACE          reduce using rule 64 (term -> identifier .)
    COMMENT         reduce using rule 64 (term -> identifier .)
    LBRACE          reduce using rule 64 (term -> identifier .)
    FOR             reduce using rule 64 (term -> identifier .)
    VOID            reduce using rule 64 (term -> identifier .)
    SIZE_T          reduce using rule 64 (term -> identifier .)
    UNKNOWN         reduce using rule 64 (term -> identifier .)
    CHAR            reduce using rule 64 (term -> identifier .)
    SHORT           reduce using rule 64 (term -> identifier .)
    INT             reduce using rule 64 (term -> identifier .)
    LONG            reduce using rule 64 (term -> identifier .)
    FLOAT           reduce using rule 64 (term -> identifier .)
    DOUBLE          reduce using rule 64 (term -> identifier .)
    SIGNED          reduce using rule 64 (term -> identifier .)
    UNSIGNED        reduce using rule 64 (term -> identifier .)
    ID              reduce using rule 64 (term -> identifier .)
    MINUS           reduce using rule 64 (term -> identifier .)
    LOGNOT          reduce using rule 64 (term -> identifier .)
    INT_CONST       reduce using rule 64 (term -> identifier .)
    FLOAT_CONST     reduce using rule 64 (term -> identifier .)
    STRING_LITERAL  reduce using rule 64 (term -> identifier .)
    LPAREN          reduce using rule 64 (term -> identifier .)
    TIMES           reduce using rule 64 (term -> identifier .)
    DIVIDE          reduce using rule 64 (term -> identifier .)
    PLUS            reduce using rule 64 (term -> identifier .)
    MOD             reduce using rule 64 (term -> identifier .)
    OR              reduce using rule 64 (term -> identifier .)
    AND             reduce using rule 64 (term -> identifier .)
    LSHIFT          reduce using rule 64 (term -> identifier .)
    RSHIFT          reduce using rule 64 (term -> identifier .)
    LOGOR           reduce using rule 64 (term -> identifier .)
    LOGAND          reduce using rule 64 (term -> identifier .)
    LT              reduce using rule 64 (term -> identifier .)
    GT              reduce using rule 64 (term -> identifier .)
    LE              reduce using rule 64 (term -> identifier .)
    GE              reduce using rule 64 (term -> identifier .)
    EQ              reduce using rule 64 (term -> identifier .)
    NE              reduce using rule 64 (term -> identifier .)
    $end            reduce using rule 64 (term -> identifier .)
    EQUALS          shift and go to state 66
    PLUSEQUALS      shift and go to state 67
    MINUSEQUALS     shift and go to state 69
    TIMESEQUALS     shift and go to state 70
    LBRACKET        shift and go to state 84

    subscript                      shift and go to state 86
    subscript_list                 shift and go to state 83
    assignment_operator            shift and go to state 85

state 44

    (26) constant -> FLOAT_CONST .

    TIMES           reduce using rule 26 (constant -> FLOAT_CONST .)
    DIVIDE          reduce using rule 26 (constant -> FLOAT_CONST .)
    PLUS            reduce using rule 26 (constant -> FLOAT_CONST .)
    MINUS           reduce using rule 26 (constant -> FLOAT_CONST .)
    MOD             reduce using rule 26 (constant -> FLOAT_CONST .)
    OR              reduce using rule 26 (constant -> FLOAT_CONST .)
    AND             reduce using rule 26 (constant -> FLOAT_CONST .)
    LSHIFT          reduce using rule 26 (constant -> FLOAT_CONST .)
    RSHIFT          reduce using rule 26 (constant -> FLOAT_CONST .)
    LOGOR           reduce using rule 26 (constant -> FLOAT_CONST .)
    LOGAND          reduce using rule 26 (constant -> FLOAT_CONST .)
    LT              reduce using rule 26 (constant -> FLOAT_CONST .)
    GT              reduce using rule 26 (constant -> FLOAT_CONST .)
    LE              reduce using rule 26 (constant -> FLOAT_CONST .)
    GE              reduce using rule 26 (constant -> FLOAT_CONST .)
    EQ              reduce using rule 26 (constant -> FLOAT_CONST .)
    NE              reduce using rule 26 (constant -> FLOAT_CONST .)
    COMMENT         reduce using rule 26 (constant -> FLOAT_CONST .)
    LBRACE          reduce using rule 26 (constant -> FLOAT_CONST .)
    FOR             reduce using rule 26 (constant -> FLOAT_CONST .)
    VOID            reduce using rule 26 (constant -> FLOAT_CONST .)
    SIZE_T          reduce using rule 26 (constant -> FLOAT_CONST .)
    UNKNOWN         reduce using rule 26 (constant -> FLOAT_CONST .)
    CHAR            reduce using rule 26 (constant -> FLOAT_CONST .)
    SHORT           reduce using rule 26 (constant -> FLOAT_CONST .)
    INT             reduce using rule 26 (constant -> FLOAT_CONST .)
    LONG            reduce using rule 26 (constant -> FLOAT_CONST .)
    FLOAT           reduce using rule 26 (constant -> FLOAT_CONST .)
    DOUBLE          reduce using rule 26 (constant -> FLOAT_CONST .)
    SIGNED          reduce using rule 26 (constant -> FLOAT_CONST .)
    UNSIGNED        reduce using rule 26 (constant -> FLOAT_CONST .)
    ID              reduce using rule 26 (constant -> FLOAT_CONST .)
    LOGNOT          reduce using rule 26 (constant -> FLOAT_CONST .)
    INT_CONST       reduce using rule 26 (constant -> FLOAT_CONST .)
    FLOAT_CONST     reduce using rule 26 (constant -> FLOAT_CONST .)
    STRING_LITERAL  reduce using rule 26 (constant -> FLOAT_CONST .)
    LPAREN          reduce using rule 26 (constant -> FLOAT_CONST .)
    $end            reduce using rule 26 (constant -> FLOAT_CONST .)
    RPAREN          reduce using rule 26 (constant -> FLOAT_CONST .)
    SEMI            reduce using rule 26 (constant -> FLOAT_CONST .)
    RBRACE          reduce using rule 26 (constant -> FLOAT_CONST .)
    RBRACKET        reduce using rule 26 (constant -> FLOAT_CONST .)
    PLUSPLUS        reduce using rule 26 (constant -> FLOAT_CONST .)
    MINUSMINUS      reduce using rule 26 (constant -> FLOAT_CONST .)


state 45

    (32) unary_expression -> unary_token_before term .

    SEMI            reduce using rule 32 (unary_expression -> unary_token_before term .)
    RBRACE          reduce using rule 32 (unary_expression -> unary_token_before term .)
    COMMENT         reduce using rule 32 (unary_expression -> unary_token_before term .)
    LBRACE          reduce using rule 32 (unary_expression -> unary_token_before term .)
    FOR             reduce using rule 32 (unary_expression -> unary_token_before term .)
    VOID            reduce using rule 32 (unary_expression -> unary_token_before term .)
    SIZE_T          reduce using rule 32 (unary_expression -> unary_token_before term .)
    UNKNOWN         reduce using rule 32 (unary_expression -> unary_token_before term .)
    CHAR            reduce using rule 32 (unary_expression -> unary_token_before term .)
    SHORT           reduce using rule 32 (unary_expression -> unary_token_before term .)
    INT             reduce using rule 32 (unary_expression -> unary_token_before term .)
    LONG            reduce using rule 32 (unary_expression -> unary_token_before term .)
    FLOAT           reduce using rule 32 (unary_expression -> unary_token_before term .)
    DOUBLE          reduce using rule 32 (unary_expression -> unary_token_before term .)
    SIGNED          reduce using rule 32 (unary_expression -> unary_token_before term .)
    UNSIGNED        reduce using rule 32 (unary_expression -> unary_token_before term .)
    ID              reduce using rule 32 (unary_expression -> unary_token_before term .)
    MINUS           reduce using rule 32 (unary_expression -> unary_token_before term .)
    LOGNOT          reduce using rule 32 (unary_expression -> unary_token_before term .)
    INT_CONST       reduce using rule 32 (unary_expression -> unary_token_before term .)
    FLOAT_CONST     reduce using rule 32 (unary_expression -> unary_token_before term .)
    STRING_LITERAL  reduce using rule 32 (unary_expression -> unary_token_before term .)
    LPAREN          reduce using rule 32 (unary_expression -> unary_token_before term .)
    RBRACKET        reduce using rule 32 (unary_expression -> unary_token_before term .)
    $end            reduce using rule 32 (unary_expression -> unary_token_before term .)


state 46

    (66) term -> array_reference .

    TIMES           reduce using rule 66 (term -> array_reference .)
    DIVIDE          reduce using rule 66 (term -> array_reference .)
    PLUS            reduce using rule 66 (term -> array_reference .)
    MINUS           reduce using rule 66 (term -> array_reference .)
    MOD             reduce using rule 66 (term -> array_reference .)
    OR              reduce using rule 66 (term -> array_reference .)
    AND             reduce using rule 66 (term -> array_reference .)
    LSHIFT          reduce using rule 66 (term -> array_reference .)
    RSHIFT          reduce using rule 66 (term -> array_reference .)
    LOGOR           reduce using rule 66 (term -> array_reference .)
    LOGAND          reduce using rule 66 (term -> array_reference .)
    LT              reduce using rule 66 (term -> array_reference .)
    GT              reduce using rule 66 (term -> array_reference .)
    LE              reduce using rule 66 (term -> array_reference .)
    GE              reduce using rule 66 (term -> array_reference .)
    EQ              reduce using rule 66 (term -> array_reference .)
    NE              reduce using rule 66 (term -> array_reference .)
    COMMENT         reduce using rule 66 (term -> array_reference .)
    LBRACE          reduce using rule 66 (term -> array_reference .)
    FOR             reduce using rule 66 (term -> array_reference .)
    VOID            reduce using rule 66 (term -> array_reference .)
    SIZE_T          reduce using rule 66 (term -> array_reference .)
    UNKNOWN         reduce using rule 66 (term -> array_reference .)
    CHAR            reduce using rule 66 (term -> array_reference .)
    SHORT           reduce using rule 66 (term -> array_reference .)
    INT             reduce using rule 66 (term -> array_reference .)
    LONG            reduce using rule 66 (term -> array_reference .)
    FLOAT           reduce using rule 66 (term -> array_reference .)
    DOUBLE          reduce using rule 66 (term -> array_reference .)
    SIGNED          reduce using rule 66 (term -> array_reference .)
    UNSIGNED        reduce using rule 66 (term -> array_reference .)
    ID              reduce using rule 66 (term -> array_reference .)
    LOGNOT          reduce using rule 66 (term -> array_reference .)
    INT_CONST       reduce using rule 66 (term -> array_reference .)
    FLOAT_CONST     reduce using rule 66 (term -> array_reference .)
    STRING_LITERAL  reduce using rule 66 (term -> array_reference .)
    LPAREN          reduce using rule 66 (term -> array_reference .)
    $end            reduce using rule 66 (term -> array_reference .)
    RPAREN          reduce using rule 66 (term -> array_reference .)
    SEMI            reduce using rule 66 (term -> array_reference .)
    RBRACE          reduce using rule 66 (term -> array_reference .)
    RBRACKET        reduce using rule 66 (term -> array_reference .)
    PLUSPLUS        reduce using rule 66 (term -> array_reference .)
    MINUSMINUS      reduce using rule 66 (term -> array_reference .)


state 47

    (64) term -> identifier .
    (62) array_reference -> identifier . subscript_list
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    TIMES           reduce using rule 64 (term -> identifier .)
    DIVIDE          reduce using rule 64 (term -> identifier .)
    PLUS            reduce using rule 64 (term -> identifier .)
    MINUS           reduce using rule 64 (term -> identifier .)
    MOD             reduce using rule 64 (term -> identifier .)
    OR              reduce using rule 64 (term -> identifier .)
    AND             reduce using rule 64 (term -> identifier .)
    LSHIFT          reduce using rule 64 (term -> identifier .)
    RSHIFT          reduce using rule 64 (term -> identifier .)
    LOGOR           reduce using rule 64 (term -> identifier .)
    LOGAND          reduce using rule 64 (term -> identifier .)
    LT              reduce using rule 64 (term -> identifier .)
    GT              reduce using rule 64 (term -> identifier .)
    LE              reduce using rule 64 (term -> identifier .)
    GE              reduce using rule 64 (term -> identifier .)
    EQ              reduce using rule 64 (term -> identifier .)
    NE              reduce using rule 64 (term -> identifier .)
    COMMENT         reduce using rule 64 (term -> identifier .)
    LBRACE          reduce using rule 64 (term -> identifier .)
    FOR             reduce using rule 64 (term -> identifier .)
    VOID            reduce using rule 64 (term -> identifier .)
    SIZE_T          reduce using rule 64 (term -> identifier .)
    UNKNOWN         reduce using rule 64 (term -> identifier .)
    CHAR            reduce using rule 64 (term -> identifier .)
    SHORT           reduce using rule 64 (term -> identifier .)
    INT             reduce using rule 64 (term -> identifier .)
    LONG            reduce using rule 64 (term -> identifier .)
    FLOAT           reduce using rule 64 (term -> identifier .)
    DOUBLE          reduce using rule 64 (term -> identifier .)
    SIGNED          reduce using rule 64 (term -> identifier .)
    UNSIGNED        reduce using rule 64 (term -> identifier .)
    ID              reduce using rule 64 (term -> identifier .)
    LOGNOT          reduce using rule 64 (term -> identifier .)
    INT_CONST       reduce using rule 64 (term -> identifier .)
    FLOAT_CONST     reduce using rule 64 (term -> identifier .)
    STRING_LITERAL  reduce using rule 64 (term -> identifier .)
    LPAREN          reduce using rule 64 (term -> identifier .)
    $end            reduce using rule 64 (term -> identifier .)
    RPAREN          reduce using rule 64 (term -> identifier .)
    SEMI            reduce using rule 64 (term -> identifier .)
    RBRACE          reduce using rule 64 (term -> identifier .)
    RBRACKET        reduce using rule 64 (term -> identifier .)
    PLUSPLUS        reduce using rule 64 (term -> identifier .)
    MINUSMINUS      reduce using rule 64 (term -> identifier .)
    LBRACKET        shift and go to state 84

    subscript                      shift and go to state 86
    subscript_list                 shift and go to state 83

state 48

    (48) binary_token -> AND .

    LPAREN          reduce using rule 48 (binary_token -> AND .)
    ID              reduce using rule 48 (binary_token -> AND .)
    INT_CONST       reduce using rule 48 (binary_token -> AND .)
    FLOAT_CONST     reduce using rule 48 (binary_token -> AND .)
    STRING_LITERAL  reduce using rule 48 (binary_token -> AND .)


state 49

    (47) binary_token -> OR .

    LPAREN          reduce using rule 47 (binary_token -> OR .)
    ID              reduce using rule 47 (binary_token -> OR .)
    INT_CONST       reduce using rule 47 (binary_token -> OR .)
    FLOAT_CONST     reduce using rule 47 (binary_token -> OR .)
    STRING_LITERAL  reduce using rule 47 (binary_token -> OR .)


state 50

    (54) binary_token -> GT .

    LPAREN          reduce using rule 54 (binary_token -> GT .)
    ID              reduce using rule 54 (binary_token -> GT .)
    INT_CONST       reduce using rule 54 (binary_token -> GT .)
    FLOAT_CONST     reduce using rule 54 (binary_token -> GT .)
    STRING_LITERAL  reduce using rule 54 (binary_token -> GT .)


state 51

    (50) binary_token -> RSHIFT .

    LPAREN          reduce using rule 50 (binary_token -> RSHIFT .)
    ID              reduce using rule 50 (binary_token -> RSHIFT .)
    INT_CONST       reduce using rule 50 (binary_token -> RSHIFT .)
    FLOAT_CONST     reduce using rule 50 (binary_token -> RSHIFT .)
    STRING_LITERAL  reduce using rule 50 (binary_token -> RSHIFT .)


state 52

    (38) binop_expression -> binop_paren DIVIDE . binop_paren
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 77
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 87
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 88
    identifier                     shift and go to state 47

state 53

    (51) binary_token -> LOGOR .

    LPAREN          reduce using rule 51 (binary_token -> LOGOR .)
    ID              reduce using rule 51 (binary_token -> LOGOR .)
    INT_CONST       reduce using rule 51 (binary_token -> LOGOR .)
    FLOAT_CONST     reduce using rule 51 (binary_token -> LOGOR .)
    STRING_LITERAL  reduce using rule 51 (binary_token -> LOGOR .)


state 54

    (52) binary_token -> LOGAND .

    LPAREN          reduce using rule 52 (binary_token -> LOGAND .)
    ID              reduce using rule 52 (binary_token -> LOGAND .)
    INT_CONST       reduce using rule 52 (binary_token -> LOGAND .)
    FLOAT_CONST     reduce using rule 52 (binary_token -> LOGAND .)
    STRING_LITERAL  reduce using rule 52 (binary_token -> LOGAND .)


state 55

    (56) binary_token -> GE .

    LPAREN          reduce using rule 56 (binary_token -> GE .)
    ID              reduce using rule 56 (binary_token -> GE .)
    INT_CONST       reduce using rule 56 (binary_token -> GE .)
    FLOAT_CONST     reduce using rule 56 (binary_token -> GE .)
    STRING_LITERAL  reduce using rule 56 (binary_token -> GE .)


state 56

    (37) binop_expression -> binop_paren TIMES . binop_paren
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 77
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 89
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 88
    identifier                     shift and go to state 47

state 57

    (53) binary_token -> LT .

    LPAREN          reduce using rule 53 (binary_token -> LT .)
    ID              reduce using rule 53 (binary_token -> LT .)
    INT_CONST       reduce using rule 53 (binary_token -> LT .)
    FLOAT_CONST     reduce using rule 53 (binary_token -> LT .)
    STRING_LITERAL  reduce using rule 53 (binary_token -> LT .)


state 58

    (55) binary_token -> LE .

    LPAREN          reduce using rule 55 (binary_token -> LE .)
    ID              reduce using rule 55 (binary_token -> LE .)
    INT_CONST       reduce using rule 55 (binary_token -> LE .)
    FLOAT_CONST     reduce using rule 55 (binary_token -> LE .)
    STRING_LITERAL  reduce using rule 55 (binary_token -> LE .)


state 59

    (44) binary_token -> PLUS .

    LPAREN          reduce using rule 44 (binary_token -> PLUS .)
    ID              reduce using rule 44 (binary_token -> PLUS .)
    INT_CONST       reduce using rule 44 (binary_token -> PLUS .)
    FLOAT_CONST     reduce using rule 44 (binary_token -> PLUS .)
    STRING_LITERAL  reduce using rule 44 (binary_token -> PLUS .)


state 60

    (49) binary_token -> LSHIFT .

    LPAREN          reduce using rule 49 (binary_token -> LSHIFT .)
    ID              reduce using rule 49 (binary_token -> LSHIFT .)
    INT_CONST       reduce using rule 49 (binary_token -> LSHIFT .)
    FLOAT_CONST     reduce using rule 49 (binary_token -> LSHIFT .)
    STRING_LITERAL  reduce using rule 49 (binary_token -> LSHIFT .)


state 61

    (46) binary_token -> MOD .

    LPAREN          reduce using rule 46 (binary_token -> MOD .)
    ID              reduce using rule 46 (binary_token -> MOD .)
    INT_CONST       reduce using rule 46 (binary_token -> MOD .)
    FLOAT_CONST     reduce using rule 46 (binary_token -> MOD .)
    STRING_LITERAL  reduce using rule 46 (binary_token -> MOD .)


state 62

    (57) binary_token -> EQ .

    LPAREN          reduce using rule 57 (binary_token -> EQ .)
    ID              reduce using rule 57 (binary_token -> EQ .)
    INT_CONST       reduce using rule 57 (binary_token -> EQ .)
    FLOAT_CONST     reduce using rule 57 (binary_token -> EQ .)
    STRING_LITERAL  reduce using rule 57 (binary_token -> EQ .)


state 63

    (45) binary_token -> MINUS .

    LPAREN          reduce using rule 45 (binary_token -> MINUS .)
    ID              reduce using rule 45 (binary_token -> MINUS .)
    INT_CONST       reduce using rule 45 (binary_token -> MINUS .)
    FLOAT_CONST     reduce using rule 45 (binary_token -> MINUS .)
    STRING_LITERAL  reduce using rule 45 (binary_token -> MINUS .)


state 64

    (58) binary_token -> NE .

    LPAREN          reduce using rule 58 (binary_token -> NE .)
    ID              reduce using rule 58 (binary_token -> NE .)
    INT_CONST       reduce using rule 58 (binary_token -> NE .)
    FLOAT_CONST     reduce using rule 58 (binary_token -> NE .)
    STRING_LITERAL  reduce using rule 58 (binary_token -> NE .)


state 65

    (39) binop_expression -> binop_paren binary_token . binop_paren
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 77
    constant                       shift and go to state 7
    binop_paren                    shift and go to state 90
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 88
    identifier                     shift and go to state 47

state 66

    (17) assignment_operator -> EQUALS .

    MINUS           reduce using rule 17 (assignment_operator -> EQUALS .)
    LOGNOT          reduce using rule 17 (assignment_operator -> EQUALS .)
    ID              reduce using rule 17 (assignment_operator -> EQUALS .)
    INT_CONST       reduce using rule 17 (assignment_operator -> EQUALS .)
    FLOAT_CONST     reduce using rule 17 (assignment_operator -> EQUALS .)
    STRING_LITERAL  reduce using rule 17 (assignment_operator -> EQUALS .)
    LPAREN          reduce using rule 17 (assignment_operator -> EQUALS .)


state 67

    (18) assignment_operator -> PLUSEQUALS .

    MINUS           reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    LOGNOT          reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    ID              reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    INT_CONST       reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    FLOAT_CONST     reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    STRING_LITERAL  reduce using rule 18 (assignment_operator -> PLUSEQUALS .)
    LPAREN          reduce using rule 18 (assignment_operator -> PLUSEQUALS .)


state 68

    (23) assignment_expression -> array_reference assignment_operator . expr
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 15
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32
    LPAREN          shift and go to state 29

    unary_token_before             shift and go to state 5
    term                           shift and go to state 34
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 27
    expr                           shift and go to state 91
    binop_paren                    shift and go to state 12
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 13
    identifier                     shift and go to state 47

state 69

    (19) assignment_operator -> MINUSEQUALS .

    MINUS           reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    LOGNOT          reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    ID              reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    INT_CONST       reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    FLOAT_CONST     reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    STRING_LITERAL  reduce using rule 19 (assignment_operator -> MINUSEQUALS .)
    LPAREN          reduce using rule 19 (assignment_operator -> MINUSEQUALS .)


state 70

    (20) assignment_operator -> TIMESEQUALS .

    MINUS           reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    LOGNOT          reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    ID              reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    INT_CONST       reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    FLOAT_CONST     reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    STRING_LITERAL  reduce using rule 20 (assignment_operator -> TIMESEQUALS .)
    LPAREN          reduce using rule 20 (assignment_operator -> TIMESEQUALS .)


state 71

    (84) type -> native_type TIMES .

    ID              reduce using rule 84 (type -> native_type TIMES .)
    RBRACE          reduce using rule 84 (type -> native_type TIMES .)
    COMMENT         reduce using rule 84 (type -> native_type TIMES .)
    LBRACE          reduce using rule 84 (type -> native_type TIMES .)
    FOR             reduce using rule 84 (type -> native_type TIMES .)
    VOID            reduce using rule 84 (type -> native_type TIMES .)
    SIZE_T          reduce using rule 84 (type -> native_type TIMES .)
    UNKNOWN         reduce using rule 84 (type -> native_type TIMES .)
    CHAR            reduce using rule 84 (type -> native_type TIMES .)
    SHORT           reduce using rule 84 (type -> native_type TIMES .)
    INT             reduce using rule 84 (type -> native_type TIMES .)
    LONG            reduce using rule 84 (type -> native_type TIMES .)
    FLOAT           reduce using rule 84 (type -> native_type TIMES .)
    DOUBLE          reduce using rule 84 (type -> native_type TIMES .)
    SIGNED          reduce using rule 84 (type -> native_type TIMES .)
    UNSIGNED        reduce using rule 84 (type -> native_type TIMES .)
    MINUS           reduce using rule 84 (type -> native_type TIMES .)
    LOGNOT          reduce using rule 84 (type -> native_type TIMES .)
    INT_CONST       reduce using rule 84 (type -> native_type TIMES .)
    FLOAT_CONST     reduce using rule 84 (type -> native_type TIMES .)
    STRING_LITERAL  reduce using rule 84 (type -> native_type TIMES .)
    LPAREN          reduce using rule 84 (type -> native_type TIMES .)
    $end            reduce using rule 84 (type -> native_type TIMES .)


state 72

    (63) for_loop -> FOR LPAREN . assignment_expression SEMI binop SEMI increment RPAREN compound
    (21) assignment_expression -> . typeid assignment_operator expr
    (22) assignment_expression -> . identifier assignment_operator expr
    (23) assignment_expression -> . array_reference assignment_operator expr
    (71) typeid -> . type identifier
    (85) identifier -> . ID
    (62) array_reference -> . identifier subscript_list
    (83) type -> . native_type
    (84) type -> . native_type TIMES
    (72) native_type -> . VOID
    (73) native_type -> . SIZE_T
    (74) native_type -> . UNKNOWN
    (75) native_type -> . CHAR
    (76) native_type -> . SHORT
    (77) native_type -> . INT
    (78) native_type -> . LONG
    (79) native_type -> . FLOAT
    (80) native_type -> . DOUBLE
    (81) native_type -> . SIGNED
    (82) native_type -> . UNSIGNED

    ID              shift and go to state 31
    VOID            shift and go to state 10
    SIZE_T          shift and go to state 42
    UNKNOWN         shift and go to state 9
    CHAR            shift and go to state 14
    SHORT           shift and go to state 6
    INT             shift and go to state 37
    LONG            shift and go to state 23
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 41
    SIGNED          shift and go to state 40
    UNSIGNED        shift and go to state 22

    typeid                         shift and go to state 95
    assignment_expression          shift and go to state 94
    native_type                    shift and go to state 17
    array_reference                shift and go to state 92
    identifier                     shift and go to state 96
    type                           shift and go to state 93

state 73

    (71) typeid -> type identifier .

    SEMI            reduce using rule 71 (typeid -> type identifier .)
    LPAREN          reduce using rule 71 (typeid -> type identifier .)
    EQUALS          reduce using rule 71 (typeid -> type identifier .)
    PLUSEQUALS      reduce using rule 71 (typeid -> type identifier .)
    MINUSEQUALS     reduce using rule 71 (typeid -> type identifier .)
    TIMESEQUALS     reduce using rule 71 (typeid -> type identifier .)
    COMMA           reduce using rule 71 (typeid -> type identifier .)
    RPAREN          reduce using rule 71 (typeid -> type identifier .)


state 74

    (24) assignment_expression_semi -> assignment_expression SEMI .

    RBRACE          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    COMMENT         reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LBRACE          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    FOR             reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    VOID            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    SIZE_T          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    UNKNOWN         reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    CHAR            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    SHORT           reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    INT             reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LONG            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    FLOAT           reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    DOUBLE          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    SIGNED          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    UNSIGNED        reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    ID              reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    MINUS           reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LOGNOT          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    INT_CONST       reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    FLOAT_CONST     reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    STRING_LITERAL  reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    LPAREN          reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)
    $end            reduce using rule 24 (assignment_expression_semi -> assignment_expression SEMI .)


state 75

    (67) compound -> LBRACE beginning_list . RBRACE
    (3) beginning_list -> beginning_list . comment
    (4) beginning_list -> beginning_list . function_declaration
    (5) beginning_list -> beginning_list . type
    (6) beginning_list -> beginning_list . declaration
    (7) beginning_list -> beginning_list . compound
    (8) beginning_list -> beginning_list . assignment_expression_semi
    (9) beginning_list -> beginning_list . expr
    (10) beginning_list -> beginning_list . for_loop
    (12) comment -> . COMMENT
    (68) function_declaration -> . typeid arglist SEMI
    (69) function_declaration -> . typeid arglist compound
    (83) type -> . native_type
    (84) type -> . native_type TIMES
    (70) declaration -> . typeid SEMI
    (67) compound -> . LBRACE beginning_list RBRACE
    (24) assignment_expression_semi -> . assignment_expression SEMI
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (63) for_loop -> . FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
    (71) typeid -> . type identifier
    (72) native_type -> . VOID
    (73) native_type -> . SIZE_T
    (74) native_type -> . UNKNOWN
    (75) native_type -> . CHAR
    (76) native_type -> . SHORT
    (77) native_type -> . INT
    (78) native_type -> . LONG
    (79) native_type -> . FLOAT
    (80) native_type -> . DOUBLE
    (81) native_type -> . SIGNED
    (82) native_type -> . UNSIGNED
    (21) assignment_expression -> . typeid assignment_operator expr
    (22) assignment_expression -> . identifier assignment_operator expr
    (23) assignment_expression -> . array_reference assignment_operator expr
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (62) array_reference -> . identifier subscript_list
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    RBRACE          shift and go to state 97
    COMMENT         shift and go to state 19
    LBRACE          shift and go to state 28
    FOR             shift and go to state 21
    VOID            shift and go to state 10
    SIZE_T          shift and go to state 42
    UNKNOWN         shift and go to state 9
    CHAR            shift and go to state 14
    SHORT           shift and go to state 6
    INT             shift and go to state 37
    LONG            shift and go to state 23
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 41
    SIGNED          shift and go to state 40
    UNSIGNED        shift and go to state 22
    ID              shift and go to state 31
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 15
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32
    LPAREN          shift and go to state 29

    comment                        shift and go to state 4
    unary_token_before             shift and go to state 5
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    compound                       shift and go to state 11
    binop_paren                    shift and go to state 12
    binop_expression               shift and go to state 13
    native_type                    shift and go to state 17
    array_reference                shift and go to state 16
    type                           shift and go to state 24
    for_loop                       shift and go to state 25
    assignment_expression          shift and go to state 26
    binop                          shift and go to state 27
    declaration                    shift and go to state 30
    typeid                         shift and go to state 33
    term                           shift and go to state 34
    assignment_expression_semi     shift and go to state 35
    function_declaration           shift and go to state 36
    expr                           shift and go to state 38
    identifier                     shift and go to state 43

state 76

    (11) beginning_list -> empty .

    RBRACE          reduce using rule 11 (beginning_list -> empty .)
    COMMENT         reduce using rule 11 (beginning_list -> empty .)
    LBRACE          reduce using rule 11 (beginning_list -> empty .)
    FOR             reduce using rule 11 (beginning_list -> empty .)
    VOID            reduce using rule 11 (beginning_list -> empty .)
    SIZE_T          reduce using rule 11 (beginning_list -> empty .)
    UNKNOWN         reduce using rule 11 (beginning_list -> empty .)
    CHAR            reduce using rule 11 (beginning_list -> empty .)
    SHORT           reduce using rule 11 (beginning_list -> empty .)
    INT             reduce using rule 11 (beginning_list -> empty .)
    LONG            reduce using rule 11 (beginning_list -> empty .)
    FLOAT           reduce using rule 11 (beginning_list -> empty .)
    DOUBLE          reduce using rule 11 (beginning_list -> empty .)
    SIGNED          reduce using rule 11 (beginning_list -> empty .)
    UNSIGNED        reduce using rule 11 (beginning_list -> empty .)
    ID              reduce using rule 11 (beginning_list -> empty .)
    MINUS           reduce using rule 11 (beginning_list -> empty .)
    LOGNOT          reduce using rule 11 (beginning_list -> empty .)
    INT_CONST       reduce using rule 11 (beginning_list -> empty .)
    FLOAT_CONST     reduce using rule 11 (beginning_list -> empty .)
    STRING_LITERAL  reduce using rule 11 (beginning_list -> empty .)
    LPAREN          reduce using rule 11 (beginning_list -> empty .)


state 77

    (36) binop_expression -> term .

    SEMI            reduce using rule 36 (binop_expression -> term .)
    TIMES           reduce using rule 36 (binop_expression -> term .)
    DIVIDE          reduce using rule 36 (binop_expression -> term .)
    PLUS            reduce using rule 36 (binop_expression -> term .)
    MINUS           reduce using rule 36 (binop_expression -> term .)
    MOD             reduce using rule 36 (binop_expression -> term .)
    OR              reduce using rule 36 (binop_expression -> term .)
    AND             reduce using rule 36 (binop_expression -> term .)
    LSHIFT          reduce using rule 36 (binop_expression -> term .)
    RSHIFT          reduce using rule 36 (binop_expression -> term .)
    LOGOR           reduce using rule 36 (binop_expression -> term .)
    LOGAND          reduce using rule 36 (binop_expression -> term .)
    LT              reduce using rule 36 (binop_expression -> term .)
    GT              reduce using rule 36 (binop_expression -> term .)
    LE              reduce using rule 36 (binop_expression -> term .)
    GE              reduce using rule 36 (binop_expression -> term .)
    EQ              reduce using rule 36 (binop_expression -> term .)
    NE              reduce using rule 36 (binop_expression -> term .)
    RPAREN          reduce using rule 36 (binop_expression -> term .)
    COMMENT         reduce using rule 36 (binop_expression -> term .)
    LBRACE          reduce using rule 36 (binop_expression -> term .)
    FOR             reduce using rule 36 (binop_expression -> term .)
    VOID            reduce using rule 36 (binop_expression -> term .)
    SIZE_T          reduce using rule 36 (binop_expression -> term .)
    UNKNOWN         reduce using rule 36 (binop_expression -> term .)
    CHAR            reduce using rule 36 (binop_expression -> term .)
    SHORT           reduce using rule 36 (binop_expression -> term .)
    INT             reduce using rule 36 (binop_expression -> term .)
    LONG            reduce using rule 36 (binop_expression -> term .)
    FLOAT           reduce using rule 36 (binop_expression -> term .)
    DOUBLE          reduce using rule 36 (binop_expression -> term .)
    SIGNED          reduce using rule 36 (binop_expression -> term .)
    UNSIGNED        reduce using rule 36 (binop_expression -> term .)
    ID              reduce using rule 36 (binop_expression -> term .)
    LOGNOT          reduce using rule 36 (binop_expression -> term .)
    INT_CONST       reduce using rule 36 (binop_expression -> term .)
    FLOAT_CONST     reduce using rule 36 (binop_expression -> term .)
    STRING_LITERAL  reduce using rule 36 (binop_expression -> term .)
    LPAREN          reduce using rule 36 (binop_expression -> term .)
    $end            reduce using rule 36 (binop_expression -> term .)
    RBRACE          reduce using rule 36 (binop_expression -> term .)
    RBRACKET        reduce using rule 36 (binop_expression -> term .)


state 78

    (34) binop_paren -> LPAREN binop_expression . RPAREN
    (35) binop_paren -> binop_expression .

    RPAREN          shift and go to state 98
    TIMES           reduce using rule 35 (binop_paren -> binop_expression .)
    DIVIDE          reduce using rule 35 (binop_paren -> binop_expression .)
    PLUS            reduce using rule 35 (binop_paren -> binop_expression .)
    MINUS           reduce using rule 35 (binop_paren -> binop_expression .)
    MOD             reduce using rule 35 (binop_paren -> binop_expression .)
    OR              reduce using rule 35 (binop_paren -> binop_expression .)
    AND             reduce using rule 35 (binop_paren -> binop_expression .)
    LSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    RSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    LOGOR           reduce using rule 35 (binop_paren -> binop_expression .)
    LOGAND          reduce using rule 35 (binop_paren -> binop_expression .)
    LT              reduce using rule 35 (binop_paren -> binop_expression .)
    GT              reduce using rule 35 (binop_paren -> binop_expression .)
    LE              reduce using rule 35 (binop_paren -> binop_expression .)
    GE              reduce using rule 35 (binop_paren -> binop_expression .)
    EQ              reduce using rule 35 (binop_paren -> binop_expression .)
    NE              reduce using rule 35 (binop_paren -> binop_expression .)


state 79

    (70) declaration -> typeid SEMI .

    COMMENT         reduce using rule 70 (declaration -> typeid SEMI .)
    LBRACE          reduce using rule 70 (declaration -> typeid SEMI .)
    FOR             reduce using rule 70 (declaration -> typeid SEMI .)
    VOID            reduce using rule 70 (declaration -> typeid SEMI .)
    SIZE_T          reduce using rule 70 (declaration -> typeid SEMI .)
    UNKNOWN         reduce using rule 70 (declaration -> typeid SEMI .)
    CHAR            reduce using rule 70 (declaration -> typeid SEMI .)
    SHORT           reduce using rule 70 (declaration -> typeid SEMI .)
    INT             reduce using rule 70 (declaration -> typeid SEMI .)
    LONG            reduce using rule 70 (declaration -> typeid SEMI .)
    FLOAT           reduce using rule 70 (declaration -> typeid SEMI .)
    DOUBLE          reduce using rule 70 (declaration -> typeid SEMI .)
    SIGNED          reduce using rule 70 (declaration -> typeid SEMI .)
    UNSIGNED        reduce using rule 70 (declaration -> typeid SEMI .)
    ID              reduce using rule 70 (declaration -> typeid SEMI .)
    MINUS           reduce using rule 70 (declaration -> typeid SEMI .)
    LOGNOT          reduce using rule 70 (declaration -> typeid SEMI .)
    INT_CONST       reduce using rule 70 (declaration -> typeid SEMI .)
    FLOAT_CONST     reduce using rule 70 (declaration -> typeid SEMI .)
    STRING_LITERAL  reduce using rule 70 (declaration -> typeid SEMI .)
    LPAREN          reduce using rule 70 (declaration -> typeid SEMI .)
    $end            reduce using rule 70 (declaration -> typeid SEMI .)
    RBRACE          reduce using rule 70 (declaration -> typeid SEMI .)


state 80

    (21) assignment_expression -> typeid assignment_operator . expr
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 15
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32
    LPAREN          shift and go to state 29

    term                           shift and go to state 34
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 27
    expr                           shift and go to state 99
    binop_paren                    shift and go to state 12
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 13
    identifier                     shift and go to state 47
    unary_token_before             shift and go to state 5

state 81

    (16) arglist -> LPAREN . arg_params RPAREN
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . typeid
    (15) arg_params -> . empty
    (71) typeid -> . type identifier
    (86) empty -> .
    (83) type -> . native_type
    (84) type -> . native_type TIMES
    (72) native_type -> . VOID
    (73) native_type -> . SIZE_T
    (74) native_type -> . UNKNOWN
    (75) native_type -> . CHAR
    (76) native_type -> . SHORT
    (77) native_type -> . INT
    (78) native_type -> . LONG
    (79) native_type -> . FLOAT
    (80) native_type -> . DOUBLE
    (81) native_type -> . SIGNED
    (82) native_type -> . UNSIGNED

    RPAREN          reduce using rule 86 (empty -> .)
    VOID            shift and go to state 10
    SIZE_T          shift and go to state 42
    UNKNOWN         shift and go to state 9
    CHAR            shift and go to state 14
    SHORT           shift and go to state 6
    INT             shift and go to state 37
    LONG            shift and go to state 23
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 41
    SIGNED          shift and go to state 40
    UNSIGNED        shift and go to state 22

    typeid                         shift and go to state 100
    native_type                    shift and go to state 17
    type                           shift and go to state 93
    empty                          shift and go to state 101
    arg_params                     shift and go to state 102

state 82

    (68) function_declaration -> typeid arglist . SEMI
    (69) function_declaration -> typeid arglist . compound
    (67) compound -> . LBRACE beginning_list RBRACE

    SEMI            shift and go to state 103
    LBRACE          shift and go to state 28

    compound                       shift and go to state 104

state 83

    (62) array_reference -> identifier subscript_list .

    SEMI            reduce using rule 62 (array_reference -> identifier subscript_list .)
    TIMES           reduce using rule 62 (array_reference -> identifier subscript_list .)
    DIVIDE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    PLUS            reduce using rule 62 (array_reference -> identifier subscript_list .)
    MINUS           reduce using rule 62 (array_reference -> identifier subscript_list .)
    MOD             reduce using rule 62 (array_reference -> identifier subscript_list .)
    OR              reduce using rule 62 (array_reference -> identifier subscript_list .)
    AND             reduce using rule 62 (array_reference -> identifier subscript_list .)
    LSHIFT          reduce using rule 62 (array_reference -> identifier subscript_list .)
    RSHIFT          reduce using rule 62 (array_reference -> identifier subscript_list .)
    LOGOR           reduce using rule 62 (array_reference -> identifier subscript_list .)
    LOGAND          reduce using rule 62 (array_reference -> identifier subscript_list .)
    LT              reduce using rule 62 (array_reference -> identifier subscript_list .)
    GT              reduce using rule 62 (array_reference -> identifier subscript_list .)
    LE              reduce using rule 62 (array_reference -> identifier subscript_list .)
    GE              reduce using rule 62 (array_reference -> identifier subscript_list .)
    EQ              reduce using rule 62 (array_reference -> identifier subscript_list .)
    NE              reduce using rule 62 (array_reference -> identifier subscript_list .)
    EQUALS          reduce using rule 62 (array_reference -> identifier subscript_list .)
    PLUSEQUALS      reduce using rule 62 (array_reference -> identifier subscript_list .)
    MINUSEQUALS     reduce using rule 62 (array_reference -> identifier subscript_list .)
    TIMESEQUALS     reduce using rule 62 (array_reference -> identifier subscript_list .)
    COMMENT         reduce using rule 62 (array_reference -> identifier subscript_list .)
    LBRACE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    FOR             reduce using rule 62 (array_reference -> identifier subscript_list .)
    VOID            reduce using rule 62 (array_reference -> identifier subscript_list .)
    SIZE_T          reduce using rule 62 (array_reference -> identifier subscript_list .)
    UNKNOWN         reduce using rule 62 (array_reference -> identifier subscript_list .)
    CHAR            reduce using rule 62 (array_reference -> identifier subscript_list .)
    SHORT           reduce using rule 62 (array_reference -> identifier subscript_list .)
    INT             reduce using rule 62 (array_reference -> identifier subscript_list .)
    LONG            reduce using rule 62 (array_reference -> identifier subscript_list .)
    FLOAT           reduce using rule 62 (array_reference -> identifier subscript_list .)
    DOUBLE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    SIGNED          reduce using rule 62 (array_reference -> identifier subscript_list .)
    UNSIGNED        reduce using rule 62 (array_reference -> identifier subscript_list .)
    ID              reduce using rule 62 (array_reference -> identifier subscript_list .)
    LOGNOT          reduce using rule 62 (array_reference -> identifier subscript_list .)
    INT_CONST       reduce using rule 62 (array_reference -> identifier subscript_list .)
    FLOAT_CONST     reduce using rule 62 (array_reference -> identifier subscript_list .)
    STRING_LITERAL  reduce using rule 62 (array_reference -> identifier subscript_list .)
    LPAREN          reduce using rule 62 (array_reference -> identifier subscript_list .)
    $end            reduce using rule 62 (array_reference -> identifier subscript_list .)
    RPAREN          reduce using rule 62 (array_reference -> identifier subscript_list .)
    RBRACE          reduce using rule 62 (array_reference -> identifier subscript_list .)
    RBRACKET        reduce using rule 62 (array_reference -> identifier subscript_list .)
    PLUSPLUS        reduce using rule 62 (array_reference -> identifier subscript_list .)
    MINUSMINUS      reduce using rule 62 (array_reference -> identifier subscript_list .)


state 84

    (59) subscript -> LBRACKET . expr RBRACKET
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 15
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32
    LPAREN          shift and go to state 29

    unary_token_before             shift and go to state 5
    term                           shift and go to state 34
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 27
    expr                           shift and go to state 105
    binop_paren                    shift and go to state 12
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 13
    identifier                     shift and go to state 47

state 85

    (22) assignment_expression -> identifier assignment_operator . expr
    (41) expr -> . unary_expression
    (42) expr -> . binop
    (43) expr -> . term
    (32) unary_expression -> . unary_token_before term
    (40) binop -> . binop_expression
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (28) unary_token_before -> . MINUS
    (29) unary_token_before -> . LOGNOT
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression

    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 15
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32
    LPAREN          shift and go to state 29

    unary_token_before             shift and go to state 5
    term                           shift and go to state 34
    constant                       shift and go to state 7
    unary_expression               shift and go to state 8
    binop                          shift and go to state 27
    expr                           shift and go to state 106
    binop_paren                    shift and go to state 12
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 13
    identifier                     shift and go to state 47

state 86

    (60) subscript_list -> subscript .
    (61) subscript_list -> subscript . subscript_list
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    EQUALS          reduce using rule 60 (subscript_list -> subscript .)
    PLUSEQUALS      reduce using rule 60 (subscript_list -> subscript .)
    MINUSEQUALS     reduce using rule 60 (subscript_list -> subscript .)
    TIMESEQUALS     reduce using rule 60 (subscript_list -> subscript .)
    COMMENT         reduce using rule 60 (subscript_list -> subscript .)
    LBRACE          reduce using rule 60 (subscript_list -> subscript .)
    FOR             reduce using rule 60 (subscript_list -> subscript .)
    VOID            reduce using rule 60 (subscript_list -> subscript .)
    SIZE_T          reduce using rule 60 (subscript_list -> subscript .)
    UNKNOWN         reduce using rule 60 (subscript_list -> subscript .)
    CHAR            reduce using rule 60 (subscript_list -> subscript .)
    SHORT           reduce using rule 60 (subscript_list -> subscript .)
    INT             reduce using rule 60 (subscript_list -> subscript .)
    LONG            reduce using rule 60 (subscript_list -> subscript .)
    FLOAT           reduce using rule 60 (subscript_list -> subscript .)
    DOUBLE          reduce using rule 60 (subscript_list -> subscript .)
    SIGNED          reduce using rule 60 (subscript_list -> subscript .)
    UNSIGNED        reduce using rule 60 (subscript_list -> subscript .)
    ID              reduce using rule 60 (subscript_list -> subscript .)
    MINUS           reduce using rule 60 (subscript_list -> subscript .)
    LOGNOT          reduce using rule 60 (subscript_list -> subscript .)
    INT_CONST       reduce using rule 60 (subscript_list -> subscript .)
    FLOAT_CONST     reduce using rule 60 (subscript_list -> subscript .)
    STRING_LITERAL  reduce using rule 60 (subscript_list -> subscript .)
    LPAREN          reduce using rule 60 (subscript_list -> subscript .)
    $end            reduce using rule 60 (subscript_list -> subscript .)
    TIMES           reduce using rule 60 (subscript_list -> subscript .)
    DIVIDE          reduce using rule 60 (subscript_list -> subscript .)
    PLUS            reduce using rule 60 (subscript_list -> subscript .)
    MOD             reduce using rule 60 (subscript_list -> subscript .)
    OR              reduce using rule 60 (subscript_list -> subscript .)
    AND             reduce using rule 60 (subscript_list -> subscript .)
    LSHIFT          reduce using rule 60 (subscript_list -> subscript .)
    RSHIFT          reduce using rule 60 (subscript_list -> subscript .)
    LOGOR           reduce using rule 60 (subscript_list -> subscript .)
    LOGAND          reduce using rule 60 (subscript_list -> subscript .)
    LT              reduce using rule 60 (subscript_list -> subscript .)
    GT              reduce using rule 60 (subscript_list -> subscript .)
    LE              reduce using rule 60 (subscript_list -> subscript .)
    GE              reduce using rule 60 (subscript_list -> subscript .)
    EQ              reduce using rule 60 (subscript_list -> subscript .)
    NE              reduce using rule 60 (subscript_list -> subscript .)
    RBRACE          reduce using rule 60 (subscript_list -> subscript .)
    SEMI            reduce using rule 60 (subscript_list -> subscript .)
    RBRACKET        reduce using rule 60 (subscript_list -> subscript .)
    RPAREN          reduce using rule 60 (subscript_list -> subscript .)
    PLUSPLUS        reduce using rule 60 (subscript_list -> subscript .)
    MINUSMINUS      reduce using rule 60 (subscript_list -> subscript .)
    LBRACKET        shift and go to state 84

    subscript                      shift and go to state 86
    subscript_list                 shift and go to state 107

state 87

    (38) binop_expression -> binop_paren DIVIDE binop_paren .
    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

    RBRACKET        reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    TIMES           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    DIVIDE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    PLUS            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    MINUS           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    MOD             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    OR              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    AND             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LSHIFT          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RSHIFT          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LOGOR           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LOGAND          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LT              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    GT              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LE              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    GE              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    EQ              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    NE              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SEMI            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RBRACE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    COMMENT         reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LBRACE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    FOR             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    VOID            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SIZE_T          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    UNKNOWN         reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    CHAR            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SHORT           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    INT             reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LONG            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    FLOAT           reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    DOUBLE          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    SIGNED          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    UNSIGNED        reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    ID              reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LOGNOT          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    INT_CONST       reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    FLOAT_CONST     reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    STRING_LITERAL  reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    LPAREN          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    RPAREN          reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)
    $end            reduce using rule 38 (binop_expression -> binop_paren DIVIDE binop_paren .)

  ! TIMES           [ shift and go to state 56 ]
  ! DIVIDE          [ shift and go to state 52 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 63 ]
  ! MOD             [ shift and go to state 61 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 48 ]
  ! LSHIFT          [ shift and go to state 60 ]
  ! RSHIFT          [ shift and go to state 51 ]
  ! LOGOR           [ shift and go to state 53 ]
  ! LOGAND          [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 50 ]
  ! LE              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 64 ]

    binary_token                   shift and go to state 65

state 88

    (35) binop_paren -> binop_expression .

    TIMES           reduce using rule 35 (binop_paren -> binop_expression .)
    DIVIDE          reduce using rule 35 (binop_paren -> binop_expression .)
    PLUS            reduce using rule 35 (binop_paren -> binop_expression .)
    MINUS           reduce using rule 35 (binop_paren -> binop_expression .)
    MOD             reduce using rule 35 (binop_paren -> binop_expression .)
    OR              reduce using rule 35 (binop_paren -> binop_expression .)
    AND             reduce using rule 35 (binop_paren -> binop_expression .)
    LSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    RSHIFT          reduce using rule 35 (binop_paren -> binop_expression .)
    LOGOR           reduce using rule 35 (binop_paren -> binop_expression .)
    LOGAND          reduce using rule 35 (binop_paren -> binop_expression .)
    LT              reduce using rule 35 (binop_paren -> binop_expression .)
    GT              reduce using rule 35 (binop_paren -> binop_expression .)
    LE              reduce using rule 35 (binop_paren -> binop_expression .)
    GE              reduce using rule 35 (binop_paren -> binop_expression .)
    EQ              reduce using rule 35 (binop_paren -> binop_expression .)
    NE              reduce using rule 35 (binop_paren -> binop_expression .)
    COMMENT         reduce using rule 35 (binop_paren -> binop_expression .)
    LBRACE          reduce using rule 35 (binop_paren -> binop_expression .)
    FOR             reduce using rule 35 (binop_paren -> binop_expression .)
    VOID            reduce using rule 35 (binop_paren -> binop_expression .)
    SIZE_T          reduce using rule 35 (binop_paren -> binop_expression .)
    UNKNOWN         reduce using rule 35 (binop_paren -> binop_expression .)
    CHAR            reduce using rule 35 (binop_paren -> binop_expression .)
    SHORT           reduce using rule 35 (binop_paren -> binop_expression .)
    INT             reduce using rule 35 (binop_paren -> binop_expression .)
    LONG            reduce using rule 35 (binop_paren -> binop_expression .)
    FLOAT           reduce using rule 35 (binop_paren -> binop_expression .)
    DOUBLE          reduce using rule 35 (binop_paren -> binop_expression .)
    SIGNED          reduce using rule 35 (binop_paren -> binop_expression .)
    UNSIGNED        reduce using rule 35 (binop_paren -> binop_expression .)
    ID              reduce using rule 35 (binop_paren -> binop_expression .)
    LOGNOT          reduce using rule 35 (binop_paren -> binop_expression .)
    INT_CONST       reduce using rule 35 (binop_paren -> binop_expression .)
    FLOAT_CONST     reduce using rule 35 (binop_paren -> binop_expression .)
    STRING_LITERAL  reduce using rule 35 (binop_paren -> binop_expression .)
    LPAREN          reduce using rule 35 (binop_paren -> binop_expression .)
    $end            reduce using rule 35 (binop_paren -> binop_expression .)
    RPAREN          reduce using rule 35 (binop_paren -> binop_expression .)
    SEMI            reduce using rule 35 (binop_paren -> binop_expression .)
    RBRACE          reduce using rule 35 (binop_paren -> binop_expression .)
    RBRACKET        reduce using rule 35 (binop_paren -> binop_expression .)


state 89

    (37) binop_expression -> binop_paren TIMES binop_paren .
    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

    RBRACKET        reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    TIMES           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    DIVIDE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    PLUS            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    MINUS           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    MOD             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    OR              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    AND             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LSHIFT          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RSHIFT          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LOGOR           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LOGAND          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LT              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    GT              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LE              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    GE              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    EQ              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    NE              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SEMI            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RBRACE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    COMMENT         reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LBRACE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    FOR             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    VOID            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SIZE_T          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    UNKNOWN         reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    CHAR            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SHORT           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    INT             reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LONG            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    FLOAT           reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    DOUBLE          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    SIGNED          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    UNSIGNED        reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    ID              reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LOGNOT          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    INT_CONST       reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    FLOAT_CONST     reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    STRING_LITERAL  reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    LPAREN          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    RPAREN          reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)
    $end            reduce using rule 37 (binop_expression -> binop_paren TIMES binop_paren .)

  ! TIMES           [ shift and go to state 56 ]
  ! DIVIDE          [ shift and go to state 52 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 63 ]
  ! MOD             [ shift and go to state 61 ]
  ! OR              [ shift and go to state 49 ]
  ! AND             [ shift and go to state 48 ]
  ! LSHIFT          [ shift and go to state 60 ]
  ! RSHIFT          [ shift and go to state 51 ]
  ! LOGOR           [ shift and go to state 53 ]
  ! LOGAND          [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 50 ]
  ! LE              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 64 ]

    binary_token                   shift and go to state 65

state 90

    (39) binop_expression -> binop_paren binary_token binop_paren .
    (37) binop_expression -> binop_paren . TIMES binop_paren
    (38) binop_expression -> binop_paren . DIVIDE binop_paren
    (39) binop_expression -> binop_paren . binary_token binop_paren
    (44) binary_token -> . PLUS
    (45) binary_token -> . MINUS
    (46) binary_token -> . MOD
    (47) binary_token -> . OR
    (48) binary_token -> . AND
    (49) binary_token -> . LSHIFT
    (50) binary_token -> . RSHIFT
    (51) binary_token -> . LOGOR
    (52) binary_token -> . LOGAND
    (53) binary_token -> . LT
    (54) binary_token -> . GT
    (55) binary_token -> . LE
    (56) binary_token -> . GE
    (57) binary_token -> . EQ
    (58) binary_token -> . NE

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    RBRACKET        reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SEMI            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    RBRACE          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    COMMENT         reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LBRACE          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    FOR             reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    VOID            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SIZE_T          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    UNKNOWN         reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    CHAR            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SHORT           reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    INT             reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LONG            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    FLOAT           reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    DOUBLE          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    SIGNED          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    UNSIGNED        reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    ID              reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LOGNOT          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    INT_CONST       reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    FLOAT_CONST     reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    STRING_LITERAL  reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    LPAREN          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    RPAREN          reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    $end            reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .)
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 52
    PLUS            shift and go to state 59
    MINUS           shift and go to state 63
    MOD             shift and go to state 61
    OR              shift and go to state 49
    AND             shift and go to state 48
    LSHIFT          shift and go to state 60
    RSHIFT          shift and go to state 51
    LOGOR           shift and go to state 53
    LOGAND          shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 50
    LE              shift and go to state 58
    GE              shift and go to state 55
    EQ              shift and go to state 62
    NE              shift and go to state 64

  ! TIMES           [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! DIVIDE          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! PLUS            [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! MINUS           [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! MOD             [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! OR              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! AND             [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LSHIFT          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! RSHIFT          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LOGOR           [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LOGAND          [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LT              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! GT              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! LE              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! GE              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! EQ              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]
  ! NE              [ reduce using rule 39 (binop_expression -> binop_paren binary_token binop_paren .) ]

    binary_token                   shift and go to state 65

state 91

    (23) assignment_expression -> array_reference assignment_operator expr .

    SEMI            reduce using rule 23 (assignment_expression -> array_reference assignment_operator expr .)


state 92

    (23) assignment_expression -> array_reference . assignment_operator expr
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    EQUALS          shift and go to state 66
    PLUSEQUALS      shift and go to state 67
    MINUSEQUALS     shift and go to state 69
    TIMESEQUALS     shift and go to state 70

    assignment_operator            shift and go to state 68

state 93

    (71) typeid -> type . identifier
    (85) identifier -> . ID

    ID              shift and go to state 31

    identifier                     shift and go to state 73

state 94

    (63) for_loop -> FOR LPAREN assignment_expression . SEMI binop SEMI increment RPAREN compound

    SEMI            shift and go to state 108


state 95

    (21) assignment_expression -> typeid . assignment_operator expr
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS

    EQUALS          shift and go to state 66
    PLUSEQUALS      shift and go to state 67
    MINUSEQUALS     shift and go to state 69
    TIMESEQUALS     shift and go to state 70

    assignment_operator            shift and go to state 80

state 96

    (22) assignment_expression -> identifier . assignment_operator expr
    (62) array_reference -> identifier . subscript_list
    (17) assignment_operator -> . EQUALS
    (18) assignment_operator -> . PLUSEQUALS
    (19) assignment_operator -> . MINUSEQUALS
    (20) assignment_operator -> . TIMESEQUALS
    (60) subscript_list -> . subscript
    (61) subscript_list -> . subscript subscript_list
    (59) subscript -> . LBRACKET expr RBRACKET

    EQUALS          shift and go to state 66
    PLUSEQUALS      shift and go to state 67
    MINUSEQUALS     shift and go to state 69
    TIMESEQUALS     shift and go to state 70
    LBRACKET        shift and go to state 84

    subscript                      shift and go to state 86
    subscript_list                 shift and go to state 83
    assignment_operator            shift and go to state 85

state 97

    (67) compound -> LBRACE beginning_list RBRACE .

    COMMENT         reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LBRACE          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    FOR             reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    VOID            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    SIZE_T          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    UNKNOWN         reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    CHAR            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    SHORT           reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    INT             reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LONG            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    FLOAT           reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    DOUBLE          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    SIGNED          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    UNSIGNED        reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    ID              reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    MINUS           reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LOGNOT          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    INT_CONST       reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    FLOAT_CONST     reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    STRING_LITERAL  reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    LPAREN          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    $end            reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)
    RBRACE          reduce using rule 67 (compound -> LBRACE beginning_list RBRACE .)


state 98

    (34) binop_paren -> LPAREN binop_expression RPAREN .

    TIMES           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    DIVIDE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    PLUS            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    MINUS           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    MOD             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    OR              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    AND             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LSHIFT          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RSHIFT          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LOGOR           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LOGAND          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LT              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    GT              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LE              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    GE              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    EQ              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    NE              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    COMMENT         reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LBRACE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    FOR             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    VOID            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SIZE_T          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    UNKNOWN         reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    CHAR            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SHORT           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    INT             reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LONG            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    FLOAT           reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    DOUBLE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SIGNED          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    UNSIGNED        reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    ID              reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LOGNOT          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    INT_CONST       reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    FLOAT_CONST     reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    STRING_LITERAL  reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    LPAREN          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    $end            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RPAREN          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    SEMI            reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RBRACE          reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)
    RBRACKET        reduce using rule 34 (binop_paren -> LPAREN binop_expression RPAREN .)


state 99

    (21) assignment_expression -> typeid assignment_operator expr .

    SEMI            reduce using rule 21 (assignment_expression -> typeid assignment_operator expr .)


state 100

    (13) arg_params -> typeid . COMMA arg_params
    (14) arg_params -> typeid .

    COMMA           shift and go to state 109
    RPAREN          reduce using rule 14 (arg_params -> typeid .)


state 101

    (15) arg_params -> empty .

    RPAREN          reduce using rule 15 (arg_params -> empty .)


state 102

    (16) arglist -> LPAREN arg_params . RPAREN

    RPAREN          shift and go to state 110


state 103

    (68) function_declaration -> typeid arglist SEMI .

    RBRACE          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    COMMENT         reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LBRACE          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    FOR             reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    VOID            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    SIZE_T          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    UNKNOWN         reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    CHAR            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    SHORT           reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    INT             reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LONG            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    FLOAT           reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    DOUBLE          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    SIGNED          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    UNSIGNED        reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    ID              reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    MINUS           reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LOGNOT          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    INT_CONST       reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    FLOAT_CONST     reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    STRING_LITERAL  reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    LPAREN          reduce using rule 68 (function_declaration -> typeid arglist SEMI .)
    $end            reduce using rule 68 (function_declaration -> typeid arglist SEMI .)


state 104

    (69) function_declaration -> typeid arglist compound .

    RBRACE          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    COMMENT         reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LBRACE          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    FOR             reduce using rule 69 (function_declaration -> typeid arglist compound .)
    VOID            reduce using rule 69 (function_declaration -> typeid arglist compound .)
    SIZE_T          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    UNKNOWN         reduce using rule 69 (function_declaration -> typeid arglist compound .)
    CHAR            reduce using rule 69 (function_declaration -> typeid arglist compound .)
    SHORT           reduce using rule 69 (function_declaration -> typeid arglist compound .)
    INT             reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LONG            reduce using rule 69 (function_declaration -> typeid arglist compound .)
    FLOAT           reduce using rule 69 (function_declaration -> typeid arglist compound .)
    DOUBLE          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    SIGNED          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    UNSIGNED        reduce using rule 69 (function_declaration -> typeid arglist compound .)
    ID              reduce using rule 69 (function_declaration -> typeid arglist compound .)
    MINUS           reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LOGNOT          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    INT_CONST       reduce using rule 69 (function_declaration -> typeid arglist compound .)
    FLOAT_CONST     reduce using rule 69 (function_declaration -> typeid arglist compound .)
    STRING_LITERAL  reduce using rule 69 (function_declaration -> typeid arglist compound .)
    LPAREN          reduce using rule 69 (function_declaration -> typeid arglist compound .)
    $end            reduce using rule 69 (function_declaration -> typeid arglist compound .)


state 105

    (59) subscript -> LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 111


state 106

    (22) assignment_expression -> identifier assignment_operator expr .

    SEMI            reduce using rule 22 (assignment_expression -> identifier assignment_operator expr .)


state 107

    (61) subscript_list -> subscript subscript_list .

    EQUALS          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    PLUSEQUALS      reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MINUSEQUALS     reduce using rule 61 (subscript_list -> subscript subscript_list .)
    TIMESEQUALS     reduce using rule 61 (subscript_list -> subscript subscript_list .)
    COMMENT         reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LBRACE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    FOR             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    VOID            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SIZE_T          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    UNKNOWN         reduce using rule 61 (subscript_list -> subscript subscript_list .)
    CHAR            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SHORT           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    INT             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LONG            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    FLOAT           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    DOUBLE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SIGNED          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    UNSIGNED        reduce using rule 61 (subscript_list -> subscript subscript_list .)
    ID              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MINUS           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LOGNOT          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    INT_CONST       reduce using rule 61 (subscript_list -> subscript subscript_list .)
    FLOAT_CONST     reduce using rule 61 (subscript_list -> subscript subscript_list .)
    STRING_LITERAL  reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LPAREN          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    $end            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    TIMES           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    DIVIDE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    PLUS            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MOD             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    OR              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    AND             reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LSHIFT          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RSHIFT          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LOGOR           reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LOGAND          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LT              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    GT              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    LE              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    GE              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    EQ              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    NE              reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RBRACE          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    SEMI            reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RBRACKET        reduce using rule 61 (subscript_list -> subscript subscript_list .)
    RPAREN          reduce using rule 61 (subscript_list -> subscript subscript_list .)
    PLUSPLUS        reduce using rule 61 (subscript_list -> subscript subscript_list .)
    MINUSMINUS      reduce using rule 61 (subscript_list -> subscript subscript_list .)


state 108

    (63) for_loop -> FOR LPAREN assignment_expression SEMI . binop SEMI increment RPAREN compound
    (40) binop -> . binop_expression
    (36) binop_expression -> . term
    (37) binop_expression -> . binop_paren TIMES binop_paren
    (38) binop_expression -> . binop_paren DIVIDE binop_paren
    (39) binop_expression -> . binop_paren binary_token binop_paren
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (34) binop_paren -> . LPAREN binop_expression RPAREN
    (35) binop_paren -> . binop_expression
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 77
    constant                       shift and go to state 7
    binop                          shift and go to state 112
    binop_paren                    shift and go to state 12
    array_reference                shift and go to state 46
    binop_expression               shift and go to state 13
    identifier                     shift and go to state 47

state 109

    (13) arg_params -> typeid COMMA . arg_params
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . typeid
    (15) arg_params -> . empty
    (71) typeid -> . type identifier
    (86) empty -> .
    (83) type -> . native_type
    (84) type -> . native_type TIMES
    (72) native_type -> . VOID
    (73) native_type -> . SIZE_T
    (74) native_type -> . UNKNOWN
    (75) native_type -> . CHAR
    (76) native_type -> . SHORT
    (77) native_type -> . INT
    (78) native_type -> . LONG
    (79) native_type -> . FLOAT
    (80) native_type -> . DOUBLE
    (81) native_type -> . SIGNED
    (82) native_type -> . UNSIGNED

    RPAREN          reduce using rule 86 (empty -> .)
    VOID            shift and go to state 10
    SIZE_T          shift and go to state 42
    UNKNOWN         shift and go to state 9
    CHAR            shift and go to state 14
    SHORT           shift and go to state 6
    INT             shift and go to state 37
    LONG            shift and go to state 23
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 41
    SIGNED          shift and go to state 40
    UNSIGNED        shift and go to state 22

    typeid                         shift and go to state 100
    native_type                    shift and go to state 17
    type                           shift and go to state 93
    empty                          shift and go to state 101
    arg_params                     shift and go to state 113

state 110

    (16) arglist -> LPAREN arg_params RPAREN .

    SEMI            reduce using rule 16 (arglist -> LPAREN arg_params RPAREN .)
    LBRACE          reduce using rule 16 (arglist -> LPAREN arg_params RPAREN .)


state 111

    (59) subscript -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    COMMENT         reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    FOR             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    VOID            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SIZE_T          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    UNKNOWN         reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    CHAR            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SHORT           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    INT             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LONG            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    FLOAT           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    DOUBLE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SIGNED          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    UNSIGNED        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    ID              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LOGNOT          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    INT_CONST       reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    FLOAT_CONST     reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    STRING_LITERAL  reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    $end            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MOD             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LSHIFT          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    RSHIFT          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LOGOR           reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LOGAND          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    LE              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    GE              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    EQ              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    NE              reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    PLUSPLUS        reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MINUSMINUS      reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    EQUALS          reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    PLUSEQUALS      reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    MINUSEQUALS     reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)
    TIMESEQUALS     reduce using rule 59 (subscript -> LBRACKET expr RBRACKET .)


state 112

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop . SEMI increment RPAREN compound

    SEMI            shift and go to state 114


state 113

    (13) arg_params -> typeid COMMA arg_params .

    RPAREN          reduce using rule 13 (arg_params -> typeid COMMA arg_params .)


state 114

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI . increment RPAREN compound
    (33) increment -> . term unary_token_after
    (64) term -> . identifier
    (65) term -> . constant
    (66) term -> . array_reference
    (85) identifier -> . ID
    (25) constant -> . INT_CONST
    (26) constant -> . FLOAT_CONST
    (27) constant -> . STRING_LITERAL
    (62) array_reference -> . identifier subscript_list

    ID              shift and go to state 31
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 44
    STRING_LITERAL  shift and go to state 32

    term                           shift and go to state 115
    constant                       shift and go to state 7
    array_reference                shift and go to state 46
    increment                      shift and go to state 116
    identifier                     shift and go to state 47

state 115

    (33) increment -> term . unary_token_after
    (30) unary_token_after -> . PLUSPLUS
    (31) unary_token_after -> . MINUSMINUS

    PLUSPLUS        shift and go to state 117
    MINUSMINUS      shift and go to state 118

    unary_token_after              shift and go to state 119

state 116

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment . RPAREN compound

    RPAREN          shift and go to state 120


state 117

    (30) unary_token_after -> PLUSPLUS .

    RPAREN          reduce using rule 30 (unary_token_after -> PLUSPLUS .)


state 118

    (31) unary_token_after -> MINUSMINUS .

    RPAREN          reduce using rule 31 (unary_token_after -> MINUSMINUS .)


state 119

    (33) increment -> term unary_token_after .

    RPAREN          reduce using rule 33 (increment -> term unary_token_after .)


state 120

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN . compound
    (67) compound -> . LBRACE beginning_list RBRACE

    LBRACE          shift and go to state 28

    compound                       shift and go to state 121

state 121

    (63) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .

    RBRACE          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    COMMENT         reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LBRACE          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FOR             reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    VOID            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SIZE_T          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    UNKNOWN         reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    CHAR            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SHORT           reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    INT             reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LONG            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FLOAT           reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    DOUBLE          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SIGNED          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    UNSIGNED        reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    ID              reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    MINUS           reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LOGNOT          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    INT_CONST       reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FLOAT_CONST     reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    STRING_LITERAL  reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LPAREN          reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    $end            reduce using rule 63 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 24 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 90 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MOD in state 90 resolved as shift
WARNING: shift/reduce conflict for OR in state 90 resolved as shift
WARNING: shift/reduce conflict for AND in state 90 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 90 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 90 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 90 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 90 resolved as shift
WARNING: shift/reduce conflict for LT in state 90 resolved as shift
WARNING: shift/reduce conflict for GT in state 90 resolved as shift
WARNING: shift/reduce conflict for LE in state 90 resolved as shift
WARNING: shift/reduce conflict for GE in state 90 resolved as shift
WARNING: shift/reduce conflict for EQ in state 90 resolved as shift
WARNING: shift/reduce conflict for NE in state 90 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (first -> empty)
WARNING: rejected rule (beginning_list -> empty) in state 2
WARNING: reduce/reduce conflict in state 13 resolved using rule (binop_paren -> binop_expression)
WARNING: rejected rule (binop -> binop_expression) in state 13
WARNING: reduce/reduce conflict in state 34 resolved using rule (binop_expression -> term)
WARNING: rejected rule (expr -> term) in state 34
WARNING: Rule (expr -> term) is never reduced
