Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN
    SIZEOF
    COLON
    PERIOD

Grammar

Rule 0     S' -> first
Rule 1     first -> top_level
Rule 2     top_level -> top_level comment
Rule 3     top_level -> top_level function_declaration
Rule 4     top_level -> top_level declaration
Rule 5     top_level -> top_level compound
Rule 6     top_level -> top_level assignment_expression_semi
Rule 7     top_level -> top_level expr
Rule 8     top_level -> top_level for_loop
Rule 9     top_level -> top_level include
Rule 10    top_level -> empty
Rule 11    comment -> COMMENT
Rule 12    arg_params -> term COMMA arg_params
Rule 13    arg_params -> typeid COMMA arg_params
Rule 14    arg_params -> binop
Rule 15    arg_params -> typeid
Rule 16    arg_params -> empty
Rule 17    arglist -> LPAREN arg_params RPAREN
Rule 18    assignment_operator -> EQUALS
Rule 19    assignment_operator -> PLUSEQUALS
Rule 20    assignment_operator -> MINUSEQUALS
Rule 21    assignment_operator -> TIMESEQUALS
Rule 22    assignment_expression -> typeid assignment_operator expr
Rule 23    assignment_expression -> identifier assignment_operator expr
Rule 24    assignment_expression -> array_reference assignment_operator expr
Rule 25    assignment_expression_semi -> assignment_expression SEMI
Rule 26    constant -> INT_CONST
Rule 27    constant -> FLOAT_CONST
Rule 28    constant -> STRING_LITERAL
Rule 29    increment -> term unary_token_after
Rule 30    binop -> LPAREN binop_expression RPAREN
Rule 31    binop -> binop_expression
Rule 32    binop_expression -> term
Rule 33    binop_expression -> binop DIVIDE binop
Rule 34    binop_expression -> binop TIMES binop
Rule 35    binop_expression -> binop PLUS binop
Rule 36    binop_expression -> binop MINUS binop
Rule 37    binop_expression -> binop MOD binop
Rule 38    binop_expression -> binop OR binop
Rule 39    binop_expression -> binop AND binop
Rule 40    binop_expression -> binop LSHIFT binop
Rule 41    binop_expression -> binop RSHIFT binop
Rule 42    binop_expression -> binop LOGOR binop
Rule 43    binop_expression -> binop LOGAND binop
Rule 44    binop_expression -> binop LT binop
Rule 45    binop_expression -> binop GT binop
Rule 46    binop_expression -> binop LE binop
Rule 47    binop_expression -> binop GE binop
Rule 48    binop_expression -> binop EQ binop
Rule 49    binop_expression -> binop NE binop
Rule 50    subscript -> LBRACKET expr RBRACKET
Rule 51    subscript_list -> subscript
Rule 52    subscript_list -> subscript subscript_list
Rule 53    array_reference -> identifier subscript_list
Rule 54    for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
Rule 55    unary_token_before -> MINUS
Rule 56    unary_token_before -> LOGNOT
Rule 57    unary_token_after -> PLUSPLUS
Rule 58    unary_token_after -> MINUSMINUS
Rule 59    unary_expression -> unary_token_before term
Rule 60    term -> identifier
Rule 61    term -> constant
Rule 62    term -> array_reference
Rule 63    term -> function_call
Rule 64    term -> unary_expression
Rule 65    compound -> LBRACE top_level RBRACE
Rule 66    function_call -> identifier arglist
Rule 67    function_declaration -> typeid arglist SEMI
Rule 68    function_declaration -> typeid arglist compound
Rule 69    function_declaration -> function_call SEMI
Rule 70    declaration -> typeid SEMI
Rule 71    declaration -> array_typeid SEMI
Rule 72    typeid -> type identifier
Rule 73    array_typeid -> type identifier subscript_list
Rule 74    native_type -> VOID
Rule 75    native_type -> SIZE_T
Rule 76    native_type -> UNKNOWN
Rule 77    native_type -> CHAR
Rule 78    native_type -> SHORT
Rule 79    native_type -> INT
Rule 80    native_type -> LONG
Rule 81    native_type -> FLOAT
Rule 82    native_type -> DOUBLE
Rule 83    native_type -> SIGNED
Rule 84    native_type -> UNSIGNED
Rule 85    expr -> binop
Rule 86    type -> native_type
Rule 87    type -> native_type TIMES
Rule 88    identifier -> ID
Rule 89    include -> PPHASH INCLUDE STRING_LITERAL
Rule 90    empty -> <empty>

Terminals, with rules where they appear

AND                  : 39
CHAR                 : 77
COLON                : 
COMMA                : 12 13
COMMENT              : 11
DIVIDE               : 33
DOUBLE               : 82
EQ                   : 48
EQUALS               : 18
FLOAT                : 81
FLOAT_CONST          : 27
FOR                  : 54
GE                   : 47
GT                   : 45
ID                   : 88
INCLUDE              : 89
INT                  : 79
INT_CONST            : 26
LBRACE               : 65
LBRACKET             : 50
LE                   : 46
LOGAND               : 43
LOGNOT               : 56
LOGOR                : 42
LONG                 : 80
LPAREN               : 17 30 54
LSHIFT               : 40
LT                   : 44
MINUS                : 36 55
MINUSEQUALS          : 20
MINUSMINUS           : 58
MOD                  : 37
NE                   : 49
OR                   : 38
PERIOD               : 
PLUS                 : 35
PLUSEQUALS           : 19
PLUSPLUS             : 57
PPHASH               : 89
RBRACE               : 65
RBRACKET             : 50
RETURN               : 
RPAREN               : 17 30 54
RSHIFT               : 41
SEMI                 : 25 54 54 67 69 70 71
SHORT                : 78
SIGNED               : 83
SIZEOF               : 
SIZE_T               : 75
STRING_LITERAL       : 28 89
TIMES                : 34 87
TIMESEQUALS          : 21
UNKNOWN              : 76
UNSIGNED             : 84
VOID                 : 74
error                : 

Nonterminals, with rules where they appear

arg_params           : 12 13 17
arglist              : 66 67 68
array_reference      : 24 62
array_typeid         : 71
assignment_expression : 25 54
assignment_expression_semi : 6
assignment_operator  : 22 23 24
binop                : 14 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 54 85
binop_expression     : 30 31
comment              : 2
compound             : 5 54 68
constant             : 61
declaration          : 4
empty                : 10 16
expr                 : 7 22 23 24 50
first                : 0
for_loop             : 8
function_call        : 63 69
function_declaration : 3
identifier           : 23 53 60 66 72 73
include              : 9
increment            : 54
native_type          : 86 87
subscript            : 51 52
subscript_list       : 52 53 73
term                 : 12 29 32 59
top_level            : 1 2 3 4 5 6 7 8 9 65
type                 : 72 73
typeid               : 13 15 22 67 68 70
unary_expression     : 64
unary_token_after    : 29
unary_token_before   : 59

Parsing method: LALR

state 0

    (0) S' -> . first
    (1) first -> . top_level
    (2) top_level -> . top_level comment
    (3) top_level -> . top_level function_declaration
    (4) top_level -> . top_level declaration
    (5) top_level -> . top_level compound
    (6) top_level -> . top_level assignment_expression_semi
    (7) top_level -> . top_level expr
    (8) top_level -> . top_level for_loop
    (9) top_level -> . top_level include
    (10) top_level -> . empty
    (90) empty -> .

    COMMENT         reduce using rule 90 (empty -> .)
    LBRACE          reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    PPHASH          reduce using rule 90 (empty -> .)
    LPAREN          reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    VOID            reduce using rule 90 (empty -> .)
    SIZE_T          reduce using rule 90 (empty -> .)
    UNKNOWN         reduce using rule 90 (empty -> .)
    CHAR            reduce using rule 90 (empty -> .)
    SHORT           reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    LONG            reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    DOUBLE          reduce using rule 90 (empty -> .)
    SIGNED          reduce using rule 90 (empty -> .)
    UNSIGNED        reduce using rule 90 (empty -> .)
    INT_CONST       reduce using rule 90 (empty -> .)
    FLOAT_CONST     reduce using rule 90 (empty -> .)
    STRING_LITERAL  reduce using rule 90 (empty -> .)
    MINUS           reduce using rule 90 (empty -> .)
    LOGNOT          reduce using rule 90 (empty -> .)
    $end            reduce using rule 90 (empty -> .)

    top_level                      shift and go to state 1
    empty                          shift and go to state 2
    first                          shift and go to state 3

state 1

    (1) first -> top_level .
    (2) top_level -> top_level . comment
    (3) top_level -> top_level . function_declaration
    (4) top_level -> top_level . declaration
    (5) top_level -> top_level . compound
    (6) top_level -> top_level . assignment_expression_semi
    (7) top_level -> top_level . expr
    (8) top_level -> top_level . for_loop
    (9) top_level -> top_level . include
    (11) comment -> . COMMENT
    (67) function_declaration -> . typeid arglist SEMI
    (68) function_declaration -> . typeid arglist compound
    (69) function_declaration -> . function_call SEMI
    (70) declaration -> . typeid SEMI
    (71) declaration -> . array_typeid SEMI
    (65) compound -> . LBRACE top_level RBRACE
    (25) assignment_expression_semi -> . assignment_expression SEMI
    (85) expr -> . binop
    (54) for_loop -> . FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
    (89) include -> . PPHASH INCLUDE STRING_LITERAL
    (72) typeid -> . type identifier
    (66) function_call -> . identifier arglist
    (73) array_typeid -> . type identifier subscript_list
    (22) assignment_expression -> . typeid assignment_operator expr
    (23) assignment_expression -> . identifier assignment_operator expr
    (24) assignment_expression -> . array_reference assignment_operator expr
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (86) type -> . native_type
    (87) type -> . native_type TIMES
    (88) identifier -> . ID
    (53) array_reference -> . identifier subscript_list
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (74) native_type -> . VOID
    (75) native_type -> . SIZE_T
    (76) native_type -> . UNKNOWN
    (77) native_type -> . CHAR
    (78) native_type -> . SHORT
    (79) native_type -> . INT
    (80) native_type -> . LONG
    (81) native_type -> . FLOAT
    (82) native_type -> . DOUBLE
    (83) native_type -> . SIGNED
    (84) native_type -> . UNSIGNED
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    $end            reduce using rule 1 (first -> top_level .)
    COMMENT         shift and go to state 19
    LBRACE          shift and go to state 29
    FOR             shift and go to state 27
    PPHASH          shift and go to state 38
    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    VOID            shift and go to state 9
    SIZE_T          shift and go to state 46
    UNKNOWN         shift and go to state 8
    CHAR            shift and go to state 13
    SHORT           shift and go to state 5
    INT             shift and go to state 39
    LONG            shift and go to state 15
    FLOAT           shift and go to state 41
    DOUBLE          shift and go to state 45
    SIGNED          shift and go to state 42
    UNSIGNED        shift and go to state 43
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    comment                        shift and go to state 4
    unary_token_before             shift and go to state 7
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    compound                       shift and go to state 10
    function_call                  shift and go to state 11
    binop_expression               shift and go to state 12
    native_type                    shift and go to state 16
    array_reference                shift and go to state 22
    include                        shift and go to state 23
    type                           shift and go to state 24
    array_typeid                   shift and go to state 44
    for_loop                       shift and go to state 25
    assignment_expression          shift and go to state 26
    binop                          shift and go to state 28
    declaration                    shift and go to state 31
    typeid                         shift and go to state 34
    term                           shift and go to state 35
    assignment_expression_semi     shift and go to state 36
    function_declaration           shift and go to state 37
    expr                           shift and go to state 40
    identifier                     shift and go to state 47

state 2

    (10) top_level -> empty .

    COMMENT         reduce using rule 10 (top_level -> empty .)
    LBRACE          reduce using rule 10 (top_level -> empty .)
    FOR             reduce using rule 10 (top_level -> empty .)
    PPHASH          reduce using rule 10 (top_level -> empty .)
    LPAREN          reduce using rule 10 (top_level -> empty .)
    ID              reduce using rule 10 (top_level -> empty .)
    VOID            reduce using rule 10 (top_level -> empty .)
    SIZE_T          reduce using rule 10 (top_level -> empty .)
    UNKNOWN         reduce using rule 10 (top_level -> empty .)
    CHAR            reduce using rule 10 (top_level -> empty .)
    SHORT           reduce using rule 10 (top_level -> empty .)
    INT             reduce using rule 10 (top_level -> empty .)
    LONG            reduce using rule 10 (top_level -> empty .)
    FLOAT           reduce using rule 10 (top_level -> empty .)
    DOUBLE          reduce using rule 10 (top_level -> empty .)
    SIGNED          reduce using rule 10 (top_level -> empty .)
    UNSIGNED        reduce using rule 10 (top_level -> empty .)
    INT_CONST       reduce using rule 10 (top_level -> empty .)
    FLOAT_CONST     reduce using rule 10 (top_level -> empty .)
    STRING_LITERAL  reduce using rule 10 (top_level -> empty .)
    MINUS           reduce using rule 10 (top_level -> empty .)
    LOGNOT          reduce using rule 10 (top_level -> empty .)
    $end            reduce using rule 10 (top_level -> empty .)
    RBRACE          reduce using rule 10 (top_level -> empty .)


state 3

    (0) S' -> first .



state 4

    (2) top_level -> top_level comment .

    COMMENT         reduce using rule 2 (top_level -> top_level comment .)
    LBRACE          reduce using rule 2 (top_level -> top_level comment .)
    FOR             reduce using rule 2 (top_level -> top_level comment .)
    PPHASH          reduce using rule 2 (top_level -> top_level comment .)
    LPAREN          reduce using rule 2 (top_level -> top_level comment .)
    ID              reduce using rule 2 (top_level -> top_level comment .)
    VOID            reduce using rule 2 (top_level -> top_level comment .)
    SIZE_T          reduce using rule 2 (top_level -> top_level comment .)
    UNKNOWN         reduce using rule 2 (top_level -> top_level comment .)
    CHAR            reduce using rule 2 (top_level -> top_level comment .)
    SHORT           reduce using rule 2 (top_level -> top_level comment .)
    INT             reduce using rule 2 (top_level -> top_level comment .)
    LONG            reduce using rule 2 (top_level -> top_level comment .)
    FLOAT           reduce using rule 2 (top_level -> top_level comment .)
    DOUBLE          reduce using rule 2 (top_level -> top_level comment .)
    SIGNED          reduce using rule 2 (top_level -> top_level comment .)
    UNSIGNED        reduce using rule 2 (top_level -> top_level comment .)
    INT_CONST       reduce using rule 2 (top_level -> top_level comment .)
    FLOAT_CONST     reduce using rule 2 (top_level -> top_level comment .)
    STRING_LITERAL  reduce using rule 2 (top_level -> top_level comment .)
    MINUS           reduce using rule 2 (top_level -> top_level comment .)
    LOGNOT          reduce using rule 2 (top_level -> top_level comment .)
    $end            reduce using rule 2 (top_level -> top_level comment .)
    RBRACE          reduce using rule 2 (top_level -> top_level comment .)


state 5

    (78) native_type -> SHORT .

    TIMES           reduce using rule 78 (native_type -> SHORT .)
    ID              reduce using rule 78 (native_type -> SHORT .)


state 6

    (64) term -> unary_expression .

    DIVIDE          reduce using rule 64 (term -> unary_expression .)
    TIMES           reduce using rule 64 (term -> unary_expression .)
    PLUS            reduce using rule 64 (term -> unary_expression .)
    MINUS           reduce using rule 64 (term -> unary_expression .)
    MOD             reduce using rule 64 (term -> unary_expression .)
    OR              reduce using rule 64 (term -> unary_expression .)
    AND             reduce using rule 64 (term -> unary_expression .)
    LSHIFT          reduce using rule 64 (term -> unary_expression .)
    RSHIFT          reduce using rule 64 (term -> unary_expression .)
    LOGOR           reduce using rule 64 (term -> unary_expression .)
    LOGAND          reduce using rule 64 (term -> unary_expression .)
    LT              reduce using rule 64 (term -> unary_expression .)
    GT              reduce using rule 64 (term -> unary_expression .)
    LE              reduce using rule 64 (term -> unary_expression .)
    GE              reduce using rule 64 (term -> unary_expression .)
    EQ              reduce using rule 64 (term -> unary_expression .)
    NE              reduce using rule 64 (term -> unary_expression .)
    COMMENT         reduce using rule 64 (term -> unary_expression .)
    LBRACE          reduce using rule 64 (term -> unary_expression .)
    FOR             reduce using rule 64 (term -> unary_expression .)
    PPHASH          reduce using rule 64 (term -> unary_expression .)
    LPAREN          reduce using rule 64 (term -> unary_expression .)
    ID              reduce using rule 64 (term -> unary_expression .)
    VOID            reduce using rule 64 (term -> unary_expression .)
    SIZE_T          reduce using rule 64 (term -> unary_expression .)
    UNKNOWN         reduce using rule 64 (term -> unary_expression .)
    CHAR            reduce using rule 64 (term -> unary_expression .)
    SHORT           reduce using rule 64 (term -> unary_expression .)
    INT             reduce using rule 64 (term -> unary_expression .)
    LONG            reduce using rule 64 (term -> unary_expression .)
    FLOAT           reduce using rule 64 (term -> unary_expression .)
    DOUBLE          reduce using rule 64 (term -> unary_expression .)
    SIGNED          reduce using rule 64 (term -> unary_expression .)
    UNSIGNED        reduce using rule 64 (term -> unary_expression .)
    INT_CONST       reduce using rule 64 (term -> unary_expression .)
    FLOAT_CONST     reduce using rule 64 (term -> unary_expression .)
    STRING_LITERAL  reduce using rule 64 (term -> unary_expression .)
    LOGNOT          reduce using rule 64 (term -> unary_expression .)
    $end            reduce using rule 64 (term -> unary_expression .)
    RPAREN          reduce using rule 64 (term -> unary_expression .)
    SEMI            reduce using rule 64 (term -> unary_expression .)
    RBRACE          reduce using rule 64 (term -> unary_expression .)
    RBRACKET        reduce using rule 64 (term -> unary_expression .)
    PLUSPLUS        reduce using rule 64 (term -> unary_expression .)
    MINUSMINUS      reduce using rule 64 (term -> unary_expression .)
    COMMA           reduce using rule 64 (term -> unary_expression .)


state 7

    (59) unary_expression -> unary_token_before . term
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 48
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    function_call                  shift and go to state 49
    array_reference                shift and go to state 50
    identifier                     shift and go to state 51

state 8

    (76) native_type -> UNKNOWN .

    TIMES           reduce using rule 76 (native_type -> UNKNOWN .)
    ID              reduce using rule 76 (native_type -> UNKNOWN .)


state 9

    (74) native_type -> VOID .

    TIMES           reduce using rule 74 (native_type -> VOID .)
    ID              reduce using rule 74 (native_type -> VOID .)


state 10

    (5) top_level -> top_level compound .

    COMMENT         reduce using rule 5 (top_level -> top_level compound .)
    LBRACE          reduce using rule 5 (top_level -> top_level compound .)
    FOR             reduce using rule 5 (top_level -> top_level compound .)
    PPHASH          reduce using rule 5 (top_level -> top_level compound .)
    LPAREN          reduce using rule 5 (top_level -> top_level compound .)
    ID              reduce using rule 5 (top_level -> top_level compound .)
    VOID            reduce using rule 5 (top_level -> top_level compound .)
    SIZE_T          reduce using rule 5 (top_level -> top_level compound .)
    UNKNOWN         reduce using rule 5 (top_level -> top_level compound .)
    CHAR            reduce using rule 5 (top_level -> top_level compound .)
    SHORT           reduce using rule 5 (top_level -> top_level compound .)
    INT             reduce using rule 5 (top_level -> top_level compound .)
    LONG            reduce using rule 5 (top_level -> top_level compound .)
    FLOAT           reduce using rule 5 (top_level -> top_level compound .)
    DOUBLE          reduce using rule 5 (top_level -> top_level compound .)
    SIGNED          reduce using rule 5 (top_level -> top_level compound .)
    UNSIGNED        reduce using rule 5 (top_level -> top_level compound .)
    INT_CONST       reduce using rule 5 (top_level -> top_level compound .)
    FLOAT_CONST     reduce using rule 5 (top_level -> top_level compound .)
    STRING_LITERAL  reduce using rule 5 (top_level -> top_level compound .)
    MINUS           reduce using rule 5 (top_level -> top_level compound .)
    LOGNOT          reduce using rule 5 (top_level -> top_level compound .)
    $end            reduce using rule 5 (top_level -> top_level compound .)
    RBRACE          reduce using rule 5 (top_level -> top_level compound .)


state 11

    (69) function_declaration -> function_call . SEMI
    (63) term -> function_call .

    SEMI            shift and go to state 52
    DIVIDE          reduce using rule 63 (term -> function_call .)
    TIMES           reduce using rule 63 (term -> function_call .)
    PLUS            reduce using rule 63 (term -> function_call .)
    MINUS           reduce using rule 63 (term -> function_call .)
    MOD             reduce using rule 63 (term -> function_call .)
    OR              reduce using rule 63 (term -> function_call .)
    AND             reduce using rule 63 (term -> function_call .)
    LSHIFT          reduce using rule 63 (term -> function_call .)
    RSHIFT          reduce using rule 63 (term -> function_call .)
    LOGOR           reduce using rule 63 (term -> function_call .)
    LOGAND          reduce using rule 63 (term -> function_call .)
    LT              reduce using rule 63 (term -> function_call .)
    GT              reduce using rule 63 (term -> function_call .)
    LE              reduce using rule 63 (term -> function_call .)
    GE              reduce using rule 63 (term -> function_call .)
    EQ              reduce using rule 63 (term -> function_call .)
    NE              reduce using rule 63 (term -> function_call .)
    COMMENT         reduce using rule 63 (term -> function_call .)
    LBRACE          reduce using rule 63 (term -> function_call .)
    FOR             reduce using rule 63 (term -> function_call .)
    PPHASH          reduce using rule 63 (term -> function_call .)
    LPAREN          reduce using rule 63 (term -> function_call .)
    ID              reduce using rule 63 (term -> function_call .)
    VOID            reduce using rule 63 (term -> function_call .)
    SIZE_T          reduce using rule 63 (term -> function_call .)
    UNKNOWN         reduce using rule 63 (term -> function_call .)
    CHAR            reduce using rule 63 (term -> function_call .)
    SHORT           reduce using rule 63 (term -> function_call .)
    INT             reduce using rule 63 (term -> function_call .)
    LONG            reduce using rule 63 (term -> function_call .)
    FLOAT           reduce using rule 63 (term -> function_call .)
    DOUBLE          reduce using rule 63 (term -> function_call .)
    SIGNED          reduce using rule 63 (term -> function_call .)
    UNSIGNED        reduce using rule 63 (term -> function_call .)
    INT_CONST       reduce using rule 63 (term -> function_call .)
    FLOAT_CONST     reduce using rule 63 (term -> function_call .)
    STRING_LITERAL  reduce using rule 63 (term -> function_call .)
    LOGNOT          reduce using rule 63 (term -> function_call .)
    $end            reduce using rule 63 (term -> function_call .)
    RBRACE          reduce using rule 63 (term -> function_call .)


state 12

    (31) binop -> binop_expression .

    DIVIDE          reduce using rule 31 (binop -> binop_expression .)
    TIMES           reduce using rule 31 (binop -> binop_expression .)
    PLUS            reduce using rule 31 (binop -> binop_expression .)
    MINUS           reduce using rule 31 (binop -> binop_expression .)
    MOD             reduce using rule 31 (binop -> binop_expression .)
    OR              reduce using rule 31 (binop -> binop_expression .)
    AND             reduce using rule 31 (binop -> binop_expression .)
    LSHIFT          reduce using rule 31 (binop -> binop_expression .)
    RSHIFT          reduce using rule 31 (binop -> binop_expression .)
    LOGOR           reduce using rule 31 (binop -> binop_expression .)
    LOGAND          reduce using rule 31 (binop -> binop_expression .)
    LT              reduce using rule 31 (binop -> binop_expression .)
    GT              reduce using rule 31 (binop -> binop_expression .)
    LE              reduce using rule 31 (binop -> binop_expression .)
    GE              reduce using rule 31 (binop -> binop_expression .)
    EQ              reduce using rule 31 (binop -> binop_expression .)
    NE              reduce using rule 31 (binop -> binop_expression .)
    COMMENT         reduce using rule 31 (binop -> binop_expression .)
    LBRACE          reduce using rule 31 (binop -> binop_expression .)
    FOR             reduce using rule 31 (binop -> binop_expression .)
    PPHASH          reduce using rule 31 (binop -> binop_expression .)
    LPAREN          reduce using rule 31 (binop -> binop_expression .)
    ID              reduce using rule 31 (binop -> binop_expression .)
    VOID            reduce using rule 31 (binop -> binop_expression .)
    SIZE_T          reduce using rule 31 (binop -> binop_expression .)
    UNKNOWN         reduce using rule 31 (binop -> binop_expression .)
    CHAR            reduce using rule 31 (binop -> binop_expression .)
    SHORT           reduce using rule 31 (binop -> binop_expression .)
    INT             reduce using rule 31 (binop -> binop_expression .)
    LONG            reduce using rule 31 (binop -> binop_expression .)
    FLOAT           reduce using rule 31 (binop -> binop_expression .)
    DOUBLE          reduce using rule 31 (binop -> binop_expression .)
    SIGNED          reduce using rule 31 (binop -> binop_expression .)
    UNSIGNED        reduce using rule 31 (binop -> binop_expression .)
    INT_CONST       reduce using rule 31 (binop -> binop_expression .)
    FLOAT_CONST     reduce using rule 31 (binop -> binop_expression .)
    STRING_LITERAL  reduce using rule 31 (binop -> binop_expression .)
    LOGNOT          reduce using rule 31 (binop -> binop_expression .)
    $end            reduce using rule 31 (binop -> binop_expression .)
    RPAREN          reduce using rule 31 (binop -> binop_expression .)
    SEMI            reduce using rule 31 (binop -> binop_expression .)
    RBRACE          reduce using rule 31 (binop -> binop_expression .)
    RBRACKET        reduce using rule 31 (binop -> binop_expression .)


state 13

    (77) native_type -> CHAR .

    TIMES           reduce using rule 77 (native_type -> CHAR .)
    ID              reduce using rule 77 (native_type -> CHAR .)


state 14

    (56) unary_token_before -> LOGNOT .

    ID              reduce using rule 56 (unary_token_before -> LOGNOT .)
    INT_CONST       reduce using rule 56 (unary_token_before -> LOGNOT .)
    FLOAT_CONST     reduce using rule 56 (unary_token_before -> LOGNOT .)
    STRING_LITERAL  reduce using rule 56 (unary_token_before -> LOGNOT .)
    MINUS           reduce using rule 56 (unary_token_before -> LOGNOT .)
    LOGNOT          reduce using rule 56 (unary_token_before -> LOGNOT .)


state 15

    (80) native_type -> LONG .

    TIMES           reduce using rule 80 (native_type -> LONG .)
    ID              reduce using rule 80 (native_type -> LONG .)


state 16

    (86) type -> native_type .
    (87) type -> native_type . TIMES

    ID              reduce using rule 86 (type -> native_type .)
    TIMES           shift and go to state 53


state 17

    (61) term -> constant .

    DIVIDE          reduce using rule 61 (term -> constant .)
    TIMES           reduce using rule 61 (term -> constant .)
    PLUS            reduce using rule 61 (term -> constant .)
    MINUS           reduce using rule 61 (term -> constant .)
    MOD             reduce using rule 61 (term -> constant .)
    OR              reduce using rule 61 (term -> constant .)
    AND             reduce using rule 61 (term -> constant .)
    LSHIFT          reduce using rule 61 (term -> constant .)
    RSHIFT          reduce using rule 61 (term -> constant .)
    LOGOR           reduce using rule 61 (term -> constant .)
    LOGAND          reduce using rule 61 (term -> constant .)
    LT              reduce using rule 61 (term -> constant .)
    GT              reduce using rule 61 (term -> constant .)
    LE              reduce using rule 61 (term -> constant .)
    GE              reduce using rule 61 (term -> constant .)
    EQ              reduce using rule 61 (term -> constant .)
    NE              reduce using rule 61 (term -> constant .)
    COMMENT         reduce using rule 61 (term -> constant .)
    LBRACE          reduce using rule 61 (term -> constant .)
    FOR             reduce using rule 61 (term -> constant .)
    PPHASH          reduce using rule 61 (term -> constant .)
    LPAREN          reduce using rule 61 (term -> constant .)
    ID              reduce using rule 61 (term -> constant .)
    VOID            reduce using rule 61 (term -> constant .)
    SIZE_T          reduce using rule 61 (term -> constant .)
    UNKNOWN         reduce using rule 61 (term -> constant .)
    CHAR            reduce using rule 61 (term -> constant .)
    SHORT           reduce using rule 61 (term -> constant .)
    INT             reduce using rule 61 (term -> constant .)
    LONG            reduce using rule 61 (term -> constant .)
    FLOAT           reduce using rule 61 (term -> constant .)
    DOUBLE          reduce using rule 61 (term -> constant .)
    SIGNED          reduce using rule 61 (term -> constant .)
    UNSIGNED        reduce using rule 61 (term -> constant .)
    INT_CONST       reduce using rule 61 (term -> constant .)
    FLOAT_CONST     reduce using rule 61 (term -> constant .)
    STRING_LITERAL  reduce using rule 61 (term -> constant .)
    LOGNOT          reduce using rule 61 (term -> constant .)
    $end            reduce using rule 61 (term -> constant .)
    RPAREN          reduce using rule 61 (term -> constant .)
    SEMI            reduce using rule 61 (term -> constant .)
    RBRACE          reduce using rule 61 (term -> constant .)
    RBRACKET        reduce using rule 61 (term -> constant .)
    PLUSPLUS        reduce using rule 61 (term -> constant .)
    MINUSMINUS      reduce using rule 61 (term -> constant .)
    COMMA           reduce using rule 61 (term -> constant .)


state 18

    (55) unary_token_before -> MINUS .

    ID              reduce using rule 55 (unary_token_before -> MINUS .)
    INT_CONST       reduce using rule 55 (unary_token_before -> MINUS .)
    FLOAT_CONST     reduce using rule 55 (unary_token_before -> MINUS .)
    STRING_LITERAL  reduce using rule 55 (unary_token_before -> MINUS .)
    MINUS           reduce using rule 55 (unary_token_before -> MINUS .)
    LOGNOT          reduce using rule 55 (unary_token_before -> MINUS .)


state 19

    (11) comment -> COMMENT .

    RBRACE          reduce using rule 11 (comment -> COMMENT .)
    COMMENT         reduce using rule 11 (comment -> COMMENT .)
    LBRACE          reduce using rule 11 (comment -> COMMENT .)
    FOR             reduce using rule 11 (comment -> COMMENT .)
    PPHASH          reduce using rule 11 (comment -> COMMENT .)
    LPAREN          reduce using rule 11 (comment -> COMMENT .)
    ID              reduce using rule 11 (comment -> COMMENT .)
    VOID            reduce using rule 11 (comment -> COMMENT .)
    SIZE_T          reduce using rule 11 (comment -> COMMENT .)
    UNKNOWN         reduce using rule 11 (comment -> COMMENT .)
    CHAR            reduce using rule 11 (comment -> COMMENT .)
    SHORT           reduce using rule 11 (comment -> COMMENT .)
    INT             reduce using rule 11 (comment -> COMMENT .)
    LONG            reduce using rule 11 (comment -> COMMENT .)
    FLOAT           reduce using rule 11 (comment -> COMMENT .)
    DOUBLE          reduce using rule 11 (comment -> COMMENT .)
    SIGNED          reduce using rule 11 (comment -> COMMENT .)
    UNSIGNED        reduce using rule 11 (comment -> COMMENT .)
    INT_CONST       reduce using rule 11 (comment -> COMMENT .)
    FLOAT_CONST     reduce using rule 11 (comment -> COMMENT .)
    STRING_LITERAL  reduce using rule 11 (comment -> COMMENT .)
    MINUS           reduce using rule 11 (comment -> COMMENT .)
    LOGNOT          reduce using rule 11 (comment -> COMMENT .)
    $end            reduce using rule 11 (comment -> COMMENT .)


state 20

    (26) constant -> INT_CONST .

    DIVIDE          reduce using rule 26 (constant -> INT_CONST .)
    TIMES           reduce using rule 26 (constant -> INT_CONST .)
    PLUS            reduce using rule 26 (constant -> INT_CONST .)
    MINUS           reduce using rule 26 (constant -> INT_CONST .)
    MOD             reduce using rule 26 (constant -> INT_CONST .)
    OR              reduce using rule 26 (constant -> INT_CONST .)
    AND             reduce using rule 26 (constant -> INT_CONST .)
    LSHIFT          reduce using rule 26 (constant -> INT_CONST .)
    RSHIFT          reduce using rule 26 (constant -> INT_CONST .)
    LOGOR           reduce using rule 26 (constant -> INT_CONST .)
    LOGAND          reduce using rule 26 (constant -> INT_CONST .)
    LT              reduce using rule 26 (constant -> INT_CONST .)
    GT              reduce using rule 26 (constant -> INT_CONST .)
    LE              reduce using rule 26 (constant -> INT_CONST .)
    GE              reduce using rule 26 (constant -> INT_CONST .)
    EQ              reduce using rule 26 (constant -> INT_CONST .)
    NE              reduce using rule 26 (constant -> INT_CONST .)
    COMMENT         reduce using rule 26 (constant -> INT_CONST .)
    LBRACE          reduce using rule 26 (constant -> INT_CONST .)
    FOR             reduce using rule 26 (constant -> INT_CONST .)
    PPHASH          reduce using rule 26 (constant -> INT_CONST .)
    LPAREN          reduce using rule 26 (constant -> INT_CONST .)
    ID              reduce using rule 26 (constant -> INT_CONST .)
    VOID            reduce using rule 26 (constant -> INT_CONST .)
    SIZE_T          reduce using rule 26 (constant -> INT_CONST .)
    UNKNOWN         reduce using rule 26 (constant -> INT_CONST .)
    CHAR            reduce using rule 26 (constant -> INT_CONST .)
    SHORT           reduce using rule 26 (constant -> INT_CONST .)
    INT             reduce using rule 26 (constant -> INT_CONST .)
    LONG            reduce using rule 26 (constant -> INT_CONST .)
    FLOAT           reduce using rule 26 (constant -> INT_CONST .)
    DOUBLE          reduce using rule 26 (constant -> INT_CONST .)
    SIGNED          reduce using rule 26 (constant -> INT_CONST .)
    UNSIGNED        reduce using rule 26 (constant -> INT_CONST .)
    INT_CONST       reduce using rule 26 (constant -> INT_CONST .)
    FLOAT_CONST     reduce using rule 26 (constant -> INT_CONST .)
    STRING_LITERAL  reduce using rule 26 (constant -> INT_CONST .)
    LOGNOT          reduce using rule 26 (constant -> INT_CONST .)
    $end            reduce using rule 26 (constant -> INT_CONST .)
    RPAREN          reduce using rule 26 (constant -> INT_CONST .)
    SEMI            reduce using rule 26 (constant -> INT_CONST .)
    RBRACE          reduce using rule 26 (constant -> INT_CONST .)
    RBRACKET        reduce using rule 26 (constant -> INT_CONST .)
    COMMA           reduce using rule 26 (constant -> INT_CONST .)
    PLUSPLUS        reduce using rule 26 (constant -> INT_CONST .)
    MINUSMINUS      reduce using rule 26 (constant -> INT_CONST .)


state 21

    (27) constant -> FLOAT_CONST .

    DIVIDE          reduce using rule 27 (constant -> FLOAT_CONST .)
    TIMES           reduce using rule 27 (constant -> FLOAT_CONST .)
    PLUS            reduce using rule 27 (constant -> FLOAT_CONST .)
    MINUS           reduce using rule 27 (constant -> FLOAT_CONST .)
    MOD             reduce using rule 27 (constant -> FLOAT_CONST .)
    OR              reduce using rule 27 (constant -> FLOAT_CONST .)
    AND             reduce using rule 27 (constant -> FLOAT_CONST .)
    LSHIFT          reduce using rule 27 (constant -> FLOAT_CONST .)
    RSHIFT          reduce using rule 27 (constant -> FLOAT_CONST .)
    LOGOR           reduce using rule 27 (constant -> FLOAT_CONST .)
    LOGAND          reduce using rule 27 (constant -> FLOAT_CONST .)
    LT              reduce using rule 27 (constant -> FLOAT_CONST .)
    GT              reduce using rule 27 (constant -> FLOAT_CONST .)
    LE              reduce using rule 27 (constant -> FLOAT_CONST .)
    GE              reduce using rule 27 (constant -> FLOAT_CONST .)
    EQ              reduce using rule 27 (constant -> FLOAT_CONST .)
    NE              reduce using rule 27 (constant -> FLOAT_CONST .)
    COMMENT         reduce using rule 27 (constant -> FLOAT_CONST .)
    LBRACE          reduce using rule 27 (constant -> FLOAT_CONST .)
    FOR             reduce using rule 27 (constant -> FLOAT_CONST .)
    PPHASH          reduce using rule 27 (constant -> FLOAT_CONST .)
    LPAREN          reduce using rule 27 (constant -> FLOAT_CONST .)
    ID              reduce using rule 27 (constant -> FLOAT_CONST .)
    VOID            reduce using rule 27 (constant -> FLOAT_CONST .)
    SIZE_T          reduce using rule 27 (constant -> FLOAT_CONST .)
    UNKNOWN         reduce using rule 27 (constant -> FLOAT_CONST .)
    CHAR            reduce using rule 27 (constant -> FLOAT_CONST .)
    SHORT           reduce using rule 27 (constant -> FLOAT_CONST .)
    INT             reduce using rule 27 (constant -> FLOAT_CONST .)
    LONG            reduce using rule 27 (constant -> FLOAT_CONST .)
    FLOAT           reduce using rule 27 (constant -> FLOAT_CONST .)
    DOUBLE          reduce using rule 27 (constant -> FLOAT_CONST .)
    SIGNED          reduce using rule 27 (constant -> FLOAT_CONST .)
    UNSIGNED        reduce using rule 27 (constant -> FLOAT_CONST .)
    INT_CONST       reduce using rule 27 (constant -> FLOAT_CONST .)
    FLOAT_CONST     reduce using rule 27 (constant -> FLOAT_CONST .)
    STRING_LITERAL  reduce using rule 27 (constant -> FLOAT_CONST .)
    LOGNOT          reduce using rule 27 (constant -> FLOAT_CONST .)
    $end            reduce using rule 27 (constant -> FLOAT_CONST .)
    RPAREN          reduce using rule 27 (constant -> FLOAT_CONST .)
    SEMI            reduce using rule 27 (constant -> FLOAT_CONST .)
    RBRACE          reduce using rule 27 (constant -> FLOAT_CONST .)
    RBRACKET        reduce using rule 27 (constant -> FLOAT_CONST .)
    COMMA           reduce using rule 27 (constant -> FLOAT_CONST .)
    PLUSPLUS        reduce using rule 27 (constant -> FLOAT_CONST .)
    MINUSMINUS      reduce using rule 27 (constant -> FLOAT_CONST .)


state 22

    (24) assignment_expression -> array_reference . assignment_operator expr
    (62) term -> array_reference .
    (18) assignment_operator -> . EQUALS
    (19) assignment_operator -> . PLUSEQUALS
    (20) assignment_operator -> . MINUSEQUALS
    (21) assignment_operator -> . TIMESEQUALS

    DIVIDE          reduce using rule 62 (term -> array_reference .)
    TIMES           reduce using rule 62 (term -> array_reference .)
    PLUS            reduce using rule 62 (term -> array_reference .)
    MINUS           reduce using rule 62 (term -> array_reference .)
    MOD             reduce using rule 62 (term -> array_reference .)
    OR              reduce using rule 62 (term -> array_reference .)
    AND             reduce using rule 62 (term -> array_reference .)
    LSHIFT          reduce using rule 62 (term -> array_reference .)
    RSHIFT          reduce using rule 62 (term -> array_reference .)
    LOGOR           reduce using rule 62 (term -> array_reference .)
    LOGAND          reduce using rule 62 (term -> array_reference .)
    LT              reduce using rule 62 (term -> array_reference .)
    GT              reduce using rule 62 (term -> array_reference .)
    LE              reduce using rule 62 (term -> array_reference .)
    GE              reduce using rule 62 (term -> array_reference .)
    EQ              reduce using rule 62 (term -> array_reference .)
    NE              reduce using rule 62 (term -> array_reference .)
    COMMENT         reduce using rule 62 (term -> array_reference .)
    LBRACE          reduce using rule 62 (term -> array_reference .)
    FOR             reduce using rule 62 (term -> array_reference .)
    PPHASH          reduce using rule 62 (term -> array_reference .)
    LPAREN          reduce using rule 62 (term -> array_reference .)
    ID              reduce using rule 62 (term -> array_reference .)
    VOID            reduce using rule 62 (term -> array_reference .)
    SIZE_T          reduce using rule 62 (term -> array_reference .)
    UNKNOWN         reduce using rule 62 (term -> array_reference .)
    CHAR            reduce using rule 62 (term -> array_reference .)
    SHORT           reduce using rule 62 (term -> array_reference .)
    INT             reduce using rule 62 (term -> array_reference .)
    LONG            reduce using rule 62 (term -> array_reference .)
    FLOAT           reduce using rule 62 (term -> array_reference .)
    DOUBLE          reduce using rule 62 (term -> array_reference .)
    SIGNED          reduce using rule 62 (term -> array_reference .)
    UNSIGNED        reduce using rule 62 (term -> array_reference .)
    INT_CONST       reduce using rule 62 (term -> array_reference .)
    FLOAT_CONST     reduce using rule 62 (term -> array_reference .)
    STRING_LITERAL  reduce using rule 62 (term -> array_reference .)
    LOGNOT          reduce using rule 62 (term -> array_reference .)
    $end            reduce using rule 62 (term -> array_reference .)
    RBRACE          reduce using rule 62 (term -> array_reference .)
    EQUALS          shift and go to state 54
    PLUSEQUALS      shift and go to state 55
    MINUSEQUALS     shift and go to state 57
    TIMESEQUALS     shift and go to state 58

    assignment_operator            shift and go to state 56

state 23

    (9) top_level -> top_level include .

    COMMENT         reduce using rule 9 (top_level -> top_level include .)
    LBRACE          reduce using rule 9 (top_level -> top_level include .)
    FOR             reduce using rule 9 (top_level -> top_level include .)
    PPHASH          reduce using rule 9 (top_level -> top_level include .)
    LPAREN          reduce using rule 9 (top_level -> top_level include .)
    ID              reduce using rule 9 (top_level -> top_level include .)
    VOID            reduce using rule 9 (top_level -> top_level include .)
    SIZE_T          reduce using rule 9 (top_level -> top_level include .)
    UNKNOWN         reduce using rule 9 (top_level -> top_level include .)
    CHAR            reduce using rule 9 (top_level -> top_level include .)
    SHORT           reduce using rule 9 (top_level -> top_level include .)
    INT             reduce using rule 9 (top_level -> top_level include .)
    LONG            reduce using rule 9 (top_level -> top_level include .)
    FLOAT           reduce using rule 9 (top_level -> top_level include .)
    DOUBLE          reduce using rule 9 (top_level -> top_level include .)
    SIGNED          reduce using rule 9 (top_level -> top_level include .)
    UNSIGNED        reduce using rule 9 (top_level -> top_level include .)
    INT_CONST       reduce using rule 9 (top_level -> top_level include .)
    FLOAT_CONST     reduce using rule 9 (top_level -> top_level include .)
    STRING_LITERAL  reduce using rule 9 (top_level -> top_level include .)
    MINUS           reduce using rule 9 (top_level -> top_level include .)
    LOGNOT          reduce using rule 9 (top_level -> top_level include .)
    $end            reduce using rule 9 (top_level -> top_level include .)
    RBRACE          reduce using rule 9 (top_level -> top_level include .)


state 24

    (72) typeid -> type . identifier
    (73) array_typeid -> type . identifier subscript_list
    (88) identifier -> . ID

    ID              shift and go to state 32

    identifier                     shift and go to state 59

state 25

    (8) top_level -> top_level for_loop .

    COMMENT         reduce using rule 8 (top_level -> top_level for_loop .)
    LBRACE          reduce using rule 8 (top_level -> top_level for_loop .)
    FOR             reduce using rule 8 (top_level -> top_level for_loop .)
    PPHASH          reduce using rule 8 (top_level -> top_level for_loop .)
    LPAREN          reduce using rule 8 (top_level -> top_level for_loop .)
    ID              reduce using rule 8 (top_level -> top_level for_loop .)
    VOID            reduce using rule 8 (top_level -> top_level for_loop .)
    SIZE_T          reduce using rule 8 (top_level -> top_level for_loop .)
    UNKNOWN         reduce using rule 8 (top_level -> top_level for_loop .)
    CHAR            reduce using rule 8 (top_level -> top_level for_loop .)
    SHORT           reduce using rule 8 (top_level -> top_level for_loop .)
    INT             reduce using rule 8 (top_level -> top_level for_loop .)
    LONG            reduce using rule 8 (top_level -> top_level for_loop .)
    FLOAT           reduce using rule 8 (top_level -> top_level for_loop .)
    DOUBLE          reduce using rule 8 (top_level -> top_level for_loop .)
    SIGNED          reduce using rule 8 (top_level -> top_level for_loop .)
    UNSIGNED        reduce using rule 8 (top_level -> top_level for_loop .)
    INT_CONST       reduce using rule 8 (top_level -> top_level for_loop .)
    FLOAT_CONST     reduce using rule 8 (top_level -> top_level for_loop .)
    STRING_LITERAL  reduce using rule 8 (top_level -> top_level for_loop .)
    MINUS           reduce using rule 8 (top_level -> top_level for_loop .)
    LOGNOT          reduce using rule 8 (top_level -> top_level for_loop .)
    $end            reduce using rule 8 (top_level -> top_level for_loop .)
    RBRACE          reduce using rule 8 (top_level -> top_level for_loop .)


state 26

    (25) assignment_expression_semi -> assignment_expression . SEMI

    SEMI            shift and go to state 60


state 27

    (54) for_loop -> FOR . LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound

    LPAREN          shift and go to state 61


state 28

    (85) expr -> binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 85 (expr -> binop .)
    COMMENT         reduce using rule 85 (expr -> binop .)
    LBRACE          reduce using rule 85 (expr -> binop .)
    FOR             reduce using rule 85 (expr -> binop .)
    PPHASH          reduce using rule 85 (expr -> binop .)
    LPAREN          reduce using rule 85 (expr -> binop .)
    ID              reduce using rule 85 (expr -> binop .)
    VOID            reduce using rule 85 (expr -> binop .)
    SIZE_T          reduce using rule 85 (expr -> binop .)
    UNKNOWN         reduce using rule 85 (expr -> binop .)
    CHAR            reduce using rule 85 (expr -> binop .)
    SHORT           reduce using rule 85 (expr -> binop .)
    INT             reduce using rule 85 (expr -> binop .)
    LONG            reduce using rule 85 (expr -> binop .)
    FLOAT           reduce using rule 85 (expr -> binop .)
    DOUBLE          reduce using rule 85 (expr -> binop .)
    SIGNED          reduce using rule 85 (expr -> binop .)
    UNSIGNED        reduce using rule 85 (expr -> binop .)
    INT_CONST       reduce using rule 85 (expr -> binop .)
    FLOAT_CONST     reduce using rule 85 (expr -> binop .)
    STRING_LITERAL  reduce using rule 85 (expr -> binop .)
    LOGNOT          reduce using rule 85 (expr -> binop .)
    $end            reduce using rule 85 (expr -> binop .)
    RBRACE          reduce using rule 85 (expr -> binop .)
    SEMI            reduce using rule 85 (expr -> binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! MINUS           [ reduce using rule 85 (expr -> binop .) ]


state 29

    (65) compound -> LBRACE . top_level RBRACE
    (2) top_level -> . top_level comment
    (3) top_level -> . top_level function_declaration
    (4) top_level -> . top_level declaration
    (5) top_level -> . top_level compound
    (6) top_level -> . top_level assignment_expression_semi
    (7) top_level -> . top_level expr
    (8) top_level -> . top_level for_loop
    (9) top_level -> . top_level include
    (10) top_level -> . empty
    (90) empty -> .

    RBRACE          reduce using rule 90 (empty -> .)
    COMMENT         reduce using rule 90 (empty -> .)
    LBRACE          reduce using rule 90 (empty -> .)
    FOR             reduce using rule 90 (empty -> .)
    PPHASH          reduce using rule 90 (empty -> .)
    LPAREN          reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    VOID            reduce using rule 90 (empty -> .)
    SIZE_T          reduce using rule 90 (empty -> .)
    UNKNOWN         reduce using rule 90 (empty -> .)
    CHAR            reduce using rule 90 (empty -> .)
    SHORT           reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    LONG            reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    DOUBLE          reduce using rule 90 (empty -> .)
    SIGNED          reduce using rule 90 (empty -> .)
    UNSIGNED        reduce using rule 90 (empty -> .)
    INT_CONST       reduce using rule 90 (empty -> .)
    FLOAT_CONST     reduce using rule 90 (empty -> .)
    STRING_LITERAL  reduce using rule 90 (empty -> .)
    MINUS           reduce using rule 90 (empty -> .)
    LOGNOT          reduce using rule 90 (empty -> .)

    top_level                      shift and go to state 79
    empty                          shift and go to state 2

state 30

    (30) binop -> LPAREN . binop_expression RPAREN
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 81
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 80
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 31

    (4) top_level -> top_level declaration .

    COMMENT         reduce using rule 4 (top_level -> top_level declaration .)
    LBRACE          reduce using rule 4 (top_level -> top_level declaration .)
    FOR             reduce using rule 4 (top_level -> top_level declaration .)
    PPHASH          reduce using rule 4 (top_level -> top_level declaration .)
    LPAREN          reduce using rule 4 (top_level -> top_level declaration .)
    ID              reduce using rule 4 (top_level -> top_level declaration .)
    VOID            reduce using rule 4 (top_level -> top_level declaration .)
    SIZE_T          reduce using rule 4 (top_level -> top_level declaration .)
    UNKNOWN         reduce using rule 4 (top_level -> top_level declaration .)
    CHAR            reduce using rule 4 (top_level -> top_level declaration .)
    SHORT           reduce using rule 4 (top_level -> top_level declaration .)
    INT             reduce using rule 4 (top_level -> top_level declaration .)
    LONG            reduce using rule 4 (top_level -> top_level declaration .)
    FLOAT           reduce using rule 4 (top_level -> top_level declaration .)
    DOUBLE          reduce using rule 4 (top_level -> top_level declaration .)
    SIGNED          reduce using rule 4 (top_level -> top_level declaration .)
    UNSIGNED        reduce using rule 4 (top_level -> top_level declaration .)
    INT_CONST       reduce using rule 4 (top_level -> top_level declaration .)
    FLOAT_CONST     reduce using rule 4 (top_level -> top_level declaration .)
    STRING_LITERAL  reduce using rule 4 (top_level -> top_level declaration .)
    MINUS           reduce using rule 4 (top_level -> top_level declaration .)
    LOGNOT          reduce using rule 4 (top_level -> top_level declaration .)
    $end            reduce using rule 4 (top_level -> top_level declaration .)
    RBRACE          reduce using rule 4 (top_level -> top_level declaration .)


state 32

    (88) identifier -> ID .

    LPAREN          reduce using rule 88 (identifier -> ID .)
    LBRACKET        reduce using rule 88 (identifier -> ID .)
    DIVIDE          reduce using rule 88 (identifier -> ID .)
    TIMES           reduce using rule 88 (identifier -> ID .)
    PLUS            reduce using rule 88 (identifier -> ID .)
    MINUS           reduce using rule 88 (identifier -> ID .)
    MOD             reduce using rule 88 (identifier -> ID .)
    OR              reduce using rule 88 (identifier -> ID .)
    AND             reduce using rule 88 (identifier -> ID .)
    LSHIFT          reduce using rule 88 (identifier -> ID .)
    RSHIFT          reduce using rule 88 (identifier -> ID .)
    LOGOR           reduce using rule 88 (identifier -> ID .)
    LOGAND          reduce using rule 88 (identifier -> ID .)
    LT              reduce using rule 88 (identifier -> ID .)
    GT              reduce using rule 88 (identifier -> ID .)
    LE              reduce using rule 88 (identifier -> ID .)
    GE              reduce using rule 88 (identifier -> ID .)
    EQ              reduce using rule 88 (identifier -> ID .)
    NE              reduce using rule 88 (identifier -> ID .)
    COMMENT         reduce using rule 88 (identifier -> ID .)
    LBRACE          reduce using rule 88 (identifier -> ID .)
    FOR             reduce using rule 88 (identifier -> ID .)
    PPHASH          reduce using rule 88 (identifier -> ID .)
    ID              reduce using rule 88 (identifier -> ID .)
    VOID            reduce using rule 88 (identifier -> ID .)
    SIZE_T          reduce using rule 88 (identifier -> ID .)
    UNKNOWN         reduce using rule 88 (identifier -> ID .)
    CHAR            reduce using rule 88 (identifier -> ID .)
    SHORT           reduce using rule 88 (identifier -> ID .)
    INT             reduce using rule 88 (identifier -> ID .)
    LONG            reduce using rule 88 (identifier -> ID .)
    FLOAT           reduce using rule 88 (identifier -> ID .)
    DOUBLE          reduce using rule 88 (identifier -> ID .)
    SIGNED          reduce using rule 88 (identifier -> ID .)
    UNSIGNED        reduce using rule 88 (identifier -> ID .)
    INT_CONST       reduce using rule 88 (identifier -> ID .)
    FLOAT_CONST     reduce using rule 88 (identifier -> ID .)
    STRING_LITERAL  reduce using rule 88 (identifier -> ID .)
    LOGNOT          reduce using rule 88 (identifier -> ID .)
    $end            reduce using rule 88 (identifier -> ID .)
    RPAREN          reduce using rule 88 (identifier -> ID .)
    SEMI            reduce using rule 88 (identifier -> ID .)
    RBRACE          reduce using rule 88 (identifier -> ID .)
    RBRACKET        reduce using rule 88 (identifier -> ID .)
    EQUALS          reduce using rule 88 (identifier -> ID .)
    PLUSEQUALS      reduce using rule 88 (identifier -> ID .)
    MINUSEQUALS     reduce using rule 88 (identifier -> ID .)
    TIMESEQUALS     reduce using rule 88 (identifier -> ID .)
    COMMA           reduce using rule 88 (identifier -> ID .)
    PLUSPLUS        reduce using rule 88 (identifier -> ID .)
    MINUSMINUS      reduce using rule 88 (identifier -> ID .)


state 33

    (28) constant -> STRING_LITERAL .

    DIVIDE          reduce using rule 28 (constant -> STRING_LITERAL .)
    TIMES           reduce using rule 28 (constant -> STRING_LITERAL .)
    PLUS            reduce using rule 28 (constant -> STRING_LITERAL .)
    MINUS           reduce using rule 28 (constant -> STRING_LITERAL .)
    MOD             reduce using rule 28 (constant -> STRING_LITERAL .)
    OR              reduce using rule 28 (constant -> STRING_LITERAL .)
    AND             reduce using rule 28 (constant -> STRING_LITERAL .)
    LSHIFT          reduce using rule 28 (constant -> STRING_LITERAL .)
    RSHIFT          reduce using rule 28 (constant -> STRING_LITERAL .)
    LOGOR           reduce using rule 28 (constant -> STRING_LITERAL .)
    LOGAND          reduce using rule 28 (constant -> STRING_LITERAL .)
    LT              reduce using rule 28 (constant -> STRING_LITERAL .)
    GT              reduce using rule 28 (constant -> STRING_LITERAL .)
    LE              reduce using rule 28 (constant -> STRING_LITERAL .)
    GE              reduce using rule 28 (constant -> STRING_LITERAL .)
    EQ              reduce using rule 28 (constant -> STRING_LITERAL .)
    NE              reduce using rule 28 (constant -> STRING_LITERAL .)
    COMMENT         reduce using rule 28 (constant -> STRING_LITERAL .)
    LBRACE          reduce using rule 28 (constant -> STRING_LITERAL .)
    FOR             reduce using rule 28 (constant -> STRING_LITERAL .)
    PPHASH          reduce using rule 28 (constant -> STRING_LITERAL .)
    LPAREN          reduce using rule 28 (constant -> STRING_LITERAL .)
    ID              reduce using rule 28 (constant -> STRING_LITERAL .)
    VOID            reduce using rule 28 (constant -> STRING_LITERAL .)
    SIZE_T          reduce using rule 28 (constant -> STRING_LITERAL .)
    UNKNOWN         reduce using rule 28 (constant -> STRING_LITERAL .)
    CHAR            reduce using rule 28 (constant -> STRING_LITERAL .)
    SHORT           reduce using rule 28 (constant -> STRING_LITERAL .)
    INT             reduce using rule 28 (constant -> STRING_LITERAL .)
    LONG            reduce using rule 28 (constant -> STRING_LITERAL .)
    FLOAT           reduce using rule 28 (constant -> STRING_LITERAL .)
    DOUBLE          reduce using rule 28 (constant -> STRING_LITERAL .)
    SIGNED          reduce using rule 28 (constant -> STRING_LITERAL .)
    UNSIGNED        reduce using rule 28 (constant -> STRING_LITERAL .)
    INT_CONST       reduce using rule 28 (constant -> STRING_LITERAL .)
    FLOAT_CONST     reduce using rule 28 (constant -> STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 28 (constant -> STRING_LITERAL .)
    LOGNOT          reduce using rule 28 (constant -> STRING_LITERAL .)
    $end            reduce using rule 28 (constant -> STRING_LITERAL .)
    RPAREN          reduce using rule 28 (constant -> STRING_LITERAL .)
    SEMI            reduce using rule 28 (constant -> STRING_LITERAL .)
    RBRACE          reduce using rule 28 (constant -> STRING_LITERAL .)
    RBRACKET        reduce using rule 28 (constant -> STRING_LITERAL .)
    COMMA           reduce using rule 28 (constant -> STRING_LITERAL .)
    PLUSPLUS        reduce using rule 28 (constant -> STRING_LITERAL .)
    MINUSMINUS      reduce using rule 28 (constant -> STRING_LITERAL .)


state 34

    (67) function_declaration -> typeid . arglist SEMI
    (68) function_declaration -> typeid . arglist compound
    (70) declaration -> typeid . SEMI
    (22) assignment_expression -> typeid . assignment_operator expr
    (17) arglist -> . LPAREN arg_params RPAREN
    (18) assignment_operator -> . EQUALS
    (19) assignment_operator -> . PLUSEQUALS
    (20) assignment_operator -> . MINUSEQUALS
    (21) assignment_operator -> . TIMESEQUALS

    SEMI            shift and go to state 82
    LPAREN          shift and go to state 84
    EQUALS          shift and go to state 54
    PLUSEQUALS      shift and go to state 55
    MINUSEQUALS     shift and go to state 57
    TIMESEQUALS     shift and go to state 58

    assignment_operator            shift and go to state 83
    arglist                        shift and go to state 85

state 35

    (32) binop_expression -> term .

    DIVIDE          reduce using rule 32 (binop_expression -> term .)
    TIMES           reduce using rule 32 (binop_expression -> term .)
    PLUS            reduce using rule 32 (binop_expression -> term .)
    MINUS           reduce using rule 32 (binop_expression -> term .)
    MOD             reduce using rule 32 (binop_expression -> term .)
    OR              reduce using rule 32 (binop_expression -> term .)
    AND             reduce using rule 32 (binop_expression -> term .)
    LSHIFT          reduce using rule 32 (binop_expression -> term .)
    RSHIFT          reduce using rule 32 (binop_expression -> term .)
    LOGOR           reduce using rule 32 (binop_expression -> term .)
    LOGAND          reduce using rule 32 (binop_expression -> term .)
    LT              reduce using rule 32 (binop_expression -> term .)
    GT              reduce using rule 32 (binop_expression -> term .)
    LE              reduce using rule 32 (binop_expression -> term .)
    GE              reduce using rule 32 (binop_expression -> term .)
    EQ              reduce using rule 32 (binop_expression -> term .)
    NE              reduce using rule 32 (binop_expression -> term .)
    COMMENT         reduce using rule 32 (binop_expression -> term .)
    LBRACE          reduce using rule 32 (binop_expression -> term .)
    FOR             reduce using rule 32 (binop_expression -> term .)
    PPHASH          reduce using rule 32 (binop_expression -> term .)
    LPAREN          reduce using rule 32 (binop_expression -> term .)
    ID              reduce using rule 32 (binop_expression -> term .)
    VOID            reduce using rule 32 (binop_expression -> term .)
    SIZE_T          reduce using rule 32 (binop_expression -> term .)
    UNKNOWN         reduce using rule 32 (binop_expression -> term .)
    CHAR            reduce using rule 32 (binop_expression -> term .)
    SHORT           reduce using rule 32 (binop_expression -> term .)
    INT             reduce using rule 32 (binop_expression -> term .)
    LONG            reduce using rule 32 (binop_expression -> term .)
    FLOAT           reduce using rule 32 (binop_expression -> term .)
    DOUBLE          reduce using rule 32 (binop_expression -> term .)
    SIGNED          reduce using rule 32 (binop_expression -> term .)
    UNSIGNED        reduce using rule 32 (binop_expression -> term .)
    INT_CONST       reduce using rule 32 (binop_expression -> term .)
    FLOAT_CONST     reduce using rule 32 (binop_expression -> term .)
    STRING_LITERAL  reduce using rule 32 (binop_expression -> term .)
    LOGNOT          reduce using rule 32 (binop_expression -> term .)
    $end            reduce using rule 32 (binop_expression -> term .)
    RPAREN          reduce using rule 32 (binop_expression -> term .)
    SEMI            reduce using rule 32 (binop_expression -> term .)
    RBRACE          reduce using rule 32 (binop_expression -> term .)
    RBRACKET        reduce using rule 32 (binop_expression -> term .)


state 36

    (6) top_level -> top_level assignment_expression_semi .

    COMMENT         reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    LBRACE          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    FOR             reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    PPHASH          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    LPAREN          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    ID              reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    VOID            reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    SIZE_T          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    UNKNOWN         reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    CHAR            reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    SHORT           reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    INT             reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    LONG            reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    FLOAT           reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    DOUBLE          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    SIGNED          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    UNSIGNED        reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    INT_CONST       reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    FLOAT_CONST     reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    STRING_LITERAL  reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    MINUS           reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    LOGNOT          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    $end            reduce using rule 6 (top_level -> top_level assignment_expression_semi .)
    RBRACE          reduce using rule 6 (top_level -> top_level assignment_expression_semi .)


state 37

    (3) top_level -> top_level function_declaration .

    COMMENT         reduce using rule 3 (top_level -> top_level function_declaration .)
    LBRACE          reduce using rule 3 (top_level -> top_level function_declaration .)
    FOR             reduce using rule 3 (top_level -> top_level function_declaration .)
    PPHASH          reduce using rule 3 (top_level -> top_level function_declaration .)
    LPAREN          reduce using rule 3 (top_level -> top_level function_declaration .)
    ID              reduce using rule 3 (top_level -> top_level function_declaration .)
    VOID            reduce using rule 3 (top_level -> top_level function_declaration .)
    SIZE_T          reduce using rule 3 (top_level -> top_level function_declaration .)
    UNKNOWN         reduce using rule 3 (top_level -> top_level function_declaration .)
    CHAR            reduce using rule 3 (top_level -> top_level function_declaration .)
    SHORT           reduce using rule 3 (top_level -> top_level function_declaration .)
    INT             reduce using rule 3 (top_level -> top_level function_declaration .)
    LONG            reduce using rule 3 (top_level -> top_level function_declaration .)
    FLOAT           reduce using rule 3 (top_level -> top_level function_declaration .)
    DOUBLE          reduce using rule 3 (top_level -> top_level function_declaration .)
    SIGNED          reduce using rule 3 (top_level -> top_level function_declaration .)
    UNSIGNED        reduce using rule 3 (top_level -> top_level function_declaration .)
    INT_CONST       reduce using rule 3 (top_level -> top_level function_declaration .)
    FLOAT_CONST     reduce using rule 3 (top_level -> top_level function_declaration .)
    STRING_LITERAL  reduce using rule 3 (top_level -> top_level function_declaration .)
    MINUS           reduce using rule 3 (top_level -> top_level function_declaration .)
    LOGNOT          reduce using rule 3 (top_level -> top_level function_declaration .)
    $end            reduce using rule 3 (top_level -> top_level function_declaration .)
    RBRACE          reduce using rule 3 (top_level -> top_level function_declaration .)


state 38

    (89) include -> PPHASH . INCLUDE STRING_LITERAL

    INCLUDE         shift and go to state 86


state 39

    (79) native_type -> INT .

    TIMES           reduce using rule 79 (native_type -> INT .)
    ID              reduce using rule 79 (native_type -> INT .)


state 40

    (7) top_level -> top_level expr .

    COMMENT         reduce using rule 7 (top_level -> top_level expr .)
    LBRACE          reduce using rule 7 (top_level -> top_level expr .)
    FOR             reduce using rule 7 (top_level -> top_level expr .)
    PPHASH          reduce using rule 7 (top_level -> top_level expr .)
    LPAREN          reduce using rule 7 (top_level -> top_level expr .)
    ID              reduce using rule 7 (top_level -> top_level expr .)
    VOID            reduce using rule 7 (top_level -> top_level expr .)
    SIZE_T          reduce using rule 7 (top_level -> top_level expr .)
    UNKNOWN         reduce using rule 7 (top_level -> top_level expr .)
    CHAR            reduce using rule 7 (top_level -> top_level expr .)
    SHORT           reduce using rule 7 (top_level -> top_level expr .)
    INT             reduce using rule 7 (top_level -> top_level expr .)
    LONG            reduce using rule 7 (top_level -> top_level expr .)
    FLOAT           reduce using rule 7 (top_level -> top_level expr .)
    DOUBLE          reduce using rule 7 (top_level -> top_level expr .)
    SIGNED          reduce using rule 7 (top_level -> top_level expr .)
    UNSIGNED        reduce using rule 7 (top_level -> top_level expr .)
    INT_CONST       reduce using rule 7 (top_level -> top_level expr .)
    FLOAT_CONST     reduce using rule 7 (top_level -> top_level expr .)
    STRING_LITERAL  reduce using rule 7 (top_level -> top_level expr .)
    MINUS           reduce using rule 7 (top_level -> top_level expr .)
    LOGNOT          reduce using rule 7 (top_level -> top_level expr .)
    $end            reduce using rule 7 (top_level -> top_level expr .)
    RBRACE          reduce using rule 7 (top_level -> top_level expr .)


state 41

    (81) native_type -> FLOAT .

    TIMES           reduce using rule 81 (native_type -> FLOAT .)
    ID              reduce using rule 81 (native_type -> FLOAT .)


state 42

    (83) native_type -> SIGNED .

    TIMES           reduce using rule 83 (native_type -> SIGNED .)
    ID              reduce using rule 83 (native_type -> SIGNED .)


state 43

    (84) native_type -> UNSIGNED .

    TIMES           reduce using rule 84 (native_type -> UNSIGNED .)
    ID              reduce using rule 84 (native_type -> UNSIGNED .)


state 44

    (71) declaration -> array_typeid . SEMI

    SEMI            shift and go to state 87


state 45

    (82) native_type -> DOUBLE .

    TIMES           reduce using rule 82 (native_type -> DOUBLE .)
    ID              reduce using rule 82 (native_type -> DOUBLE .)


state 46

    (75) native_type -> SIZE_T .

    TIMES           reduce using rule 75 (native_type -> SIZE_T .)
    ID              reduce using rule 75 (native_type -> SIZE_T .)


state 47

    (66) function_call -> identifier . arglist
    (23) assignment_expression -> identifier . assignment_operator expr
    (53) array_reference -> identifier . subscript_list
    (60) term -> identifier .
    (17) arglist -> . LPAREN arg_params RPAREN
    (18) assignment_operator -> . EQUALS
    (19) assignment_operator -> . PLUSEQUALS
    (20) assignment_operator -> . MINUSEQUALS
    (21) assignment_operator -> . TIMESEQUALS
    (51) subscript_list -> . subscript
    (52) subscript_list -> . subscript subscript_list
    (50) subscript -> . LBRACKET expr RBRACKET

  ! shift/reduce conflict for LPAREN resolved as shift
    DIVIDE          reduce using rule 60 (term -> identifier .)
    TIMES           reduce using rule 60 (term -> identifier .)
    PLUS            reduce using rule 60 (term -> identifier .)
    MINUS           reduce using rule 60 (term -> identifier .)
    MOD             reduce using rule 60 (term -> identifier .)
    OR              reduce using rule 60 (term -> identifier .)
    AND             reduce using rule 60 (term -> identifier .)
    LSHIFT          reduce using rule 60 (term -> identifier .)
    RSHIFT          reduce using rule 60 (term -> identifier .)
    LOGOR           reduce using rule 60 (term -> identifier .)
    LOGAND          reduce using rule 60 (term -> identifier .)
    LT              reduce using rule 60 (term -> identifier .)
    GT              reduce using rule 60 (term -> identifier .)
    LE              reduce using rule 60 (term -> identifier .)
    GE              reduce using rule 60 (term -> identifier .)
    EQ              reduce using rule 60 (term -> identifier .)
    NE              reduce using rule 60 (term -> identifier .)
    COMMENT         reduce using rule 60 (term -> identifier .)
    LBRACE          reduce using rule 60 (term -> identifier .)
    FOR             reduce using rule 60 (term -> identifier .)
    PPHASH          reduce using rule 60 (term -> identifier .)
    ID              reduce using rule 60 (term -> identifier .)
    VOID            reduce using rule 60 (term -> identifier .)
    SIZE_T          reduce using rule 60 (term -> identifier .)
    UNKNOWN         reduce using rule 60 (term -> identifier .)
    CHAR            reduce using rule 60 (term -> identifier .)
    SHORT           reduce using rule 60 (term -> identifier .)
    INT             reduce using rule 60 (term -> identifier .)
    LONG            reduce using rule 60 (term -> identifier .)
    FLOAT           reduce using rule 60 (term -> identifier .)
    DOUBLE          reduce using rule 60 (term -> identifier .)
    SIGNED          reduce using rule 60 (term -> identifier .)
    UNSIGNED        reduce using rule 60 (term -> identifier .)
    INT_CONST       reduce using rule 60 (term -> identifier .)
    FLOAT_CONST     reduce using rule 60 (term -> identifier .)
    STRING_LITERAL  reduce using rule 60 (term -> identifier .)
    LOGNOT          reduce using rule 60 (term -> identifier .)
    $end            reduce using rule 60 (term -> identifier .)
    RBRACE          reduce using rule 60 (term -> identifier .)
    LPAREN          shift and go to state 84
    EQUALS          shift and go to state 54
    PLUSEQUALS      shift and go to state 55
    MINUSEQUALS     shift and go to state 57
    TIMESEQUALS     shift and go to state 58
    LBRACKET        shift and go to state 90

  ! LPAREN          [ reduce using rule 60 (term -> identifier .) ]

    arglist                        shift and go to state 88
    subscript_list                 shift and go to state 89
    assignment_operator            shift and go to state 91
    subscript                      shift and go to state 92

state 48

    (59) unary_expression -> unary_token_before term .

    DIVIDE          reduce using rule 59 (unary_expression -> unary_token_before term .)
    TIMES           reduce using rule 59 (unary_expression -> unary_token_before term .)
    PLUS            reduce using rule 59 (unary_expression -> unary_token_before term .)
    MINUS           reduce using rule 59 (unary_expression -> unary_token_before term .)
    MOD             reduce using rule 59 (unary_expression -> unary_token_before term .)
    OR              reduce using rule 59 (unary_expression -> unary_token_before term .)
    AND             reduce using rule 59 (unary_expression -> unary_token_before term .)
    LSHIFT          reduce using rule 59 (unary_expression -> unary_token_before term .)
    RSHIFT          reduce using rule 59 (unary_expression -> unary_token_before term .)
    LOGOR           reduce using rule 59 (unary_expression -> unary_token_before term .)
    LOGAND          reduce using rule 59 (unary_expression -> unary_token_before term .)
    LT              reduce using rule 59 (unary_expression -> unary_token_before term .)
    GT              reduce using rule 59 (unary_expression -> unary_token_before term .)
    LE              reduce using rule 59 (unary_expression -> unary_token_before term .)
    GE              reduce using rule 59 (unary_expression -> unary_token_before term .)
    EQ              reduce using rule 59 (unary_expression -> unary_token_before term .)
    NE              reduce using rule 59 (unary_expression -> unary_token_before term .)
    COMMENT         reduce using rule 59 (unary_expression -> unary_token_before term .)
    LBRACE          reduce using rule 59 (unary_expression -> unary_token_before term .)
    FOR             reduce using rule 59 (unary_expression -> unary_token_before term .)
    PPHASH          reduce using rule 59 (unary_expression -> unary_token_before term .)
    LPAREN          reduce using rule 59 (unary_expression -> unary_token_before term .)
    ID              reduce using rule 59 (unary_expression -> unary_token_before term .)
    VOID            reduce using rule 59 (unary_expression -> unary_token_before term .)
    SIZE_T          reduce using rule 59 (unary_expression -> unary_token_before term .)
    UNKNOWN         reduce using rule 59 (unary_expression -> unary_token_before term .)
    CHAR            reduce using rule 59 (unary_expression -> unary_token_before term .)
    SHORT           reduce using rule 59 (unary_expression -> unary_token_before term .)
    INT             reduce using rule 59 (unary_expression -> unary_token_before term .)
    LONG            reduce using rule 59 (unary_expression -> unary_token_before term .)
    FLOAT           reduce using rule 59 (unary_expression -> unary_token_before term .)
    DOUBLE          reduce using rule 59 (unary_expression -> unary_token_before term .)
    SIGNED          reduce using rule 59 (unary_expression -> unary_token_before term .)
    UNSIGNED        reduce using rule 59 (unary_expression -> unary_token_before term .)
    INT_CONST       reduce using rule 59 (unary_expression -> unary_token_before term .)
    FLOAT_CONST     reduce using rule 59 (unary_expression -> unary_token_before term .)
    STRING_LITERAL  reduce using rule 59 (unary_expression -> unary_token_before term .)
    LOGNOT          reduce using rule 59 (unary_expression -> unary_token_before term .)
    $end            reduce using rule 59 (unary_expression -> unary_token_before term .)
    RPAREN          reduce using rule 59 (unary_expression -> unary_token_before term .)
    SEMI            reduce using rule 59 (unary_expression -> unary_token_before term .)
    RBRACE          reduce using rule 59 (unary_expression -> unary_token_before term .)
    RBRACKET        reduce using rule 59 (unary_expression -> unary_token_before term .)
    COMMA           reduce using rule 59 (unary_expression -> unary_token_before term .)
    PLUSPLUS        reduce using rule 59 (unary_expression -> unary_token_before term .)
    MINUSMINUS      reduce using rule 59 (unary_expression -> unary_token_before term .)


state 49

    (63) term -> function_call .

    DIVIDE          reduce using rule 63 (term -> function_call .)
    TIMES           reduce using rule 63 (term -> function_call .)
    PLUS            reduce using rule 63 (term -> function_call .)
    MINUS           reduce using rule 63 (term -> function_call .)
    MOD             reduce using rule 63 (term -> function_call .)
    OR              reduce using rule 63 (term -> function_call .)
    AND             reduce using rule 63 (term -> function_call .)
    LSHIFT          reduce using rule 63 (term -> function_call .)
    RSHIFT          reduce using rule 63 (term -> function_call .)
    LOGOR           reduce using rule 63 (term -> function_call .)
    LOGAND          reduce using rule 63 (term -> function_call .)
    LT              reduce using rule 63 (term -> function_call .)
    GT              reduce using rule 63 (term -> function_call .)
    LE              reduce using rule 63 (term -> function_call .)
    GE              reduce using rule 63 (term -> function_call .)
    EQ              reduce using rule 63 (term -> function_call .)
    NE              reduce using rule 63 (term -> function_call .)
    COMMENT         reduce using rule 63 (term -> function_call .)
    LBRACE          reduce using rule 63 (term -> function_call .)
    FOR             reduce using rule 63 (term -> function_call .)
    PPHASH          reduce using rule 63 (term -> function_call .)
    LPAREN          reduce using rule 63 (term -> function_call .)
    ID              reduce using rule 63 (term -> function_call .)
    VOID            reduce using rule 63 (term -> function_call .)
    SIZE_T          reduce using rule 63 (term -> function_call .)
    UNKNOWN         reduce using rule 63 (term -> function_call .)
    CHAR            reduce using rule 63 (term -> function_call .)
    SHORT           reduce using rule 63 (term -> function_call .)
    INT             reduce using rule 63 (term -> function_call .)
    LONG            reduce using rule 63 (term -> function_call .)
    FLOAT           reduce using rule 63 (term -> function_call .)
    DOUBLE          reduce using rule 63 (term -> function_call .)
    SIGNED          reduce using rule 63 (term -> function_call .)
    UNSIGNED        reduce using rule 63 (term -> function_call .)
    INT_CONST       reduce using rule 63 (term -> function_call .)
    FLOAT_CONST     reduce using rule 63 (term -> function_call .)
    STRING_LITERAL  reduce using rule 63 (term -> function_call .)
    LOGNOT          reduce using rule 63 (term -> function_call .)
    $end            reduce using rule 63 (term -> function_call .)
    RPAREN          reduce using rule 63 (term -> function_call .)
    SEMI            reduce using rule 63 (term -> function_call .)
    RBRACE          reduce using rule 63 (term -> function_call .)
    RBRACKET        reduce using rule 63 (term -> function_call .)
    PLUSPLUS        reduce using rule 63 (term -> function_call .)
    MINUSMINUS      reduce using rule 63 (term -> function_call .)
    COMMA           reduce using rule 63 (term -> function_call .)


state 50

    (62) term -> array_reference .

    DIVIDE          reduce using rule 62 (term -> array_reference .)
    TIMES           reduce using rule 62 (term -> array_reference .)
    PLUS            reduce using rule 62 (term -> array_reference .)
    MINUS           reduce using rule 62 (term -> array_reference .)
    MOD             reduce using rule 62 (term -> array_reference .)
    OR              reduce using rule 62 (term -> array_reference .)
    AND             reduce using rule 62 (term -> array_reference .)
    LSHIFT          reduce using rule 62 (term -> array_reference .)
    RSHIFT          reduce using rule 62 (term -> array_reference .)
    LOGOR           reduce using rule 62 (term -> array_reference .)
    LOGAND          reduce using rule 62 (term -> array_reference .)
    LT              reduce using rule 62 (term -> array_reference .)
    GT              reduce using rule 62 (term -> array_reference .)
    LE              reduce using rule 62 (term -> array_reference .)
    GE              reduce using rule 62 (term -> array_reference .)
    EQ              reduce using rule 62 (term -> array_reference .)
    NE              reduce using rule 62 (term -> array_reference .)
    COMMENT         reduce using rule 62 (term -> array_reference .)
    LBRACE          reduce using rule 62 (term -> array_reference .)
    FOR             reduce using rule 62 (term -> array_reference .)
    PPHASH          reduce using rule 62 (term -> array_reference .)
    LPAREN          reduce using rule 62 (term -> array_reference .)
    ID              reduce using rule 62 (term -> array_reference .)
    VOID            reduce using rule 62 (term -> array_reference .)
    SIZE_T          reduce using rule 62 (term -> array_reference .)
    UNKNOWN         reduce using rule 62 (term -> array_reference .)
    CHAR            reduce using rule 62 (term -> array_reference .)
    SHORT           reduce using rule 62 (term -> array_reference .)
    INT             reduce using rule 62 (term -> array_reference .)
    LONG            reduce using rule 62 (term -> array_reference .)
    FLOAT           reduce using rule 62 (term -> array_reference .)
    DOUBLE          reduce using rule 62 (term -> array_reference .)
    SIGNED          reduce using rule 62 (term -> array_reference .)
    UNSIGNED        reduce using rule 62 (term -> array_reference .)
    INT_CONST       reduce using rule 62 (term -> array_reference .)
    FLOAT_CONST     reduce using rule 62 (term -> array_reference .)
    STRING_LITERAL  reduce using rule 62 (term -> array_reference .)
    LOGNOT          reduce using rule 62 (term -> array_reference .)
    $end            reduce using rule 62 (term -> array_reference .)
    RPAREN          reduce using rule 62 (term -> array_reference .)
    SEMI            reduce using rule 62 (term -> array_reference .)
    RBRACE          reduce using rule 62 (term -> array_reference .)
    RBRACKET        reduce using rule 62 (term -> array_reference .)
    PLUSPLUS        reduce using rule 62 (term -> array_reference .)
    MINUSMINUS      reduce using rule 62 (term -> array_reference .)
    COMMA           reduce using rule 62 (term -> array_reference .)


state 51

    (60) term -> identifier .
    (53) array_reference -> identifier . subscript_list
    (66) function_call -> identifier . arglist
    (51) subscript_list -> . subscript
    (52) subscript_list -> . subscript subscript_list
    (17) arglist -> . LPAREN arg_params RPAREN
    (50) subscript -> . LBRACKET expr RBRACKET

  ! shift/reduce conflict for LPAREN resolved as shift
    DIVIDE          reduce using rule 60 (term -> identifier .)
    TIMES           reduce using rule 60 (term -> identifier .)
    PLUS            reduce using rule 60 (term -> identifier .)
    MINUS           reduce using rule 60 (term -> identifier .)
    MOD             reduce using rule 60 (term -> identifier .)
    OR              reduce using rule 60 (term -> identifier .)
    AND             reduce using rule 60 (term -> identifier .)
    LSHIFT          reduce using rule 60 (term -> identifier .)
    RSHIFT          reduce using rule 60 (term -> identifier .)
    LOGOR           reduce using rule 60 (term -> identifier .)
    LOGAND          reduce using rule 60 (term -> identifier .)
    LT              reduce using rule 60 (term -> identifier .)
    GT              reduce using rule 60 (term -> identifier .)
    LE              reduce using rule 60 (term -> identifier .)
    GE              reduce using rule 60 (term -> identifier .)
    EQ              reduce using rule 60 (term -> identifier .)
    NE              reduce using rule 60 (term -> identifier .)
    COMMENT         reduce using rule 60 (term -> identifier .)
    LBRACE          reduce using rule 60 (term -> identifier .)
    FOR             reduce using rule 60 (term -> identifier .)
    PPHASH          reduce using rule 60 (term -> identifier .)
    ID              reduce using rule 60 (term -> identifier .)
    VOID            reduce using rule 60 (term -> identifier .)
    SIZE_T          reduce using rule 60 (term -> identifier .)
    UNKNOWN         reduce using rule 60 (term -> identifier .)
    CHAR            reduce using rule 60 (term -> identifier .)
    SHORT           reduce using rule 60 (term -> identifier .)
    INT             reduce using rule 60 (term -> identifier .)
    LONG            reduce using rule 60 (term -> identifier .)
    FLOAT           reduce using rule 60 (term -> identifier .)
    DOUBLE          reduce using rule 60 (term -> identifier .)
    SIGNED          reduce using rule 60 (term -> identifier .)
    UNSIGNED        reduce using rule 60 (term -> identifier .)
    INT_CONST       reduce using rule 60 (term -> identifier .)
    FLOAT_CONST     reduce using rule 60 (term -> identifier .)
    STRING_LITERAL  reduce using rule 60 (term -> identifier .)
    LOGNOT          reduce using rule 60 (term -> identifier .)
    $end            reduce using rule 60 (term -> identifier .)
    RPAREN          reduce using rule 60 (term -> identifier .)
    SEMI            reduce using rule 60 (term -> identifier .)
    RBRACE          reduce using rule 60 (term -> identifier .)
    RBRACKET        reduce using rule 60 (term -> identifier .)
    PLUSPLUS        reduce using rule 60 (term -> identifier .)
    MINUSMINUS      reduce using rule 60 (term -> identifier .)
    COMMA           reduce using rule 60 (term -> identifier .)
    LPAREN          shift and go to state 84
    LBRACKET        shift and go to state 90

  ! LPAREN          [ reduce using rule 60 (term -> identifier .) ]

    subscript_list                 shift and go to state 89
    subscript                      shift and go to state 92
    arglist                        shift and go to state 88

state 52

    (69) function_declaration -> function_call SEMI .

    RBRACE          reduce using rule 69 (function_declaration -> function_call SEMI .)
    COMMENT         reduce using rule 69 (function_declaration -> function_call SEMI .)
    LBRACE          reduce using rule 69 (function_declaration -> function_call SEMI .)
    FOR             reduce using rule 69 (function_declaration -> function_call SEMI .)
    PPHASH          reduce using rule 69 (function_declaration -> function_call SEMI .)
    LPAREN          reduce using rule 69 (function_declaration -> function_call SEMI .)
    ID              reduce using rule 69 (function_declaration -> function_call SEMI .)
    VOID            reduce using rule 69 (function_declaration -> function_call SEMI .)
    SIZE_T          reduce using rule 69 (function_declaration -> function_call SEMI .)
    UNKNOWN         reduce using rule 69 (function_declaration -> function_call SEMI .)
    CHAR            reduce using rule 69 (function_declaration -> function_call SEMI .)
    SHORT           reduce using rule 69 (function_declaration -> function_call SEMI .)
    INT             reduce using rule 69 (function_declaration -> function_call SEMI .)
    LONG            reduce using rule 69 (function_declaration -> function_call SEMI .)
    FLOAT           reduce using rule 69 (function_declaration -> function_call SEMI .)
    DOUBLE          reduce using rule 69 (function_declaration -> function_call SEMI .)
    SIGNED          reduce using rule 69 (function_declaration -> function_call SEMI .)
    UNSIGNED        reduce using rule 69 (function_declaration -> function_call SEMI .)
    INT_CONST       reduce using rule 69 (function_declaration -> function_call SEMI .)
    FLOAT_CONST     reduce using rule 69 (function_declaration -> function_call SEMI .)
    STRING_LITERAL  reduce using rule 69 (function_declaration -> function_call SEMI .)
    MINUS           reduce using rule 69 (function_declaration -> function_call SEMI .)
    LOGNOT          reduce using rule 69 (function_declaration -> function_call SEMI .)
    $end            reduce using rule 69 (function_declaration -> function_call SEMI .)


state 53

    (87) type -> native_type TIMES .

    ID              reduce using rule 87 (type -> native_type TIMES .)


state 54

    (18) assignment_operator -> EQUALS .

    LPAREN          reduce using rule 18 (assignment_operator -> EQUALS .)
    ID              reduce using rule 18 (assignment_operator -> EQUALS .)
    INT_CONST       reduce using rule 18 (assignment_operator -> EQUALS .)
    FLOAT_CONST     reduce using rule 18 (assignment_operator -> EQUALS .)
    STRING_LITERAL  reduce using rule 18 (assignment_operator -> EQUALS .)
    MINUS           reduce using rule 18 (assignment_operator -> EQUALS .)
    LOGNOT          reduce using rule 18 (assignment_operator -> EQUALS .)


state 55

    (19) assignment_operator -> PLUSEQUALS .

    LPAREN          reduce using rule 19 (assignment_operator -> PLUSEQUALS .)
    ID              reduce using rule 19 (assignment_operator -> PLUSEQUALS .)
    INT_CONST       reduce using rule 19 (assignment_operator -> PLUSEQUALS .)
    FLOAT_CONST     reduce using rule 19 (assignment_operator -> PLUSEQUALS .)
    STRING_LITERAL  reduce using rule 19 (assignment_operator -> PLUSEQUALS .)
    MINUS           reduce using rule 19 (assignment_operator -> PLUSEQUALS .)
    LOGNOT          reduce using rule 19 (assignment_operator -> PLUSEQUALS .)


state 56

    (24) assignment_expression -> array_reference assignment_operator . expr
    (85) expr -> . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 28
    expr                           shift and go to state 93
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 51
    function_call                  shift and go to state 49

state 57

    (20) assignment_operator -> MINUSEQUALS .

    LPAREN          reduce using rule 20 (assignment_operator -> MINUSEQUALS .)
    ID              reduce using rule 20 (assignment_operator -> MINUSEQUALS .)
    INT_CONST       reduce using rule 20 (assignment_operator -> MINUSEQUALS .)
    FLOAT_CONST     reduce using rule 20 (assignment_operator -> MINUSEQUALS .)
    STRING_LITERAL  reduce using rule 20 (assignment_operator -> MINUSEQUALS .)
    MINUS           reduce using rule 20 (assignment_operator -> MINUSEQUALS .)
    LOGNOT          reduce using rule 20 (assignment_operator -> MINUSEQUALS .)


state 58

    (21) assignment_operator -> TIMESEQUALS .

    LPAREN          reduce using rule 21 (assignment_operator -> TIMESEQUALS .)
    ID              reduce using rule 21 (assignment_operator -> TIMESEQUALS .)
    INT_CONST       reduce using rule 21 (assignment_operator -> TIMESEQUALS .)
    FLOAT_CONST     reduce using rule 21 (assignment_operator -> TIMESEQUALS .)
    STRING_LITERAL  reduce using rule 21 (assignment_operator -> TIMESEQUALS .)
    MINUS           reduce using rule 21 (assignment_operator -> TIMESEQUALS .)
    LOGNOT          reduce using rule 21 (assignment_operator -> TIMESEQUALS .)


state 59

    (72) typeid -> type identifier .
    (73) array_typeid -> type identifier . subscript_list
    (51) subscript_list -> . subscript
    (52) subscript_list -> . subscript subscript_list
    (50) subscript -> . LBRACKET expr RBRACKET

    SEMI            reduce using rule 72 (typeid -> type identifier .)
    LPAREN          reduce using rule 72 (typeid -> type identifier .)
    EQUALS          reduce using rule 72 (typeid -> type identifier .)
    PLUSEQUALS      reduce using rule 72 (typeid -> type identifier .)
    MINUSEQUALS     reduce using rule 72 (typeid -> type identifier .)
    TIMESEQUALS     reduce using rule 72 (typeid -> type identifier .)
    LBRACKET        shift and go to state 90

    subscript_list                 shift and go to state 94
    subscript                      shift and go to state 92

state 60

    (25) assignment_expression_semi -> assignment_expression SEMI .

    RBRACE          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    COMMENT         reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    LBRACE          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    FOR             reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    PPHASH          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    LPAREN          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    ID              reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    VOID            reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    SIZE_T          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    UNKNOWN         reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    CHAR            reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    SHORT           reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    INT             reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    LONG            reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    FLOAT           reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    DOUBLE          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    SIGNED          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    UNSIGNED        reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    INT_CONST       reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    FLOAT_CONST     reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    STRING_LITERAL  reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    MINUS           reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    LOGNOT          reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)
    $end            reduce using rule 25 (assignment_expression_semi -> assignment_expression SEMI .)


state 61

    (54) for_loop -> FOR LPAREN . assignment_expression SEMI binop SEMI increment RPAREN compound
    (22) assignment_expression -> . typeid assignment_operator expr
    (23) assignment_expression -> . identifier assignment_operator expr
    (24) assignment_expression -> . array_reference assignment_operator expr
    (72) typeid -> . type identifier
    (88) identifier -> . ID
    (53) array_reference -> . identifier subscript_list
    (86) type -> . native_type
    (87) type -> . native_type TIMES
    (74) native_type -> . VOID
    (75) native_type -> . SIZE_T
    (76) native_type -> . UNKNOWN
    (77) native_type -> . CHAR
    (78) native_type -> . SHORT
    (79) native_type -> . INT
    (80) native_type -> . LONG
    (81) native_type -> . FLOAT
    (82) native_type -> . DOUBLE
    (83) native_type -> . SIGNED
    (84) native_type -> . UNSIGNED

    ID              shift and go to state 32
    VOID            shift and go to state 9
    SIZE_T          shift and go to state 46
    UNKNOWN         shift and go to state 8
    CHAR            shift and go to state 13
    SHORT           shift and go to state 5
    INT             shift and go to state 39
    LONG            shift and go to state 15
    FLOAT           shift and go to state 41
    DOUBLE          shift and go to state 45
    SIGNED          shift and go to state 42
    UNSIGNED        shift and go to state 43

    typeid                         shift and go to state 98
    assignment_expression          shift and go to state 97
    native_type                    shift and go to state 16
    array_reference                shift and go to state 95
    identifier                     shift and go to state 99
    type                           shift and go to state 96

state 62

    (39) binop_expression -> binop AND . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 100
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 63

    (38) binop_expression -> binop OR . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 101
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 64

    (45) binop_expression -> binop GT . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 102
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 65

    (41) binop_expression -> binop RSHIFT . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 103
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 66

    (33) binop_expression -> binop DIVIDE . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 104
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 67

    (42) binop_expression -> binop LOGOR . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 105
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 68

    (43) binop_expression -> binop LOGAND . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 106
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 69

    (47) binop_expression -> binop GE . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 107
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 70

    (34) binop_expression -> binop TIMES . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 108
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 71

    (44) binop_expression -> binop LT . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 109
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 72

    (46) binop_expression -> binop LE . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 110
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 73

    (35) binop_expression -> binop PLUS . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 111
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 74

    (40) binop_expression -> binop LSHIFT . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 112
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 75

    (48) binop_expression -> binop EQ . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 113
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 76

    (36) binop_expression -> binop MINUS . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 114
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 77

    (49) binop_expression -> binop NE . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 115
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 78

    (37) binop_expression -> binop MOD . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 116
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 79

    (65) compound -> LBRACE top_level . RBRACE
    (2) top_level -> top_level . comment
    (3) top_level -> top_level . function_declaration
    (4) top_level -> top_level . declaration
    (5) top_level -> top_level . compound
    (6) top_level -> top_level . assignment_expression_semi
    (7) top_level -> top_level . expr
    (8) top_level -> top_level . for_loop
    (9) top_level -> top_level . include
    (11) comment -> . COMMENT
    (67) function_declaration -> . typeid arglist SEMI
    (68) function_declaration -> . typeid arglist compound
    (69) function_declaration -> . function_call SEMI
    (70) declaration -> . typeid SEMI
    (71) declaration -> . array_typeid SEMI
    (65) compound -> . LBRACE top_level RBRACE
    (25) assignment_expression_semi -> . assignment_expression SEMI
    (85) expr -> . binop
    (54) for_loop -> . FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound
    (89) include -> . PPHASH INCLUDE STRING_LITERAL
    (72) typeid -> . type identifier
    (66) function_call -> . identifier arglist
    (73) array_typeid -> . type identifier subscript_list
    (22) assignment_expression -> . typeid assignment_operator expr
    (23) assignment_expression -> . identifier assignment_operator expr
    (24) assignment_expression -> . array_reference assignment_operator expr
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (86) type -> . native_type
    (87) type -> . native_type TIMES
    (88) identifier -> . ID
    (53) array_reference -> . identifier subscript_list
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (74) native_type -> . VOID
    (75) native_type -> . SIZE_T
    (76) native_type -> . UNKNOWN
    (77) native_type -> . CHAR
    (78) native_type -> . SHORT
    (79) native_type -> . INT
    (80) native_type -> . LONG
    (81) native_type -> . FLOAT
    (82) native_type -> . DOUBLE
    (83) native_type -> . SIGNED
    (84) native_type -> . UNSIGNED
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    RBRACE          shift and go to state 117
    COMMENT         shift and go to state 19
    LBRACE          shift and go to state 29
    FOR             shift and go to state 27
    PPHASH          shift and go to state 38
    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    VOID            shift and go to state 9
    SIZE_T          shift and go to state 46
    UNKNOWN         shift and go to state 8
    CHAR            shift and go to state 13
    SHORT           shift and go to state 5
    INT             shift and go to state 39
    LONG            shift and go to state 15
    FLOAT           shift and go to state 41
    DOUBLE          shift and go to state 45
    SIGNED          shift and go to state 42
    UNSIGNED        shift and go to state 43
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    comment                        shift and go to state 4
    unary_token_before             shift and go to state 7
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    compound                       shift and go to state 10
    function_call                  shift and go to state 11
    binop_expression               shift and go to state 12
    native_type                    shift and go to state 16
    array_reference                shift and go to state 22
    include                        shift and go to state 23
    type                           shift and go to state 24
    array_typeid                   shift and go to state 44
    for_loop                       shift and go to state 25
    assignment_expression          shift and go to state 26
    binop                          shift and go to state 28
    declaration                    shift and go to state 31
    typeid                         shift and go to state 34
    term                           shift and go to state 35
    assignment_expression_semi     shift and go to state 36
    function_declaration           shift and go to state 37
    expr                           shift and go to state 40
    identifier                     shift and go to state 47

state 80

    (30) binop -> LPAREN binop_expression . RPAREN
    (31) binop -> binop_expression .

    RPAREN          shift and go to state 118
    DIVIDE          reduce using rule 31 (binop -> binop_expression .)
    TIMES           reduce using rule 31 (binop -> binop_expression .)
    PLUS            reduce using rule 31 (binop -> binop_expression .)
    MINUS           reduce using rule 31 (binop -> binop_expression .)
    MOD             reduce using rule 31 (binop -> binop_expression .)
    OR              reduce using rule 31 (binop -> binop_expression .)
    AND             reduce using rule 31 (binop -> binop_expression .)
    LSHIFT          reduce using rule 31 (binop -> binop_expression .)
    RSHIFT          reduce using rule 31 (binop -> binop_expression .)
    LOGOR           reduce using rule 31 (binop -> binop_expression .)
    LOGAND          reduce using rule 31 (binop -> binop_expression .)
    LT              reduce using rule 31 (binop -> binop_expression .)
    GT              reduce using rule 31 (binop -> binop_expression .)
    LE              reduce using rule 31 (binop -> binop_expression .)
    GE              reduce using rule 31 (binop -> binop_expression .)
    EQ              reduce using rule 31 (binop -> binop_expression .)
    NE              reduce using rule 31 (binop -> binop_expression .)


state 81

    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77


state 82

    (70) declaration -> typeid SEMI .

    COMMENT         reduce using rule 70 (declaration -> typeid SEMI .)
    LBRACE          reduce using rule 70 (declaration -> typeid SEMI .)
    FOR             reduce using rule 70 (declaration -> typeid SEMI .)
    PPHASH          reduce using rule 70 (declaration -> typeid SEMI .)
    LPAREN          reduce using rule 70 (declaration -> typeid SEMI .)
    ID              reduce using rule 70 (declaration -> typeid SEMI .)
    VOID            reduce using rule 70 (declaration -> typeid SEMI .)
    SIZE_T          reduce using rule 70 (declaration -> typeid SEMI .)
    UNKNOWN         reduce using rule 70 (declaration -> typeid SEMI .)
    CHAR            reduce using rule 70 (declaration -> typeid SEMI .)
    SHORT           reduce using rule 70 (declaration -> typeid SEMI .)
    INT             reduce using rule 70 (declaration -> typeid SEMI .)
    LONG            reduce using rule 70 (declaration -> typeid SEMI .)
    FLOAT           reduce using rule 70 (declaration -> typeid SEMI .)
    DOUBLE          reduce using rule 70 (declaration -> typeid SEMI .)
    SIGNED          reduce using rule 70 (declaration -> typeid SEMI .)
    UNSIGNED        reduce using rule 70 (declaration -> typeid SEMI .)
    INT_CONST       reduce using rule 70 (declaration -> typeid SEMI .)
    FLOAT_CONST     reduce using rule 70 (declaration -> typeid SEMI .)
    STRING_LITERAL  reduce using rule 70 (declaration -> typeid SEMI .)
    MINUS           reduce using rule 70 (declaration -> typeid SEMI .)
    LOGNOT          reduce using rule 70 (declaration -> typeid SEMI .)
    $end            reduce using rule 70 (declaration -> typeid SEMI .)
    RBRACE          reduce using rule 70 (declaration -> typeid SEMI .)


state 83

    (22) assignment_expression -> typeid assignment_operator . expr
    (85) expr -> . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 28
    expr                           shift and go to state 119
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 51
    unary_token_before             shift and go to state 7
    function_call                  shift and go to state 49

state 84

    (17) arglist -> LPAREN . arg_params RPAREN
    (12) arg_params -> . term COMMA arg_params
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . binop
    (15) arg_params -> . typeid
    (16) arg_params -> . empty
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (72) typeid -> . type identifier
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (90) empty -> .
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (86) type -> . native_type
    (87) type -> . native_type TIMES
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT
    (74) native_type -> . VOID
    (75) native_type -> . SIZE_T
    (76) native_type -> . UNKNOWN
    (77) native_type -> . CHAR
    (78) native_type -> . SHORT
    (79) native_type -> . INT
    (80) native_type -> . LONG
    (81) native_type -> . FLOAT
    (82) native_type -> . DOUBLE
    (83) native_type -> . SIGNED
    (84) native_type -> . UNSIGNED

    LPAREN          shift and go to state 30
    RPAREN          reduce using rule 90 (empty -> .)
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14
    VOID            shift and go to state 9
    SIZE_T          shift and go to state 46
    UNKNOWN         shift and go to state 8
    CHAR            shift and go to state 13
    SHORT           shift and go to state 5
    INT             shift and go to state 39
    LONG            shift and go to state 15
    FLOAT           shift and go to state 41
    DOUBLE          shift and go to state 45
    SIGNED          shift and go to state 42
    UNSIGNED        shift and go to state 43

    typeid                         shift and go to state 123
    term                           shift and go to state 124
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 122
    unary_token_before             shift and go to state 7
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    native_type                    shift and go to state 16
    identifier                     shift and go to state 51
    type                           shift and go to state 96
    empty                          shift and go to state 121
    arg_params                     shift and go to state 120

state 85

    (67) function_declaration -> typeid arglist . SEMI
    (68) function_declaration -> typeid arglist . compound
    (65) compound -> . LBRACE top_level RBRACE

    SEMI            shift and go to state 125
    LBRACE          shift and go to state 29

    compound                       shift and go to state 126

state 86

    (89) include -> PPHASH INCLUDE . STRING_LITERAL

    STRING_LITERAL  shift and go to state 127


state 87

    (71) declaration -> array_typeid SEMI .

    COMMENT         reduce using rule 71 (declaration -> array_typeid SEMI .)
    LBRACE          reduce using rule 71 (declaration -> array_typeid SEMI .)
    FOR             reduce using rule 71 (declaration -> array_typeid SEMI .)
    PPHASH          reduce using rule 71 (declaration -> array_typeid SEMI .)
    LPAREN          reduce using rule 71 (declaration -> array_typeid SEMI .)
    ID              reduce using rule 71 (declaration -> array_typeid SEMI .)
    VOID            reduce using rule 71 (declaration -> array_typeid SEMI .)
    SIZE_T          reduce using rule 71 (declaration -> array_typeid SEMI .)
    UNKNOWN         reduce using rule 71 (declaration -> array_typeid SEMI .)
    CHAR            reduce using rule 71 (declaration -> array_typeid SEMI .)
    SHORT           reduce using rule 71 (declaration -> array_typeid SEMI .)
    INT             reduce using rule 71 (declaration -> array_typeid SEMI .)
    LONG            reduce using rule 71 (declaration -> array_typeid SEMI .)
    FLOAT           reduce using rule 71 (declaration -> array_typeid SEMI .)
    DOUBLE          reduce using rule 71 (declaration -> array_typeid SEMI .)
    SIGNED          reduce using rule 71 (declaration -> array_typeid SEMI .)
    UNSIGNED        reduce using rule 71 (declaration -> array_typeid SEMI .)
    INT_CONST       reduce using rule 71 (declaration -> array_typeid SEMI .)
    FLOAT_CONST     reduce using rule 71 (declaration -> array_typeid SEMI .)
    STRING_LITERAL  reduce using rule 71 (declaration -> array_typeid SEMI .)
    MINUS           reduce using rule 71 (declaration -> array_typeid SEMI .)
    LOGNOT          reduce using rule 71 (declaration -> array_typeid SEMI .)
    $end            reduce using rule 71 (declaration -> array_typeid SEMI .)
    RBRACE          reduce using rule 71 (declaration -> array_typeid SEMI .)


state 88

    (66) function_call -> identifier arglist .

    DIVIDE          reduce using rule 66 (function_call -> identifier arglist .)
    TIMES           reduce using rule 66 (function_call -> identifier arglist .)
    PLUS            reduce using rule 66 (function_call -> identifier arglist .)
    MINUS           reduce using rule 66 (function_call -> identifier arglist .)
    MOD             reduce using rule 66 (function_call -> identifier arglist .)
    OR              reduce using rule 66 (function_call -> identifier arglist .)
    AND             reduce using rule 66 (function_call -> identifier arglist .)
    LSHIFT          reduce using rule 66 (function_call -> identifier arglist .)
    RSHIFT          reduce using rule 66 (function_call -> identifier arglist .)
    LOGOR           reduce using rule 66 (function_call -> identifier arglist .)
    LOGAND          reduce using rule 66 (function_call -> identifier arglist .)
    LT              reduce using rule 66 (function_call -> identifier arglist .)
    GT              reduce using rule 66 (function_call -> identifier arglist .)
    LE              reduce using rule 66 (function_call -> identifier arglist .)
    GE              reduce using rule 66 (function_call -> identifier arglist .)
    EQ              reduce using rule 66 (function_call -> identifier arglist .)
    NE              reduce using rule 66 (function_call -> identifier arglist .)
    COMMENT         reduce using rule 66 (function_call -> identifier arglist .)
    LBRACE          reduce using rule 66 (function_call -> identifier arglist .)
    FOR             reduce using rule 66 (function_call -> identifier arglist .)
    PPHASH          reduce using rule 66 (function_call -> identifier arglist .)
    LPAREN          reduce using rule 66 (function_call -> identifier arglist .)
    ID              reduce using rule 66 (function_call -> identifier arglist .)
    VOID            reduce using rule 66 (function_call -> identifier arglist .)
    SIZE_T          reduce using rule 66 (function_call -> identifier arglist .)
    UNKNOWN         reduce using rule 66 (function_call -> identifier arglist .)
    CHAR            reduce using rule 66 (function_call -> identifier arglist .)
    SHORT           reduce using rule 66 (function_call -> identifier arglist .)
    INT             reduce using rule 66 (function_call -> identifier arglist .)
    LONG            reduce using rule 66 (function_call -> identifier arglist .)
    FLOAT           reduce using rule 66 (function_call -> identifier arglist .)
    DOUBLE          reduce using rule 66 (function_call -> identifier arglist .)
    SIGNED          reduce using rule 66 (function_call -> identifier arglist .)
    UNSIGNED        reduce using rule 66 (function_call -> identifier arglist .)
    INT_CONST       reduce using rule 66 (function_call -> identifier arglist .)
    FLOAT_CONST     reduce using rule 66 (function_call -> identifier arglist .)
    STRING_LITERAL  reduce using rule 66 (function_call -> identifier arglist .)
    LOGNOT          reduce using rule 66 (function_call -> identifier arglist .)
    $end            reduce using rule 66 (function_call -> identifier arglist .)
    RPAREN          reduce using rule 66 (function_call -> identifier arglist .)
    SEMI            reduce using rule 66 (function_call -> identifier arglist .)
    RBRACE          reduce using rule 66 (function_call -> identifier arglist .)
    RBRACKET        reduce using rule 66 (function_call -> identifier arglist .)
    COMMA           reduce using rule 66 (function_call -> identifier arglist .)
    PLUSPLUS        reduce using rule 66 (function_call -> identifier arglist .)
    MINUSMINUS      reduce using rule 66 (function_call -> identifier arglist .)


state 89

    (53) array_reference -> identifier subscript_list .

    DIVIDE          reduce using rule 53 (array_reference -> identifier subscript_list .)
    TIMES           reduce using rule 53 (array_reference -> identifier subscript_list .)
    PLUS            reduce using rule 53 (array_reference -> identifier subscript_list .)
    MINUS           reduce using rule 53 (array_reference -> identifier subscript_list .)
    MOD             reduce using rule 53 (array_reference -> identifier subscript_list .)
    OR              reduce using rule 53 (array_reference -> identifier subscript_list .)
    AND             reduce using rule 53 (array_reference -> identifier subscript_list .)
    LSHIFT          reduce using rule 53 (array_reference -> identifier subscript_list .)
    RSHIFT          reduce using rule 53 (array_reference -> identifier subscript_list .)
    LOGOR           reduce using rule 53 (array_reference -> identifier subscript_list .)
    LOGAND          reduce using rule 53 (array_reference -> identifier subscript_list .)
    LT              reduce using rule 53 (array_reference -> identifier subscript_list .)
    GT              reduce using rule 53 (array_reference -> identifier subscript_list .)
    LE              reduce using rule 53 (array_reference -> identifier subscript_list .)
    GE              reduce using rule 53 (array_reference -> identifier subscript_list .)
    EQ              reduce using rule 53 (array_reference -> identifier subscript_list .)
    NE              reduce using rule 53 (array_reference -> identifier subscript_list .)
    COMMENT         reduce using rule 53 (array_reference -> identifier subscript_list .)
    LBRACE          reduce using rule 53 (array_reference -> identifier subscript_list .)
    FOR             reduce using rule 53 (array_reference -> identifier subscript_list .)
    PPHASH          reduce using rule 53 (array_reference -> identifier subscript_list .)
    LPAREN          reduce using rule 53 (array_reference -> identifier subscript_list .)
    ID              reduce using rule 53 (array_reference -> identifier subscript_list .)
    VOID            reduce using rule 53 (array_reference -> identifier subscript_list .)
    SIZE_T          reduce using rule 53 (array_reference -> identifier subscript_list .)
    UNKNOWN         reduce using rule 53 (array_reference -> identifier subscript_list .)
    CHAR            reduce using rule 53 (array_reference -> identifier subscript_list .)
    SHORT           reduce using rule 53 (array_reference -> identifier subscript_list .)
    INT             reduce using rule 53 (array_reference -> identifier subscript_list .)
    LONG            reduce using rule 53 (array_reference -> identifier subscript_list .)
    FLOAT           reduce using rule 53 (array_reference -> identifier subscript_list .)
    DOUBLE          reduce using rule 53 (array_reference -> identifier subscript_list .)
    SIGNED          reduce using rule 53 (array_reference -> identifier subscript_list .)
    UNSIGNED        reduce using rule 53 (array_reference -> identifier subscript_list .)
    INT_CONST       reduce using rule 53 (array_reference -> identifier subscript_list .)
    FLOAT_CONST     reduce using rule 53 (array_reference -> identifier subscript_list .)
    STRING_LITERAL  reduce using rule 53 (array_reference -> identifier subscript_list .)
    LOGNOT          reduce using rule 53 (array_reference -> identifier subscript_list .)
    $end            reduce using rule 53 (array_reference -> identifier subscript_list .)
    RPAREN          reduce using rule 53 (array_reference -> identifier subscript_list .)
    SEMI            reduce using rule 53 (array_reference -> identifier subscript_list .)
    RBRACE          reduce using rule 53 (array_reference -> identifier subscript_list .)
    RBRACKET        reduce using rule 53 (array_reference -> identifier subscript_list .)
    EQUALS          reduce using rule 53 (array_reference -> identifier subscript_list .)
    PLUSEQUALS      reduce using rule 53 (array_reference -> identifier subscript_list .)
    MINUSEQUALS     reduce using rule 53 (array_reference -> identifier subscript_list .)
    TIMESEQUALS     reduce using rule 53 (array_reference -> identifier subscript_list .)
    COMMA           reduce using rule 53 (array_reference -> identifier subscript_list .)
    PLUSPLUS        reduce using rule 53 (array_reference -> identifier subscript_list .)
    MINUSMINUS      reduce using rule 53 (array_reference -> identifier subscript_list .)


state 90

    (50) subscript -> LBRACKET . expr RBRACKET
    (85) expr -> . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 28
    expr                           shift and go to state 128
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 91

    (23) assignment_expression -> identifier assignment_operator . expr
    (85) expr -> . binop
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 28
    expr                           shift and go to state 129
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    identifier                     shift and go to state 51
    function_call                  shift and go to state 49

state 92

    (51) subscript_list -> subscript .
    (52) subscript_list -> subscript . subscript_list
    (51) subscript_list -> . subscript
    (52) subscript_list -> . subscript subscript_list
    (50) subscript -> . LBRACKET expr RBRACKET

    EQUALS          reduce using rule 51 (subscript_list -> subscript .)
    PLUSEQUALS      reduce using rule 51 (subscript_list -> subscript .)
    MINUSEQUALS     reduce using rule 51 (subscript_list -> subscript .)
    TIMESEQUALS     reduce using rule 51 (subscript_list -> subscript .)
    DIVIDE          reduce using rule 51 (subscript_list -> subscript .)
    TIMES           reduce using rule 51 (subscript_list -> subscript .)
    PLUS            reduce using rule 51 (subscript_list -> subscript .)
    MINUS           reduce using rule 51 (subscript_list -> subscript .)
    MOD             reduce using rule 51 (subscript_list -> subscript .)
    OR              reduce using rule 51 (subscript_list -> subscript .)
    AND             reduce using rule 51 (subscript_list -> subscript .)
    LSHIFT          reduce using rule 51 (subscript_list -> subscript .)
    RSHIFT          reduce using rule 51 (subscript_list -> subscript .)
    LOGOR           reduce using rule 51 (subscript_list -> subscript .)
    LOGAND          reduce using rule 51 (subscript_list -> subscript .)
    LT              reduce using rule 51 (subscript_list -> subscript .)
    GT              reduce using rule 51 (subscript_list -> subscript .)
    LE              reduce using rule 51 (subscript_list -> subscript .)
    GE              reduce using rule 51 (subscript_list -> subscript .)
    EQ              reduce using rule 51 (subscript_list -> subscript .)
    NE              reduce using rule 51 (subscript_list -> subscript .)
    COMMENT         reduce using rule 51 (subscript_list -> subscript .)
    LBRACE          reduce using rule 51 (subscript_list -> subscript .)
    FOR             reduce using rule 51 (subscript_list -> subscript .)
    PPHASH          reduce using rule 51 (subscript_list -> subscript .)
    LPAREN          reduce using rule 51 (subscript_list -> subscript .)
    ID              reduce using rule 51 (subscript_list -> subscript .)
    VOID            reduce using rule 51 (subscript_list -> subscript .)
    SIZE_T          reduce using rule 51 (subscript_list -> subscript .)
    UNKNOWN         reduce using rule 51 (subscript_list -> subscript .)
    CHAR            reduce using rule 51 (subscript_list -> subscript .)
    SHORT           reduce using rule 51 (subscript_list -> subscript .)
    INT             reduce using rule 51 (subscript_list -> subscript .)
    LONG            reduce using rule 51 (subscript_list -> subscript .)
    FLOAT           reduce using rule 51 (subscript_list -> subscript .)
    DOUBLE          reduce using rule 51 (subscript_list -> subscript .)
    SIGNED          reduce using rule 51 (subscript_list -> subscript .)
    UNSIGNED        reduce using rule 51 (subscript_list -> subscript .)
    INT_CONST       reduce using rule 51 (subscript_list -> subscript .)
    FLOAT_CONST     reduce using rule 51 (subscript_list -> subscript .)
    STRING_LITERAL  reduce using rule 51 (subscript_list -> subscript .)
    LOGNOT          reduce using rule 51 (subscript_list -> subscript .)
    $end            reduce using rule 51 (subscript_list -> subscript .)
    RBRACE          reduce using rule 51 (subscript_list -> subscript .)
    RPAREN          reduce using rule 51 (subscript_list -> subscript .)
    SEMI            reduce using rule 51 (subscript_list -> subscript .)
    RBRACKET        reduce using rule 51 (subscript_list -> subscript .)
    COMMA           reduce using rule 51 (subscript_list -> subscript .)
    PLUSPLUS        reduce using rule 51 (subscript_list -> subscript .)
    MINUSMINUS      reduce using rule 51 (subscript_list -> subscript .)
    LBRACKET        shift and go to state 90

    subscript                      shift and go to state 92
    subscript_list                 shift and go to state 130

state 93

    (24) assignment_expression -> array_reference assignment_operator expr .

    SEMI            reduce using rule 24 (assignment_expression -> array_reference assignment_operator expr .)


state 94

    (73) array_typeid -> type identifier subscript_list .

    SEMI            reduce using rule 73 (array_typeid -> type identifier subscript_list .)


state 95

    (24) assignment_expression -> array_reference . assignment_operator expr
    (18) assignment_operator -> . EQUALS
    (19) assignment_operator -> . PLUSEQUALS
    (20) assignment_operator -> . MINUSEQUALS
    (21) assignment_operator -> . TIMESEQUALS

    EQUALS          shift and go to state 54
    PLUSEQUALS      shift and go to state 55
    MINUSEQUALS     shift and go to state 57
    TIMESEQUALS     shift and go to state 58

    assignment_operator            shift and go to state 56

state 96

    (72) typeid -> type . identifier
    (88) identifier -> . ID

    ID              shift and go to state 32

    identifier                     shift and go to state 131

state 97

    (54) for_loop -> FOR LPAREN assignment_expression . SEMI binop SEMI increment RPAREN compound

    SEMI            shift and go to state 132


state 98

    (22) assignment_expression -> typeid . assignment_operator expr
    (18) assignment_operator -> . EQUALS
    (19) assignment_operator -> . PLUSEQUALS
    (20) assignment_operator -> . MINUSEQUALS
    (21) assignment_operator -> . TIMESEQUALS

    EQUALS          shift and go to state 54
    PLUSEQUALS      shift and go to state 55
    MINUSEQUALS     shift and go to state 57
    TIMESEQUALS     shift and go to state 58

    assignment_operator            shift and go to state 83

state 99

    (23) assignment_expression -> identifier . assignment_operator expr
    (53) array_reference -> identifier . subscript_list
    (18) assignment_operator -> . EQUALS
    (19) assignment_operator -> . PLUSEQUALS
    (20) assignment_operator -> . MINUSEQUALS
    (21) assignment_operator -> . TIMESEQUALS
    (51) subscript_list -> . subscript
    (52) subscript_list -> . subscript subscript_list
    (50) subscript -> . LBRACKET expr RBRACKET

    EQUALS          shift and go to state 54
    PLUSEQUALS      shift and go to state 55
    MINUSEQUALS     shift and go to state 57
    TIMESEQUALS     shift and go to state 58
    LBRACKET        shift and go to state 90

    subscript                      shift and go to state 92
    subscript_list                 shift and go to state 89
    assignment_operator            shift and go to state 91

state 100

    (39) binop_expression -> binop AND binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 39 (binop_expression -> binop AND binop .)
    LBRACE          reduce using rule 39 (binop_expression -> binop AND binop .)
    FOR             reduce using rule 39 (binop_expression -> binop AND binop .)
    PPHASH          reduce using rule 39 (binop_expression -> binop AND binop .)
    LPAREN          reduce using rule 39 (binop_expression -> binop AND binop .)
    ID              reduce using rule 39 (binop_expression -> binop AND binop .)
    VOID            reduce using rule 39 (binop_expression -> binop AND binop .)
    SIZE_T          reduce using rule 39 (binop_expression -> binop AND binop .)
    UNKNOWN         reduce using rule 39 (binop_expression -> binop AND binop .)
    CHAR            reduce using rule 39 (binop_expression -> binop AND binop .)
    SHORT           reduce using rule 39 (binop_expression -> binop AND binop .)
    INT             reduce using rule 39 (binop_expression -> binop AND binop .)
    LONG            reduce using rule 39 (binop_expression -> binop AND binop .)
    FLOAT           reduce using rule 39 (binop_expression -> binop AND binop .)
    DOUBLE          reduce using rule 39 (binop_expression -> binop AND binop .)
    SIGNED          reduce using rule 39 (binop_expression -> binop AND binop .)
    UNSIGNED        reduce using rule 39 (binop_expression -> binop AND binop .)
    INT_CONST       reduce using rule 39 (binop_expression -> binop AND binop .)
    FLOAT_CONST     reduce using rule 39 (binop_expression -> binop AND binop .)
    STRING_LITERAL  reduce using rule 39 (binop_expression -> binop AND binop .)
    LOGNOT          reduce using rule 39 (binop_expression -> binop AND binop .)
    $end            reduce using rule 39 (binop_expression -> binop AND binop .)
    RPAREN          reduce using rule 39 (binop_expression -> binop AND binop .)
    SEMI            reduce using rule 39 (binop_expression -> binop AND binop .)
    RBRACE          reduce using rule 39 (binop_expression -> binop AND binop .)
    RBRACKET        reduce using rule 39 (binop_expression -> binop AND binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! TIMES           [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! PLUS            [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! MINUS           [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! MOD             [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! OR              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! AND             [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! LSHIFT          [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! RSHIFT          [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! LOGOR           [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! LOGAND          [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! LT              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! GT              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! LE              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! GE              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! EQ              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]
  ! NE              [ reduce using rule 39 (binop_expression -> binop AND binop .) ]


state 101

    (38) binop_expression -> binop OR binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 38 (binop_expression -> binop OR binop .)
    LBRACE          reduce using rule 38 (binop_expression -> binop OR binop .)
    FOR             reduce using rule 38 (binop_expression -> binop OR binop .)
    PPHASH          reduce using rule 38 (binop_expression -> binop OR binop .)
    LPAREN          reduce using rule 38 (binop_expression -> binop OR binop .)
    ID              reduce using rule 38 (binop_expression -> binop OR binop .)
    VOID            reduce using rule 38 (binop_expression -> binop OR binop .)
    SIZE_T          reduce using rule 38 (binop_expression -> binop OR binop .)
    UNKNOWN         reduce using rule 38 (binop_expression -> binop OR binop .)
    CHAR            reduce using rule 38 (binop_expression -> binop OR binop .)
    SHORT           reduce using rule 38 (binop_expression -> binop OR binop .)
    INT             reduce using rule 38 (binop_expression -> binop OR binop .)
    LONG            reduce using rule 38 (binop_expression -> binop OR binop .)
    FLOAT           reduce using rule 38 (binop_expression -> binop OR binop .)
    DOUBLE          reduce using rule 38 (binop_expression -> binop OR binop .)
    SIGNED          reduce using rule 38 (binop_expression -> binop OR binop .)
    UNSIGNED        reduce using rule 38 (binop_expression -> binop OR binop .)
    INT_CONST       reduce using rule 38 (binop_expression -> binop OR binop .)
    FLOAT_CONST     reduce using rule 38 (binop_expression -> binop OR binop .)
    STRING_LITERAL  reduce using rule 38 (binop_expression -> binop OR binop .)
    LOGNOT          reduce using rule 38 (binop_expression -> binop OR binop .)
    $end            reduce using rule 38 (binop_expression -> binop OR binop .)
    RPAREN          reduce using rule 38 (binop_expression -> binop OR binop .)
    SEMI            reduce using rule 38 (binop_expression -> binop OR binop .)
    RBRACE          reduce using rule 38 (binop_expression -> binop OR binop .)
    RBRACKET        reduce using rule 38 (binop_expression -> binop OR binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! TIMES           [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! PLUS            [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! MINUS           [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! MOD             [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! OR              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! AND             [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! LSHIFT          [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! RSHIFT          [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! LOGOR           [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! LOGAND          [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! LT              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! GT              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! LE              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! GE              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! EQ              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]
  ! NE              [ reduce using rule 38 (binop_expression -> binop OR binop .) ]


state 102

    (45) binop_expression -> binop GT binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 45 (binop_expression -> binop GT binop .)
    LBRACE          reduce using rule 45 (binop_expression -> binop GT binop .)
    FOR             reduce using rule 45 (binop_expression -> binop GT binop .)
    PPHASH          reduce using rule 45 (binop_expression -> binop GT binop .)
    LPAREN          reduce using rule 45 (binop_expression -> binop GT binop .)
    ID              reduce using rule 45 (binop_expression -> binop GT binop .)
    VOID            reduce using rule 45 (binop_expression -> binop GT binop .)
    SIZE_T          reduce using rule 45 (binop_expression -> binop GT binop .)
    UNKNOWN         reduce using rule 45 (binop_expression -> binop GT binop .)
    CHAR            reduce using rule 45 (binop_expression -> binop GT binop .)
    SHORT           reduce using rule 45 (binop_expression -> binop GT binop .)
    INT             reduce using rule 45 (binop_expression -> binop GT binop .)
    LONG            reduce using rule 45 (binop_expression -> binop GT binop .)
    FLOAT           reduce using rule 45 (binop_expression -> binop GT binop .)
    DOUBLE          reduce using rule 45 (binop_expression -> binop GT binop .)
    SIGNED          reduce using rule 45 (binop_expression -> binop GT binop .)
    UNSIGNED        reduce using rule 45 (binop_expression -> binop GT binop .)
    INT_CONST       reduce using rule 45 (binop_expression -> binop GT binop .)
    FLOAT_CONST     reduce using rule 45 (binop_expression -> binop GT binop .)
    STRING_LITERAL  reduce using rule 45 (binop_expression -> binop GT binop .)
    LOGNOT          reduce using rule 45 (binop_expression -> binop GT binop .)
    $end            reduce using rule 45 (binop_expression -> binop GT binop .)
    RPAREN          reduce using rule 45 (binop_expression -> binop GT binop .)
    SEMI            reduce using rule 45 (binop_expression -> binop GT binop .)
    RBRACE          reduce using rule 45 (binop_expression -> binop GT binop .)
    RBRACKET        reduce using rule 45 (binop_expression -> binop GT binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! TIMES           [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! PLUS            [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! MINUS           [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! MOD             [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! OR              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! AND             [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! LSHIFT          [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! RSHIFT          [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! LOGOR           [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! LOGAND          [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! LT              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! GT              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! LE              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! GE              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! EQ              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]
  ! NE              [ reduce using rule 45 (binop_expression -> binop GT binop .) ]


state 103

    (41) binop_expression -> binop RSHIFT binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    LBRACE          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    FOR             reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    PPHASH          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    LPAREN          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    ID              reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    VOID            reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    SIZE_T          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    UNKNOWN         reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    CHAR            reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    SHORT           reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    INT             reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    LONG            reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    FLOAT           reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    DOUBLE          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    SIGNED          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    UNSIGNED        reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    INT_CONST       reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    FLOAT_CONST     reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    STRING_LITERAL  reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    LOGNOT          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    $end            reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    RPAREN          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    SEMI            reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    RBRACE          reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    RBRACKET        reduce using rule 41 (binop_expression -> binop RSHIFT binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! TIMES           [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! PLUS            [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! MINUS           [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! MOD             [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! OR              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! AND             [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! LSHIFT          [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! RSHIFT          [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! LOGOR           [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! LOGAND          [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! LT              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! GT              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! LE              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! GE              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! EQ              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]
  ! NE              [ reduce using rule 41 (binop_expression -> binop RSHIFT binop .) ]


state 104

    (33) binop_expression -> binop DIVIDE binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    DIVIDE          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    TIMES           reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    PLUS            reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    MINUS           reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    MOD             reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    OR              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    AND             reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LSHIFT          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    RSHIFT          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LOGOR           reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LOGAND          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LT              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    GT              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LE              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    GE              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    EQ              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    NE              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    COMMENT         reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LBRACE          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    FOR             reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    PPHASH          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LPAREN          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    ID              reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    VOID            reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    SIZE_T          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    UNKNOWN         reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    CHAR            reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    SHORT           reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    INT             reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LONG            reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    FLOAT           reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    DOUBLE          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    SIGNED          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    UNSIGNED        reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    INT_CONST       reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    FLOAT_CONST     reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    STRING_LITERAL  reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    LOGNOT          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    $end            reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    RPAREN          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    SEMI            reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    RBRACE          reduce using rule 33 (binop_expression -> binop DIVIDE binop .)
    RBRACKET        reduce using rule 33 (binop_expression -> binop DIVIDE binop .)

  ! DIVIDE          [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 76 ]
  ! MOD             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 63 ]
  ! AND             [ shift and go to state 62 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 65 ]
  ! LOGOR           [ shift and go to state 67 ]
  ! LOGAND          [ shift and go to state 68 ]
  ! LT              [ shift and go to state 71 ]
  ! GT              [ shift and go to state 64 ]
  ! LE              [ shift and go to state 72 ]
  ! GE              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 75 ]
  ! NE              [ shift and go to state 77 ]


state 105

    (42) binop_expression -> binop LOGOR binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    LBRACE          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    FOR             reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    PPHASH          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    LPAREN          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    ID              reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    VOID            reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    SIZE_T          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    UNKNOWN         reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    CHAR            reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    SHORT           reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    INT             reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    LONG            reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    FLOAT           reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    DOUBLE          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    SIGNED          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    UNSIGNED        reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    INT_CONST       reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    FLOAT_CONST     reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    STRING_LITERAL  reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    LOGNOT          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    $end            reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    RPAREN          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    SEMI            reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    RBRACE          reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    RBRACKET        reduce using rule 42 (binop_expression -> binop LOGOR binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! TIMES           [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! PLUS            [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! MINUS           [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! MOD             [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! OR              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! AND             [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! LSHIFT          [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! RSHIFT          [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! LOGOR           [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! LOGAND          [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! LT              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! GT              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! LE              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! GE              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! EQ              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]
  ! NE              [ reduce using rule 42 (binop_expression -> binop LOGOR binop .) ]


state 106

    (43) binop_expression -> binop LOGAND binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    LBRACE          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    FOR             reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    PPHASH          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    LPAREN          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    ID              reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    VOID            reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    SIZE_T          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    UNKNOWN         reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    CHAR            reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    SHORT           reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    INT             reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    LONG            reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    FLOAT           reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    DOUBLE          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    SIGNED          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    UNSIGNED        reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    INT_CONST       reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    FLOAT_CONST     reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    STRING_LITERAL  reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    LOGNOT          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    $end            reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    RPAREN          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    SEMI            reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    RBRACE          reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    RBRACKET        reduce using rule 43 (binop_expression -> binop LOGAND binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! TIMES           [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! PLUS            [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! MINUS           [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! MOD             [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! OR              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! AND             [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! LSHIFT          [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! RSHIFT          [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! LOGOR           [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! LOGAND          [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! LT              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! GT              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! LE              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! GE              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! EQ              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]
  ! NE              [ reduce using rule 43 (binop_expression -> binop LOGAND binop .) ]


state 107

    (47) binop_expression -> binop GE binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 47 (binop_expression -> binop GE binop .)
    LBRACE          reduce using rule 47 (binop_expression -> binop GE binop .)
    FOR             reduce using rule 47 (binop_expression -> binop GE binop .)
    PPHASH          reduce using rule 47 (binop_expression -> binop GE binop .)
    LPAREN          reduce using rule 47 (binop_expression -> binop GE binop .)
    ID              reduce using rule 47 (binop_expression -> binop GE binop .)
    VOID            reduce using rule 47 (binop_expression -> binop GE binop .)
    SIZE_T          reduce using rule 47 (binop_expression -> binop GE binop .)
    UNKNOWN         reduce using rule 47 (binop_expression -> binop GE binop .)
    CHAR            reduce using rule 47 (binop_expression -> binop GE binop .)
    SHORT           reduce using rule 47 (binop_expression -> binop GE binop .)
    INT             reduce using rule 47 (binop_expression -> binop GE binop .)
    LONG            reduce using rule 47 (binop_expression -> binop GE binop .)
    FLOAT           reduce using rule 47 (binop_expression -> binop GE binop .)
    DOUBLE          reduce using rule 47 (binop_expression -> binop GE binop .)
    SIGNED          reduce using rule 47 (binop_expression -> binop GE binop .)
    UNSIGNED        reduce using rule 47 (binop_expression -> binop GE binop .)
    INT_CONST       reduce using rule 47 (binop_expression -> binop GE binop .)
    FLOAT_CONST     reduce using rule 47 (binop_expression -> binop GE binop .)
    STRING_LITERAL  reduce using rule 47 (binop_expression -> binop GE binop .)
    LOGNOT          reduce using rule 47 (binop_expression -> binop GE binop .)
    $end            reduce using rule 47 (binop_expression -> binop GE binop .)
    RPAREN          reduce using rule 47 (binop_expression -> binop GE binop .)
    SEMI            reduce using rule 47 (binop_expression -> binop GE binop .)
    RBRACE          reduce using rule 47 (binop_expression -> binop GE binop .)
    RBRACKET        reduce using rule 47 (binop_expression -> binop GE binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! TIMES           [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! PLUS            [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! MINUS           [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! MOD             [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! OR              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! AND             [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! LSHIFT          [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! RSHIFT          [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! LOGOR           [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! LOGAND          [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! LT              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! GT              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! LE              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! GE              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! EQ              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]
  ! NE              [ reduce using rule 47 (binop_expression -> binop GE binop .) ]


state 108

    (34) binop_expression -> binop TIMES binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    DIVIDE          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    TIMES           reduce using rule 34 (binop_expression -> binop TIMES binop .)
    PLUS            reduce using rule 34 (binop_expression -> binop TIMES binop .)
    MINUS           reduce using rule 34 (binop_expression -> binop TIMES binop .)
    MOD             reduce using rule 34 (binop_expression -> binop TIMES binop .)
    OR              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    AND             reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LSHIFT          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    RSHIFT          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LOGOR           reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LOGAND          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LT              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    GT              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LE              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    GE              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    EQ              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    NE              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    COMMENT         reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LBRACE          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    FOR             reduce using rule 34 (binop_expression -> binop TIMES binop .)
    PPHASH          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LPAREN          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    ID              reduce using rule 34 (binop_expression -> binop TIMES binop .)
    VOID            reduce using rule 34 (binop_expression -> binop TIMES binop .)
    SIZE_T          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    UNKNOWN         reduce using rule 34 (binop_expression -> binop TIMES binop .)
    CHAR            reduce using rule 34 (binop_expression -> binop TIMES binop .)
    SHORT           reduce using rule 34 (binop_expression -> binop TIMES binop .)
    INT             reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LONG            reduce using rule 34 (binop_expression -> binop TIMES binop .)
    FLOAT           reduce using rule 34 (binop_expression -> binop TIMES binop .)
    DOUBLE          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    SIGNED          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    UNSIGNED        reduce using rule 34 (binop_expression -> binop TIMES binop .)
    INT_CONST       reduce using rule 34 (binop_expression -> binop TIMES binop .)
    FLOAT_CONST     reduce using rule 34 (binop_expression -> binop TIMES binop .)
    STRING_LITERAL  reduce using rule 34 (binop_expression -> binop TIMES binop .)
    LOGNOT          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    $end            reduce using rule 34 (binop_expression -> binop TIMES binop .)
    RPAREN          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    SEMI            reduce using rule 34 (binop_expression -> binop TIMES binop .)
    RBRACE          reduce using rule 34 (binop_expression -> binop TIMES binop .)
    RBRACKET        reduce using rule 34 (binop_expression -> binop TIMES binop .)

  ! DIVIDE          [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 76 ]
  ! MOD             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 63 ]
  ! AND             [ shift and go to state 62 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 65 ]
  ! LOGOR           [ shift and go to state 67 ]
  ! LOGAND          [ shift and go to state 68 ]
  ! LT              [ shift and go to state 71 ]
  ! GT              [ shift and go to state 64 ]
  ! LE              [ shift and go to state 72 ]
  ! GE              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 75 ]
  ! NE              [ shift and go to state 77 ]


state 109

    (44) binop_expression -> binop LT binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 44 (binop_expression -> binop LT binop .)
    LBRACE          reduce using rule 44 (binop_expression -> binop LT binop .)
    FOR             reduce using rule 44 (binop_expression -> binop LT binop .)
    PPHASH          reduce using rule 44 (binop_expression -> binop LT binop .)
    LPAREN          reduce using rule 44 (binop_expression -> binop LT binop .)
    ID              reduce using rule 44 (binop_expression -> binop LT binop .)
    VOID            reduce using rule 44 (binop_expression -> binop LT binop .)
    SIZE_T          reduce using rule 44 (binop_expression -> binop LT binop .)
    UNKNOWN         reduce using rule 44 (binop_expression -> binop LT binop .)
    CHAR            reduce using rule 44 (binop_expression -> binop LT binop .)
    SHORT           reduce using rule 44 (binop_expression -> binop LT binop .)
    INT             reduce using rule 44 (binop_expression -> binop LT binop .)
    LONG            reduce using rule 44 (binop_expression -> binop LT binop .)
    FLOAT           reduce using rule 44 (binop_expression -> binop LT binop .)
    DOUBLE          reduce using rule 44 (binop_expression -> binop LT binop .)
    SIGNED          reduce using rule 44 (binop_expression -> binop LT binop .)
    UNSIGNED        reduce using rule 44 (binop_expression -> binop LT binop .)
    INT_CONST       reduce using rule 44 (binop_expression -> binop LT binop .)
    FLOAT_CONST     reduce using rule 44 (binop_expression -> binop LT binop .)
    STRING_LITERAL  reduce using rule 44 (binop_expression -> binop LT binop .)
    LOGNOT          reduce using rule 44 (binop_expression -> binop LT binop .)
    $end            reduce using rule 44 (binop_expression -> binop LT binop .)
    RPAREN          reduce using rule 44 (binop_expression -> binop LT binop .)
    SEMI            reduce using rule 44 (binop_expression -> binop LT binop .)
    RBRACE          reduce using rule 44 (binop_expression -> binop LT binop .)
    RBRACKET        reduce using rule 44 (binop_expression -> binop LT binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! TIMES           [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! PLUS            [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! MINUS           [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! MOD             [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! OR              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! AND             [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! LSHIFT          [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! RSHIFT          [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! LOGOR           [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! LOGAND          [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! LT              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! GT              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! LE              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! GE              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! EQ              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]
  ! NE              [ reduce using rule 44 (binop_expression -> binop LT binop .) ]


state 110

    (46) binop_expression -> binop LE binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 46 (binop_expression -> binop LE binop .)
    LBRACE          reduce using rule 46 (binop_expression -> binop LE binop .)
    FOR             reduce using rule 46 (binop_expression -> binop LE binop .)
    PPHASH          reduce using rule 46 (binop_expression -> binop LE binop .)
    LPAREN          reduce using rule 46 (binop_expression -> binop LE binop .)
    ID              reduce using rule 46 (binop_expression -> binop LE binop .)
    VOID            reduce using rule 46 (binop_expression -> binop LE binop .)
    SIZE_T          reduce using rule 46 (binop_expression -> binop LE binop .)
    UNKNOWN         reduce using rule 46 (binop_expression -> binop LE binop .)
    CHAR            reduce using rule 46 (binop_expression -> binop LE binop .)
    SHORT           reduce using rule 46 (binop_expression -> binop LE binop .)
    INT             reduce using rule 46 (binop_expression -> binop LE binop .)
    LONG            reduce using rule 46 (binop_expression -> binop LE binop .)
    FLOAT           reduce using rule 46 (binop_expression -> binop LE binop .)
    DOUBLE          reduce using rule 46 (binop_expression -> binop LE binop .)
    SIGNED          reduce using rule 46 (binop_expression -> binop LE binop .)
    UNSIGNED        reduce using rule 46 (binop_expression -> binop LE binop .)
    INT_CONST       reduce using rule 46 (binop_expression -> binop LE binop .)
    FLOAT_CONST     reduce using rule 46 (binop_expression -> binop LE binop .)
    STRING_LITERAL  reduce using rule 46 (binop_expression -> binop LE binop .)
    LOGNOT          reduce using rule 46 (binop_expression -> binop LE binop .)
    $end            reduce using rule 46 (binop_expression -> binop LE binop .)
    RPAREN          reduce using rule 46 (binop_expression -> binop LE binop .)
    SEMI            reduce using rule 46 (binop_expression -> binop LE binop .)
    RBRACE          reduce using rule 46 (binop_expression -> binop LE binop .)
    RBRACKET        reduce using rule 46 (binop_expression -> binop LE binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! TIMES           [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! PLUS            [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! MINUS           [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! MOD             [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! OR              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! AND             [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! LSHIFT          [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! RSHIFT          [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! LOGOR           [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! LOGAND          [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! LT              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! GT              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! LE              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! GE              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! EQ              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]
  ! NE              [ reduce using rule 46 (binop_expression -> binop LE binop .) ]


state 111

    (35) binop_expression -> binop PLUS binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    PLUS            reduce using rule 35 (binop_expression -> binop PLUS binop .)
    MINUS           reduce using rule 35 (binop_expression -> binop PLUS binop .)
    MOD             reduce using rule 35 (binop_expression -> binop PLUS binop .)
    OR              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    AND             reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LSHIFT          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    RSHIFT          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LOGOR           reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LOGAND          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LT              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    GT              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LE              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    GE              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    EQ              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    NE              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    COMMENT         reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LBRACE          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    FOR             reduce using rule 35 (binop_expression -> binop PLUS binop .)
    PPHASH          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LPAREN          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    ID              reduce using rule 35 (binop_expression -> binop PLUS binop .)
    VOID            reduce using rule 35 (binop_expression -> binop PLUS binop .)
    SIZE_T          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    UNKNOWN         reduce using rule 35 (binop_expression -> binop PLUS binop .)
    CHAR            reduce using rule 35 (binop_expression -> binop PLUS binop .)
    SHORT           reduce using rule 35 (binop_expression -> binop PLUS binop .)
    INT             reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LONG            reduce using rule 35 (binop_expression -> binop PLUS binop .)
    FLOAT           reduce using rule 35 (binop_expression -> binop PLUS binop .)
    DOUBLE          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    SIGNED          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    UNSIGNED        reduce using rule 35 (binop_expression -> binop PLUS binop .)
    INT_CONST       reduce using rule 35 (binop_expression -> binop PLUS binop .)
    FLOAT_CONST     reduce using rule 35 (binop_expression -> binop PLUS binop .)
    STRING_LITERAL  reduce using rule 35 (binop_expression -> binop PLUS binop .)
    LOGNOT          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    $end            reduce using rule 35 (binop_expression -> binop PLUS binop .)
    RPAREN          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    SEMI            reduce using rule 35 (binop_expression -> binop PLUS binop .)
    RBRACE          reduce using rule 35 (binop_expression -> binop PLUS binop .)
    RBRACKET        reduce using rule 35 (binop_expression -> binop PLUS binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70

  ! DIVIDE          [ reduce using rule 35 (binop_expression -> binop PLUS binop .) ]
  ! TIMES           [ reduce using rule 35 (binop_expression -> binop PLUS binop .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 76 ]
  ! MOD             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 63 ]
  ! AND             [ shift and go to state 62 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 65 ]
  ! LOGOR           [ shift and go to state 67 ]
  ! LOGAND          [ shift and go to state 68 ]
  ! LT              [ shift and go to state 71 ]
  ! GT              [ shift and go to state 64 ]
  ! LE              [ shift and go to state 72 ]
  ! GE              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 75 ]
  ! NE              [ shift and go to state 77 ]


state 112

    (40) binop_expression -> binop LSHIFT binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    LBRACE          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    FOR             reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    PPHASH          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    LPAREN          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    ID              reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    VOID            reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    SIZE_T          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    UNKNOWN         reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    CHAR            reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    SHORT           reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    INT             reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    LONG            reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    FLOAT           reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    DOUBLE          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    SIGNED          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    UNSIGNED        reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    INT_CONST       reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    FLOAT_CONST     reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    STRING_LITERAL  reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    LOGNOT          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    $end            reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    RPAREN          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    SEMI            reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    RBRACE          reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    RBRACKET        reduce using rule 40 (binop_expression -> binop LSHIFT binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! TIMES           [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! PLUS            [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! MINUS           [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! MOD             [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! OR              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! AND             [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! LSHIFT          [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! RSHIFT          [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! LOGOR           [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! LOGAND          [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! LT              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! GT              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! LE              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! GE              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! EQ              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]
  ! NE              [ reduce using rule 40 (binop_expression -> binop LSHIFT binop .) ]


state 113

    (48) binop_expression -> binop EQ binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 48 (binop_expression -> binop EQ binop .)
    LBRACE          reduce using rule 48 (binop_expression -> binop EQ binop .)
    FOR             reduce using rule 48 (binop_expression -> binop EQ binop .)
    PPHASH          reduce using rule 48 (binop_expression -> binop EQ binop .)
    LPAREN          reduce using rule 48 (binop_expression -> binop EQ binop .)
    ID              reduce using rule 48 (binop_expression -> binop EQ binop .)
    VOID            reduce using rule 48 (binop_expression -> binop EQ binop .)
    SIZE_T          reduce using rule 48 (binop_expression -> binop EQ binop .)
    UNKNOWN         reduce using rule 48 (binop_expression -> binop EQ binop .)
    CHAR            reduce using rule 48 (binop_expression -> binop EQ binop .)
    SHORT           reduce using rule 48 (binop_expression -> binop EQ binop .)
    INT             reduce using rule 48 (binop_expression -> binop EQ binop .)
    LONG            reduce using rule 48 (binop_expression -> binop EQ binop .)
    FLOAT           reduce using rule 48 (binop_expression -> binop EQ binop .)
    DOUBLE          reduce using rule 48 (binop_expression -> binop EQ binop .)
    SIGNED          reduce using rule 48 (binop_expression -> binop EQ binop .)
    UNSIGNED        reduce using rule 48 (binop_expression -> binop EQ binop .)
    INT_CONST       reduce using rule 48 (binop_expression -> binop EQ binop .)
    FLOAT_CONST     reduce using rule 48 (binop_expression -> binop EQ binop .)
    STRING_LITERAL  reduce using rule 48 (binop_expression -> binop EQ binop .)
    LOGNOT          reduce using rule 48 (binop_expression -> binop EQ binop .)
    $end            reduce using rule 48 (binop_expression -> binop EQ binop .)
    RPAREN          reduce using rule 48 (binop_expression -> binop EQ binop .)
    SEMI            reduce using rule 48 (binop_expression -> binop EQ binop .)
    RBRACE          reduce using rule 48 (binop_expression -> binop EQ binop .)
    RBRACKET        reduce using rule 48 (binop_expression -> binop EQ binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! TIMES           [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! PLUS            [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! MINUS           [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! MOD             [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! OR              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! AND             [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! LSHIFT          [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! RSHIFT          [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! LOGOR           [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! LOGAND          [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! LT              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! GT              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! LE              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! GE              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! EQ              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]
  ! NE              [ reduce using rule 48 (binop_expression -> binop EQ binop .) ]


state 114

    (36) binop_expression -> binop MINUS binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    PLUS            reduce using rule 36 (binop_expression -> binop MINUS binop .)
    MINUS           reduce using rule 36 (binop_expression -> binop MINUS binop .)
    MOD             reduce using rule 36 (binop_expression -> binop MINUS binop .)
    OR              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    AND             reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LSHIFT          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    RSHIFT          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LOGOR           reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LOGAND          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LT              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    GT              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LE              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    GE              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    EQ              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    NE              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    COMMENT         reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LBRACE          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    FOR             reduce using rule 36 (binop_expression -> binop MINUS binop .)
    PPHASH          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LPAREN          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    ID              reduce using rule 36 (binop_expression -> binop MINUS binop .)
    VOID            reduce using rule 36 (binop_expression -> binop MINUS binop .)
    SIZE_T          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    UNKNOWN         reduce using rule 36 (binop_expression -> binop MINUS binop .)
    CHAR            reduce using rule 36 (binop_expression -> binop MINUS binop .)
    SHORT           reduce using rule 36 (binop_expression -> binop MINUS binop .)
    INT             reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LONG            reduce using rule 36 (binop_expression -> binop MINUS binop .)
    FLOAT           reduce using rule 36 (binop_expression -> binop MINUS binop .)
    DOUBLE          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    SIGNED          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    UNSIGNED        reduce using rule 36 (binop_expression -> binop MINUS binop .)
    INT_CONST       reduce using rule 36 (binop_expression -> binop MINUS binop .)
    FLOAT_CONST     reduce using rule 36 (binop_expression -> binop MINUS binop .)
    STRING_LITERAL  reduce using rule 36 (binop_expression -> binop MINUS binop .)
    LOGNOT          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    $end            reduce using rule 36 (binop_expression -> binop MINUS binop .)
    RPAREN          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    SEMI            reduce using rule 36 (binop_expression -> binop MINUS binop .)
    RBRACE          reduce using rule 36 (binop_expression -> binop MINUS binop .)
    RBRACKET        reduce using rule 36 (binop_expression -> binop MINUS binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70

  ! DIVIDE          [ reduce using rule 36 (binop_expression -> binop MINUS binop .) ]
  ! TIMES           [ reduce using rule 36 (binop_expression -> binop MINUS binop .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 76 ]
  ! MOD             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 63 ]
  ! AND             [ shift and go to state 62 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 65 ]
  ! LOGOR           [ shift and go to state 67 ]
  ! LOGAND          [ shift and go to state 68 ]
  ! LT              [ shift and go to state 71 ]
  ! GT              [ shift and go to state 64 ]
  ! LE              [ shift and go to state 72 ]
  ! GE              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 75 ]
  ! NE              [ shift and go to state 77 ]


state 115

    (49) binop_expression -> binop NE binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 49 (binop_expression -> binop NE binop .)
    LBRACE          reduce using rule 49 (binop_expression -> binop NE binop .)
    FOR             reduce using rule 49 (binop_expression -> binop NE binop .)
    PPHASH          reduce using rule 49 (binop_expression -> binop NE binop .)
    LPAREN          reduce using rule 49 (binop_expression -> binop NE binop .)
    ID              reduce using rule 49 (binop_expression -> binop NE binop .)
    VOID            reduce using rule 49 (binop_expression -> binop NE binop .)
    SIZE_T          reduce using rule 49 (binop_expression -> binop NE binop .)
    UNKNOWN         reduce using rule 49 (binop_expression -> binop NE binop .)
    CHAR            reduce using rule 49 (binop_expression -> binop NE binop .)
    SHORT           reduce using rule 49 (binop_expression -> binop NE binop .)
    INT             reduce using rule 49 (binop_expression -> binop NE binop .)
    LONG            reduce using rule 49 (binop_expression -> binop NE binop .)
    FLOAT           reduce using rule 49 (binop_expression -> binop NE binop .)
    DOUBLE          reduce using rule 49 (binop_expression -> binop NE binop .)
    SIGNED          reduce using rule 49 (binop_expression -> binop NE binop .)
    UNSIGNED        reduce using rule 49 (binop_expression -> binop NE binop .)
    INT_CONST       reduce using rule 49 (binop_expression -> binop NE binop .)
    FLOAT_CONST     reduce using rule 49 (binop_expression -> binop NE binop .)
    STRING_LITERAL  reduce using rule 49 (binop_expression -> binop NE binop .)
    LOGNOT          reduce using rule 49 (binop_expression -> binop NE binop .)
    $end            reduce using rule 49 (binop_expression -> binop NE binop .)
    RPAREN          reduce using rule 49 (binop_expression -> binop NE binop .)
    SEMI            reduce using rule 49 (binop_expression -> binop NE binop .)
    RBRACE          reduce using rule 49 (binop_expression -> binop NE binop .)
    RBRACKET        reduce using rule 49 (binop_expression -> binop NE binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! TIMES           [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! PLUS            [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! MINUS           [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! MOD             [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! OR              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! AND             [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! LSHIFT          [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! RSHIFT          [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! LOGOR           [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! LOGAND          [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! LT              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! GT              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! LE              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! GE              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! EQ              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]
  ! NE              [ reduce using rule 49 (binop_expression -> binop NE binop .) ]


state 116

    (37) binop_expression -> binop MOD binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    COMMENT         reduce using rule 37 (binop_expression -> binop MOD binop .)
    LBRACE          reduce using rule 37 (binop_expression -> binop MOD binop .)
    FOR             reduce using rule 37 (binop_expression -> binop MOD binop .)
    PPHASH          reduce using rule 37 (binop_expression -> binop MOD binop .)
    LPAREN          reduce using rule 37 (binop_expression -> binop MOD binop .)
    ID              reduce using rule 37 (binop_expression -> binop MOD binop .)
    VOID            reduce using rule 37 (binop_expression -> binop MOD binop .)
    SIZE_T          reduce using rule 37 (binop_expression -> binop MOD binop .)
    UNKNOWN         reduce using rule 37 (binop_expression -> binop MOD binop .)
    CHAR            reduce using rule 37 (binop_expression -> binop MOD binop .)
    SHORT           reduce using rule 37 (binop_expression -> binop MOD binop .)
    INT             reduce using rule 37 (binop_expression -> binop MOD binop .)
    LONG            reduce using rule 37 (binop_expression -> binop MOD binop .)
    FLOAT           reduce using rule 37 (binop_expression -> binop MOD binop .)
    DOUBLE          reduce using rule 37 (binop_expression -> binop MOD binop .)
    SIGNED          reduce using rule 37 (binop_expression -> binop MOD binop .)
    UNSIGNED        reduce using rule 37 (binop_expression -> binop MOD binop .)
    INT_CONST       reduce using rule 37 (binop_expression -> binop MOD binop .)
    FLOAT_CONST     reduce using rule 37 (binop_expression -> binop MOD binop .)
    STRING_LITERAL  reduce using rule 37 (binop_expression -> binop MOD binop .)
    LOGNOT          reduce using rule 37 (binop_expression -> binop MOD binop .)
    $end            reduce using rule 37 (binop_expression -> binop MOD binop .)
    RPAREN          reduce using rule 37 (binop_expression -> binop MOD binop .)
    SEMI            reduce using rule 37 (binop_expression -> binop MOD binop .)
    RBRACE          reduce using rule 37 (binop_expression -> binop MOD binop .)
    RBRACKET        reduce using rule 37 (binop_expression -> binop MOD binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77

  ! DIVIDE          [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! TIMES           [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! PLUS            [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! MINUS           [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! MOD             [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! OR              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! AND             [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! LSHIFT          [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! RSHIFT          [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! LOGOR           [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! LOGAND          [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! LT              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! GT              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! LE              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! GE              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! EQ              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]
  ! NE              [ reduce using rule 37 (binop_expression -> binop MOD binop .) ]


state 117

    (65) compound -> LBRACE top_level RBRACE .

    COMMENT         reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    LBRACE          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    FOR             reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    PPHASH          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    LPAREN          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    ID              reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    VOID            reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    SIZE_T          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    UNKNOWN         reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    CHAR            reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    SHORT           reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    INT             reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    LONG            reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    FLOAT           reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    DOUBLE          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    SIGNED          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    UNSIGNED        reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    INT_CONST       reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    FLOAT_CONST     reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    STRING_LITERAL  reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    MINUS           reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    LOGNOT          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    $end            reduce using rule 65 (compound -> LBRACE top_level RBRACE .)
    RBRACE          reduce using rule 65 (compound -> LBRACE top_level RBRACE .)


state 118

    (30) binop -> LPAREN binop_expression RPAREN .

    DIVIDE          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    TIMES           reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    PLUS            reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    MINUS           reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    MOD             reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    OR              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    AND             reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LSHIFT          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    RSHIFT          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LOGOR           reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LOGAND          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LT              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    GT              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LE              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    GE              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    EQ              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    NE              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    COMMENT         reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LBRACE          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    FOR             reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    PPHASH          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LPAREN          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    ID              reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    VOID            reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    SIZE_T          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    UNKNOWN         reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    CHAR            reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    SHORT           reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    INT             reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LONG            reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    FLOAT           reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    DOUBLE          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    SIGNED          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    UNSIGNED        reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    INT_CONST       reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    FLOAT_CONST     reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    STRING_LITERAL  reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    LOGNOT          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    $end            reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    RPAREN          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    SEMI            reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    RBRACE          reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)
    RBRACKET        reduce using rule 30 (binop -> LPAREN binop_expression RPAREN .)


state 119

    (22) assignment_expression -> typeid assignment_operator expr .

    SEMI            reduce using rule 22 (assignment_expression -> typeid assignment_operator expr .)


state 120

    (17) arglist -> LPAREN arg_params . RPAREN

    RPAREN          shift and go to state 133


state 121

    (16) arg_params -> empty .

    RPAREN          reduce using rule 16 (arg_params -> empty .)


state 122

    (14) arg_params -> binop .
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    RPAREN          reduce using rule 14 (arg_params -> binop .)
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77


state 123

    (13) arg_params -> typeid . COMMA arg_params
    (15) arg_params -> typeid .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 15 (arg_params -> typeid .)


state 124

    (12) arg_params -> term . COMMA arg_params
    (32) binop_expression -> term .

    COMMA           shift and go to state 135
    DIVIDE          reduce using rule 32 (binop_expression -> term .)
    TIMES           reduce using rule 32 (binop_expression -> term .)
    PLUS            reduce using rule 32 (binop_expression -> term .)
    MINUS           reduce using rule 32 (binop_expression -> term .)
    MOD             reduce using rule 32 (binop_expression -> term .)
    OR              reduce using rule 32 (binop_expression -> term .)
    AND             reduce using rule 32 (binop_expression -> term .)
    LSHIFT          reduce using rule 32 (binop_expression -> term .)
    RSHIFT          reduce using rule 32 (binop_expression -> term .)
    LOGOR           reduce using rule 32 (binop_expression -> term .)
    LOGAND          reduce using rule 32 (binop_expression -> term .)
    LT              reduce using rule 32 (binop_expression -> term .)
    GT              reduce using rule 32 (binop_expression -> term .)
    LE              reduce using rule 32 (binop_expression -> term .)
    GE              reduce using rule 32 (binop_expression -> term .)
    EQ              reduce using rule 32 (binop_expression -> term .)
    NE              reduce using rule 32 (binop_expression -> term .)
    RPAREN          reduce using rule 32 (binop_expression -> term .)


state 125

    (67) function_declaration -> typeid arglist SEMI .

    RBRACE          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    COMMENT         reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    LBRACE          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    FOR             reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    PPHASH          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    LPAREN          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    ID              reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    VOID            reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    SIZE_T          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    UNKNOWN         reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    CHAR            reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    SHORT           reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    INT             reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    LONG            reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    FLOAT           reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    DOUBLE          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    SIGNED          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    UNSIGNED        reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    INT_CONST       reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    FLOAT_CONST     reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    STRING_LITERAL  reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    MINUS           reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    LOGNOT          reduce using rule 67 (function_declaration -> typeid arglist SEMI .)
    $end            reduce using rule 67 (function_declaration -> typeid arglist SEMI .)


state 126

    (68) function_declaration -> typeid arglist compound .

    RBRACE          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    COMMENT         reduce using rule 68 (function_declaration -> typeid arglist compound .)
    LBRACE          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    FOR             reduce using rule 68 (function_declaration -> typeid arglist compound .)
    PPHASH          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    LPAREN          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    ID              reduce using rule 68 (function_declaration -> typeid arglist compound .)
    VOID            reduce using rule 68 (function_declaration -> typeid arglist compound .)
    SIZE_T          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    UNKNOWN         reduce using rule 68 (function_declaration -> typeid arglist compound .)
    CHAR            reduce using rule 68 (function_declaration -> typeid arglist compound .)
    SHORT           reduce using rule 68 (function_declaration -> typeid arglist compound .)
    INT             reduce using rule 68 (function_declaration -> typeid arglist compound .)
    LONG            reduce using rule 68 (function_declaration -> typeid arglist compound .)
    FLOAT           reduce using rule 68 (function_declaration -> typeid arglist compound .)
    DOUBLE          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    SIGNED          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    UNSIGNED        reduce using rule 68 (function_declaration -> typeid arglist compound .)
    INT_CONST       reduce using rule 68 (function_declaration -> typeid arglist compound .)
    FLOAT_CONST     reduce using rule 68 (function_declaration -> typeid arglist compound .)
    STRING_LITERAL  reduce using rule 68 (function_declaration -> typeid arglist compound .)
    MINUS           reduce using rule 68 (function_declaration -> typeid arglist compound .)
    LOGNOT          reduce using rule 68 (function_declaration -> typeid arglist compound .)
    $end            reduce using rule 68 (function_declaration -> typeid arglist compound .)


state 127

    (89) include -> PPHASH INCLUDE STRING_LITERAL .

    COMMENT         reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    LBRACE          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    FOR             reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    PPHASH          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    LPAREN          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    ID              reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    VOID            reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    SIZE_T          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    UNKNOWN         reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    CHAR            reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    SHORT           reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    INT             reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    LONG            reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    FLOAT           reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    DOUBLE          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    SIGNED          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    UNSIGNED        reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    INT_CONST       reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    FLOAT_CONST     reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    MINUS           reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    LOGNOT          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    $end            reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)
    RBRACE          reduce using rule 89 (include -> PPHASH INCLUDE STRING_LITERAL .)


state 128

    (50) subscript -> LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 136


state 129

    (23) assignment_expression -> identifier assignment_operator expr .

    SEMI            reduce using rule 23 (assignment_expression -> identifier assignment_operator expr .)


state 130

    (52) subscript_list -> subscript subscript_list .

    EQUALS          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    PLUSEQUALS      reduce using rule 52 (subscript_list -> subscript subscript_list .)
    MINUSEQUALS     reduce using rule 52 (subscript_list -> subscript subscript_list .)
    TIMESEQUALS     reduce using rule 52 (subscript_list -> subscript subscript_list .)
    DIVIDE          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    TIMES           reduce using rule 52 (subscript_list -> subscript subscript_list .)
    PLUS            reduce using rule 52 (subscript_list -> subscript subscript_list .)
    MINUS           reduce using rule 52 (subscript_list -> subscript subscript_list .)
    MOD             reduce using rule 52 (subscript_list -> subscript subscript_list .)
    OR              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    AND             reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LSHIFT          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    RSHIFT          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LOGOR           reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LOGAND          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LT              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    GT              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LE              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    GE              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    EQ              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    NE              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    COMMENT         reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LBRACE          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    FOR             reduce using rule 52 (subscript_list -> subscript subscript_list .)
    PPHASH          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LPAREN          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    ID              reduce using rule 52 (subscript_list -> subscript subscript_list .)
    VOID            reduce using rule 52 (subscript_list -> subscript subscript_list .)
    SIZE_T          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    UNKNOWN         reduce using rule 52 (subscript_list -> subscript subscript_list .)
    CHAR            reduce using rule 52 (subscript_list -> subscript subscript_list .)
    SHORT           reduce using rule 52 (subscript_list -> subscript subscript_list .)
    INT             reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LONG            reduce using rule 52 (subscript_list -> subscript subscript_list .)
    FLOAT           reduce using rule 52 (subscript_list -> subscript subscript_list .)
    DOUBLE          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    SIGNED          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    UNSIGNED        reduce using rule 52 (subscript_list -> subscript subscript_list .)
    INT_CONST       reduce using rule 52 (subscript_list -> subscript subscript_list .)
    FLOAT_CONST     reduce using rule 52 (subscript_list -> subscript subscript_list .)
    STRING_LITERAL  reduce using rule 52 (subscript_list -> subscript subscript_list .)
    LOGNOT          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    $end            reduce using rule 52 (subscript_list -> subscript subscript_list .)
    RBRACE          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    RPAREN          reduce using rule 52 (subscript_list -> subscript subscript_list .)
    SEMI            reduce using rule 52 (subscript_list -> subscript subscript_list .)
    RBRACKET        reduce using rule 52 (subscript_list -> subscript subscript_list .)
    COMMA           reduce using rule 52 (subscript_list -> subscript subscript_list .)
    PLUSPLUS        reduce using rule 52 (subscript_list -> subscript subscript_list .)
    MINUSMINUS      reduce using rule 52 (subscript_list -> subscript subscript_list .)


state 131

    (72) typeid -> type identifier .

    COMMA           reduce using rule 72 (typeid -> type identifier .)
    RPAREN          reduce using rule 72 (typeid -> type identifier .)
    EQUALS          reduce using rule 72 (typeid -> type identifier .)
    PLUSEQUALS      reduce using rule 72 (typeid -> type identifier .)
    MINUSEQUALS     reduce using rule 72 (typeid -> type identifier .)
    TIMESEQUALS     reduce using rule 72 (typeid -> type identifier .)


state 132

    (54) for_loop -> FOR LPAREN assignment_expression SEMI . binop SEMI increment RPAREN compound
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    LPAREN          shift and go to state 30
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 35
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 137
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    identifier                     shift and go to state 51

state 133

    (17) arglist -> LPAREN arg_params RPAREN .

    SEMI            reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    DIVIDE          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    TIMES           reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    PLUS            reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    MINUS           reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    MOD             reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    OR              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    AND             reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LSHIFT          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    RSHIFT          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LOGOR           reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LOGAND          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LT              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    GT              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LE              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    GE              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    EQ              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    NE              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    COMMENT         reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LBRACE          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    FOR             reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    PPHASH          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LPAREN          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    ID              reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    VOID            reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    SIZE_T          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    UNKNOWN         reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    CHAR            reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    SHORT           reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    INT             reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LONG            reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    FLOAT           reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    DOUBLE          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    SIGNED          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    UNSIGNED        reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    INT_CONST       reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    FLOAT_CONST     reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    STRING_LITERAL  reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    LOGNOT          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    $end            reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    RBRACE          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    RPAREN          reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    RBRACKET        reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    COMMA           reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    PLUSPLUS        reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)
    MINUSMINUS      reduce using rule 17 (arglist -> LPAREN arg_params RPAREN .)


state 134

    (13) arg_params -> typeid COMMA . arg_params
    (12) arg_params -> . term COMMA arg_params
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . binop
    (15) arg_params -> . typeid
    (16) arg_params -> . empty
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (72) typeid -> . type identifier
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (90) empty -> .
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (86) type -> . native_type
    (87) type -> . native_type TIMES
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT
    (74) native_type -> . VOID
    (75) native_type -> . SIZE_T
    (76) native_type -> . UNKNOWN
    (77) native_type -> . CHAR
    (78) native_type -> . SHORT
    (79) native_type -> . INT
    (80) native_type -> . LONG
    (81) native_type -> . FLOAT
    (82) native_type -> . DOUBLE
    (83) native_type -> . SIGNED
    (84) native_type -> . UNSIGNED

    LPAREN          shift and go to state 30
    RPAREN          reduce using rule 90 (empty -> .)
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14
    VOID            shift and go to state 9
    SIZE_T          shift and go to state 46
    UNKNOWN         shift and go to state 8
    CHAR            shift and go to state 13
    SHORT           shift and go to state 5
    INT             shift and go to state 39
    LONG            shift and go to state 15
    FLOAT           shift and go to state 41
    DOUBLE          shift and go to state 45
    SIGNED          shift and go to state 42
    UNSIGNED        shift and go to state 43

    typeid                         shift and go to state 123
    term                           shift and go to state 124
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 122
    unary_token_before             shift and go to state 7
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    native_type                    shift and go to state 16
    identifier                     shift and go to state 51
    type                           shift and go to state 96
    empty                          shift and go to state 121
    arg_params                     shift and go to state 138

state 135

    (12) arg_params -> term COMMA . arg_params
    (12) arg_params -> . term COMMA arg_params
    (13) arg_params -> . typeid COMMA arg_params
    (14) arg_params -> . binop
    (15) arg_params -> . typeid
    (16) arg_params -> . empty
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (72) typeid -> . type identifier
    (30) binop -> . LPAREN binop_expression RPAREN
    (31) binop -> . binop_expression
    (90) empty -> .
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (86) type -> . native_type
    (87) type -> . native_type TIMES
    (32) binop_expression -> . term
    (33) binop_expression -> . binop DIVIDE binop
    (34) binop_expression -> . binop TIMES binop
    (35) binop_expression -> . binop PLUS binop
    (36) binop_expression -> . binop MINUS binop
    (37) binop_expression -> . binop MOD binop
    (38) binop_expression -> . binop OR binop
    (39) binop_expression -> . binop AND binop
    (40) binop_expression -> . binop LSHIFT binop
    (41) binop_expression -> . binop RSHIFT binop
    (42) binop_expression -> . binop LOGOR binop
    (43) binop_expression -> . binop LOGAND binop
    (44) binop_expression -> . binop LT binop
    (45) binop_expression -> . binop GT binop
    (46) binop_expression -> . binop LE binop
    (47) binop_expression -> . binop GE binop
    (48) binop_expression -> . binop EQ binop
    (49) binop_expression -> . binop NE binop
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT
    (74) native_type -> . VOID
    (75) native_type -> . SIZE_T
    (76) native_type -> . UNKNOWN
    (77) native_type -> . CHAR
    (78) native_type -> . SHORT
    (79) native_type -> . INT
    (80) native_type -> . LONG
    (81) native_type -> . FLOAT
    (82) native_type -> . DOUBLE
    (83) native_type -> . SIGNED
    (84) native_type -> . UNSIGNED

    LPAREN          shift and go to state 30
    RPAREN          reduce using rule 90 (empty -> .)
    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14
    VOID            shift and go to state 9
    SIZE_T          shift and go to state 46
    UNKNOWN         shift and go to state 8
    CHAR            shift and go to state 13
    SHORT           shift and go to state 5
    INT             shift and go to state 39
    LONG            shift and go to state 15
    FLOAT           shift and go to state 41
    DOUBLE          shift and go to state 45
    SIGNED          shift and go to state 42
    UNSIGNED        shift and go to state 43

    typeid                         shift and go to state 123
    term                           shift and go to state 124
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    binop                          shift and go to state 122
    unary_token_before             shift and go to state 7
    array_reference                shift and go to state 50
    binop_expression               shift and go to state 12
    function_call                  shift and go to state 49
    native_type                    shift and go to state 16
    identifier                     shift and go to state 51
    type                           shift and go to state 96
    empty                          shift and go to state 121
    arg_params                     shift and go to state 139

state 136

    (50) subscript -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    EQUALS          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    PLUSEQUALS      reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    MINUSEQUALS     reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    TIMESEQUALS     reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    MOD             reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LSHIFT          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    RSHIFT          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LOGOR           reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LOGAND          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LE              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    GE              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    EQ              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    NE              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    COMMENT         reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    FOR             reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    PPHASH          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    ID              reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    VOID            reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    SIZE_T          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    UNKNOWN         reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    CHAR            reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    SHORT           reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    INT             reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LONG            reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    FLOAT           reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    DOUBLE          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    SIGNED          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    UNSIGNED        reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    INT_CONST       reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    FLOAT_CONST     reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    STRING_LITERAL  reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    LOGNOT          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    $end            reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    SEMI            reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    PLUSPLUS        reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)
    MINUSMINUS      reduce using rule 50 (subscript -> LBRACKET expr RBRACKET .)


state 137

    (54) for_loop -> FOR LPAREN assignment_expression SEMI binop . SEMI increment RPAREN compound
    (33) binop_expression -> binop . DIVIDE binop
    (34) binop_expression -> binop . TIMES binop
    (35) binop_expression -> binop . PLUS binop
    (36) binop_expression -> binop . MINUS binop
    (37) binop_expression -> binop . MOD binop
    (38) binop_expression -> binop . OR binop
    (39) binop_expression -> binop . AND binop
    (40) binop_expression -> binop . LSHIFT binop
    (41) binop_expression -> binop . RSHIFT binop
    (42) binop_expression -> binop . LOGOR binop
    (43) binop_expression -> binop . LOGAND binop
    (44) binop_expression -> binop . LT binop
    (45) binop_expression -> binop . GT binop
    (46) binop_expression -> binop . LE binop
    (47) binop_expression -> binop . GE binop
    (48) binop_expression -> binop . EQ binop
    (49) binop_expression -> binop . NE binop

    SEMI            shift and go to state 140
    DIVIDE          shift and go to state 66
    TIMES           shift and go to state 70
    PLUS            shift and go to state 73
    MINUS           shift and go to state 76
    MOD             shift and go to state 78
    OR              shift and go to state 63
    AND             shift and go to state 62
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 65
    LOGOR           shift and go to state 67
    LOGAND          shift and go to state 68
    LT              shift and go to state 71
    GT              shift and go to state 64
    LE              shift and go to state 72
    GE              shift and go to state 69
    EQ              shift and go to state 75
    NE              shift and go to state 77


state 138

    (13) arg_params -> typeid COMMA arg_params .

    RPAREN          reduce using rule 13 (arg_params -> typeid COMMA arg_params .)


state 139

    (12) arg_params -> term COMMA arg_params .

    RPAREN          reduce using rule 12 (arg_params -> term COMMA arg_params .)


state 140

    (54) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI . increment RPAREN compound
    (29) increment -> . term unary_token_after
    (60) term -> . identifier
    (61) term -> . constant
    (62) term -> . array_reference
    (63) term -> . function_call
    (64) term -> . unary_expression
    (88) identifier -> . ID
    (26) constant -> . INT_CONST
    (27) constant -> . FLOAT_CONST
    (28) constant -> . STRING_LITERAL
    (53) array_reference -> . identifier subscript_list
    (66) function_call -> . identifier arglist
    (59) unary_expression -> . unary_token_before term
    (55) unary_token_before -> . MINUS
    (56) unary_token_before -> . LOGNOT

    ID              shift and go to state 32
    INT_CONST       shift and go to state 20
    FLOAT_CONST     shift and go to state 21
    STRING_LITERAL  shift and go to state 33
    MINUS           shift and go to state 18
    LOGNOT          shift and go to state 14

    unary_token_before             shift and go to state 7
    term                           shift and go to state 142
    constant                       shift and go to state 17
    unary_expression               shift and go to state 6
    array_reference                shift and go to state 50
    function_call                  shift and go to state 49
    increment                      shift and go to state 141
    identifier                     shift and go to state 51

state 141

    (54) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment . RPAREN compound

    RPAREN          shift and go to state 143


state 142

    (29) increment -> term . unary_token_after
    (57) unary_token_after -> . PLUSPLUS
    (58) unary_token_after -> . MINUSMINUS

    PLUSPLUS        shift and go to state 144
    MINUSMINUS      shift and go to state 145

    unary_token_after              shift and go to state 146

state 143

    (54) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN . compound
    (65) compound -> . LBRACE top_level RBRACE

    LBRACE          shift and go to state 29

    compound                       shift and go to state 147

state 144

    (57) unary_token_after -> PLUSPLUS .

    RPAREN          reduce using rule 57 (unary_token_after -> PLUSPLUS .)


state 145

    (58) unary_token_after -> MINUSMINUS .

    RPAREN          reduce using rule 58 (unary_token_after -> MINUSMINUS .)


state 146

    (29) increment -> term unary_token_after .

    RPAREN          reduce using rule 29 (increment -> term unary_token_after .)


state 147

    (54) for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .

    COMMENT         reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LBRACE          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FOR             reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    PPHASH          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LPAREN          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    ID              reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    VOID            reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SIZE_T          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    UNKNOWN         reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    CHAR            reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SHORT           reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    INT             reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LONG            reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FLOAT           reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    DOUBLE          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    SIGNED          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    UNSIGNED        reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    INT_CONST       reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    FLOAT_CONST     reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    STRING_LITERAL  reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    MINUS           reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    LOGNOT          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    $end            reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)
    RBRACE          reduce using rule 54 (for_loop -> FOR LPAREN assignment_expression SEMI binop SEMI increment RPAREN compound .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 28 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 51 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 100 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 100 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MOD in state 100 resolved as shift
WARNING: shift/reduce conflict for OR in state 100 resolved as shift
WARNING: shift/reduce conflict for AND in state 100 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 100 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 100 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 100 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 100 resolved as shift
WARNING: shift/reduce conflict for LT in state 100 resolved as shift
WARNING: shift/reduce conflict for GT in state 100 resolved as shift
WARNING: shift/reduce conflict for LE in state 100 resolved as shift
WARNING: shift/reduce conflict for GE in state 100 resolved as shift
WARNING: shift/reduce conflict for EQ in state 100 resolved as shift
WARNING: shift/reduce conflict for NE in state 100 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 101 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 101 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MOD in state 101 resolved as shift
WARNING: shift/reduce conflict for OR in state 101 resolved as shift
WARNING: shift/reduce conflict for AND in state 101 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 101 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 101 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 101 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 101 resolved as shift
WARNING: shift/reduce conflict for LT in state 101 resolved as shift
WARNING: shift/reduce conflict for GT in state 101 resolved as shift
WARNING: shift/reduce conflict for LE in state 101 resolved as shift
WARNING: shift/reduce conflict for GE in state 101 resolved as shift
WARNING: shift/reduce conflict for EQ in state 101 resolved as shift
WARNING: shift/reduce conflict for NE in state 101 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 102 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MOD in state 102 resolved as shift
WARNING: shift/reduce conflict for OR in state 102 resolved as shift
WARNING: shift/reduce conflict for AND in state 102 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 102 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 102 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 102 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 102 resolved as shift
WARNING: shift/reduce conflict for LT in state 102 resolved as shift
WARNING: shift/reduce conflict for GT in state 102 resolved as shift
WARNING: shift/reduce conflict for LE in state 102 resolved as shift
WARNING: shift/reduce conflict for GE in state 102 resolved as shift
WARNING: shift/reduce conflict for EQ in state 102 resolved as shift
WARNING: shift/reduce conflict for NE in state 102 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 103 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 103 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MOD in state 103 resolved as shift
WARNING: shift/reduce conflict for OR in state 103 resolved as shift
WARNING: shift/reduce conflict for AND in state 103 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 103 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 103 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 103 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 103 resolved as shift
WARNING: shift/reduce conflict for LT in state 103 resolved as shift
WARNING: shift/reduce conflict for GT in state 103 resolved as shift
WARNING: shift/reduce conflict for LE in state 103 resolved as shift
WARNING: shift/reduce conflict for GE in state 103 resolved as shift
WARNING: shift/reduce conflict for EQ in state 103 resolved as shift
WARNING: shift/reduce conflict for NE in state 103 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MOD in state 105 resolved as shift
WARNING: shift/reduce conflict for OR in state 105 resolved as shift
WARNING: shift/reduce conflict for AND in state 105 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 105 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for LE in state 105 resolved as shift
WARNING: shift/reduce conflict for GE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for NE in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MOD in state 106 resolved as shift
WARNING: shift/reduce conflict for OR in state 106 resolved as shift
WARNING: shift/reduce conflict for AND in state 106 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 106 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 106 resolved as shift
WARNING: shift/reduce conflict for LT in state 106 resolved as shift
WARNING: shift/reduce conflict for GT in state 106 resolved as shift
WARNING: shift/reduce conflict for LE in state 106 resolved as shift
WARNING: shift/reduce conflict for GE in state 106 resolved as shift
WARNING: shift/reduce conflict for EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for NE in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MOD in state 107 resolved as shift
WARNING: shift/reduce conflict for OR in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 107 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LE in state 107 resolved as shift
WARNING: shift/reduce conflict for GE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for NE in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MOD in state 109 resolved as shift
WARNING: shift/reduce conflict for OR in state 109 resolved as shift
WARNING: shift/reduce conflict for AND in state 109 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 109 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 109 resolved as shift
WARNING: shift/reduce conflict for LT in state 109 resolved as shift
WARNING: shift/reduce conflict for GT in state 109 resolved as shift
WARNING: shift/reduce conflict for LE in state 109 resolved as shift
WARNING: shift/reduce conflict for GE in state 109 resolved as shift
WARNING: shift/reduce conflict for EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for NE in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MOD in state 110 resolved as shift
WARNING: shift/reduce conflict for OR in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 110 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 110 resolved as shift
WARNING: shift/reduce conflict for LT in state 110 resolved as shift
WARNING: shift/reduce conflict for GT in state 110 resolved as shift
WARNING: shift/reduce conflict for LE in state 110 resolved as shift
WARNING: shift/reduce conflict for GE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQ in state 110 resolved as shift
WARNING: shift/reduce conflict for NE in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MOD in state 112 resolved as shift
WARNING: shift/reduce conflict for OR in state 112 resolved as shift
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 112 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 112 resolved as shift
WARNING: shift/reduce conflict for LT in state 112 resolved as shift
WARNING: shift/reduce conflict for GT in state 112 resolved as shift
WARNING: shift/reduce conflict for LE in state 112 resolved as shift
WARNING: shift/reduce conflict for GE in state 112 resolved as shift
WARNING: shift/reduce conflict for EQ in state 112 resolved as shift
WARNING: shift/reduce conflict for NE in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MOD in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 113 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for LE in state 113 resolved as shift
WARNING: shift/reduce conflict for GE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for NE in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MOD in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 115 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for LE in state 115 resolved as shift
WARNING: shift/reduce conflict for GE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for NE in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MOD in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 116 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGOR in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for GE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for NE in state 116 resolved as shift
